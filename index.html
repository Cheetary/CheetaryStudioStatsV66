<html lang="en"><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Channel statistics!</title><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&amp;display=swap" rel="stylesheet"/></head><body><style>/*
! tailwindcss v3.4.4 | MIT License | https://tailwindcss.com
*/

/*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box;
  /* 1 */
  border-width: 0;
  /* 2 */
  border-style: solid;
  /* 2 */
  border-color: #e5e7eb;
  /* 2 */
}

::before,
::after {
  --tw-content: &#x27;&#x27;;
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user&#x27;s configured `sans` font-family by default.
5. Use the user&#x27;s configured `sans` font-feature-settings by default.
6. Use the user&#x27;s configured `sans` font-variation-settings by default.
7. Disable tap highlights on iOS
*/

html,
:host {
  line-height: 1.5;
  /* 1 */
  -webkit-text-size-adjust: 100%;
  /* 2 */
  -moz-tab-size: 4;
  /* 3 */
  -o-tab-size: 4;
     tab-size: 4;
  /* 3 */
  font-family: ui-sans-serif, system-ui, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;;
  /* 4 */
  font-feature-settings: normal;
  /* 5 */
  font-variation-settings: normal;
  /* 6 */
  -webkit-tap-highlight-color: transparent;
  /* 7 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.
*/

body {
  margin: 0;
  /* 1 */
  line-height: inherit;
  /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0;
  /* 1 */
  color: inherit;
  /* 2 */
  border-top-width: 1px;
  /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user&#x27;s configured `mono` font-family by default.
2. Use the user&#x27;s configured `mono` font-feature-settings by default.
3. Use the user&#x27;s configured `mono` font-variation-settings by default.
4. Correct the odd `em` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;
  /* 1 */
  font-feature-settings: normal;
  /* 2 */
  font-variation-settings: normal;
  /* 3 */
  font-size: 1em;
  /* 4 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent `sub` and `sup` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0;
  /* 1 */
  border-color: inherit;
  /* 2 */
  border-collapse: collapse;
  /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit;
  /* 1 */
  font-feature-settings: inherit;
  /* 1 */
  font-variation-settings: inherit;
  /* 1 */
  font-size: 100%;
  /* 1 */
  font-weight: inherit;
  /* 1 */
  line-height: inherit;
  /* 1 */
  letter-spacing: inherit;
  /* 1 */
  color: inherit;
  /* 1 */
  margin: 0;
  /* 2 */
  padding: 0;
  /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button,
input:where([type=&#x27;button&#x27;]),
input:where([type=&#x27;reset&#x27;]),
input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  /* 1 */
  background-color: transparent;
  /* 2 */
  background-image: none;
  /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
Remove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type=&#x27;search&#x27;] {
  -webkit-appearance: textfield;
  /* 1 */
  outline-offset: -2px;
  /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to `inherit` in Safari.
*/

::-webkit-file-upload-button {
  -webkit-appearance: button;
  /* 1 */
  font: inherit;
  /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Reset default styling for dialogs.
*/

dialog {
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user&#x27;s configured gray 400 color.
*/

input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1;
  /* 1 */
  color: #9ca3af;
  /* 2 */
}

input::placeholder,
textarea::placeholder {
  opacity: 1;
  /* 1 */
  color: #9ca3af;
  /* 2 */
}

/*
Set the default cursor for buttons.
*/

button,
[role=&quot;button&quot;] {
  cursor: pointer;
}

/*
Make sure disabled buttons don&#x27;t get the pointer cursor.
*/

:disabled {
  cursor: default;
}

/*
1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block;
  /* 1 */
  vertical-align: middle;
  /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */

[hidden] {
  display: none;
}

*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}

.m-auto {
  margin: auto;
}

.mx-auto {
  margin-left: auto;
  margin-right: auto;
}

.mt-1 {
  margin-top: 0.25rem;
}

.mt-2 {
  margin-top: 0.5rem;
}

.mt-5 {
  margin-top: 1.25rem;
}

.flex {
  display: flex;
}

.grid {
  display: grid;
}

.h-full {
  height: 100%;
}

.min-h-screen {
  min-height: 100vh;
}

.w-full {
  width: 100%;
}

.max-w-2xl {
  max-width: 42rem;
}

.max-w-5xl {
  max-width: 64rem;
}

.grid-cols-1 {
  grid-template-columns: repeat(1, minmax(0, 1fr));
}

.grid-cols-2 {
  grid-template-columns: repeat(2, minmax(0, 1fr));
}

.items-center {
  align-items: center;
}

.justify-center {
  justify-content: center;
}

.gap-1 {
  gap: 0.25rem;
}

.gap-2 {
  gap: 0.5rem;
}

.overflow-hidden {
  overflow: hidden;
}

.text-ellipsis {
  text-overflow: ellipsis;
}

.whitespace-nowrap {
  white-space: nowrap;
}

.rounded-full {
  border-radius: 9999px;
}

.rounded-md {
  border-radius: 0.375rem;
}

.bg-blue-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(96 165 250 / var(--tw-bg-opacity));
}

.bg-slate-800 {
  --tw-bg-opacity: 1;
  background-color: rgb(30 41 59 / var(--tw-bg-opacity));
}

.bg-zinc-900 {
  --tw-bg-opacity: 1;
  background-color: rgb(24 24 27 / var(--tw-bg-opacity));
}

.p-2 {
  padding: 0.5rem;
}

.p-4 {
  padding: 1rem;
}

.px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}

.text-center {
  text-align: center;
}

.text-2xl {
  font-size: 1.5rem;
  line-height: 2rem;
}

.text-4xl {
  font-size: 2.25rem;
  line-height: 2.5rem;
}

.text-5xl {
  font-size: 3rem;
  line-height: 1;
}

.text-sm {
  font-size: 0.875rem;
  line-height: 1.25rem;
}

.text-xl {
  font-size: 1.25rem;
  line-height: 1.75rem;
}

.text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}

.opacity-50 {
  opacity: 0.5;
}

.shadow-lg {
  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

body {
  font-family: Open Sans;
}

.odometer.odometer-auto-theme,
.odometer.odometer-auto-theme .odometer-digit,
.odometer.odometer-theme-default,
.odometer.odometer-theme-default .odometer-digit {
  display: inline-block;
  vertical-align: middle;
  position: relative;
}

.odometer.odometer-auto-theme .odometer-digit .odometer-digit-spacer,
.odometer.odometer-theme-default .odometer-digit .odometer-digit-spacer {
  display: inline-block;
  vertical-align: middle;
  visibility: hidden;
}

.odometer.odometer-auto-theme .odometer-digit .odometer-digit-inner,
.odometer.odometer-theme-default .odometer-digit .odometer-digit-inner {
  text-align: left;
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  overflow: hidden;
}

.odometer.odometer-auto-theme .odometer-digit .odometer-ribbon,
.odometer.odometer-theme-default .odometer-digit .odometer-ribbon {
  display: block;
}

.odometer.odometer-auto-theme .odometer-digit .odometer-ribbon-inner,
.odometer.odometer-theme-default .odometer-digit .odometer-ribbon-inner {
  display: block;
  backface-visibility: hidden;
}

.odometer.odometer-auto-theme .odometer-digit .odometer-value,
.odometer.odometer-theme-default .odometer-digit .odometer-value {
  display: block;
  transform: translateZ(0);
}

.odometer.odometer-auto-theme
  .odometer-digit
  .odometer-value.odometer-last-value,
.odometer.odometer-theme-default
  .odometer-digit
  .odometer-value.odometer-last-value {
  position: absolute;
}

.odometer.odometer-auto-theme.odometer-animating-up .odometer-ribbon-inner,
.odometer.odometer-theme-default.odometer-animating-up .odometer-ribbon-inner {
  transition: transform 2s;
}

.odometer.odometer-auto-theme.odometer-animating-down .odometer-ribbon-inner,
.odometer.odometer-auto-theme.odometer-animating-up.odometer-animating
  .odometer-ribbon-inner,
.odometer.odometer-theme-default.odometer-animating-down .odometer-ribbon-inner,
.odometer.odometer-theme-default.odometer-animating-up.odometer-animating
  .odometer-ribbon-inner {
  transform: translateY(-100%);
}

.odometer.odometer-auto-theme.odometer-animating-down.odometer-animating
  .odometer-ribbon-inner,
.odometer.odometer-theme-default.odometer-animating-down.odometer-animating
  .odometer-ribbon-inner {
  transition: transform 2s;
  transform: translateY(0);
}

.odometer.odometer-auto-theme,
.odometer.odometer-theme-default {
  line-height: 1.1em;
}

.odometer.odometer-auto-theme .odometer-value,
.odometer.odometer-theme-default .odometer-value {
  text-align: center;
}

.odometer-formatting-mark {
  vertical-align: bottom;
}

@media (min-width: 640px) {
  .sm\:grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}

@media (min-width: 768px) {
  .md\:grid-cols-4 {
    grid-template-columns: repeat(4, minmax(0, 1fr));
  }

  .md\:text-3xl {
    font-size: 1.875rem;
    line-height: 2.25rem;
  }

  .md\:text-7xl {
    font-size: 4.5rem;
    line-height: 1;
  }
}</style><script>// public_scripts/channel.ts
async function getData() {
  if (!getOdometer)
    getOdometer = document.getElementById("odo");
  if (sideCounts.length == 0)
    sideCounts = document.querySelectorAll(".sidecounters");
  const data = await fetch("/api?id=" + getID).then((resp) => resp.json());
  if (getOdometer != null)
    getOdometer.innerHTML = data.channels.counts.filter((a) => a.type == otherWay.find((ab) => ab[1] == getType)?.[0])[0].count;
  if (sideCounts.length > 0) {
    for (let [idx, i] of data.channels.counts.filter((a) => a.type != otherWay.find((ab) => ab[1] == getType)?.[0]).entries()) {
      sideCounts[idx].innerHTML = i.count;
    }
  }
}

// node_modules/highcharts/es-modules/Core/Globals.js
var Globals;
(function(Globals2) {
  Globals2.SVG_NS = "http://www.w3.org/2000/svg", Globals2.product = "Highcharts", Globals2.version = "@product.version@", Globals2.win = typeof window !== "undefined" ? window : {}, Globals2.doc = Globals2.win.document, Globals2.svg = Globals2.doc && Globals2.doc.createElementNS && !!Globals2.doc.createElementNS(Globals2.SVG_NS, "svg").createSVGRect, Globals2.userAgent = Globals2.win.navigator && Globals2.win.navigator.userAgent || "", Globals2.isChrome = Globals2.win.chrome, Globals2.isFirefox = Globals2.userAgent.indexOf("Firefox") !== -1, Globals2.isMS = /(edge|msie|trident)/i.test(Globals2.userAgent) && !Globals2.win.opera, Globals2.isSafari = !Globals2.isChrome && Globals2.userAgent.indexOf("Safari") !== -1, Globals2.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(Globals2.userAgent), Globals2.isWebKit = Globals2.userAgent.indexOf("AppleWebKit") !== -1, Globals2.deg2rad = Math.PI * 2 / 360, Globals2.hasBidiBug = Globals2.isFirefox && parseInt(Globals2.userAgent.split("Firefox/")[1], 10) < 4, Globals2.marginNames = [
    "plotTop",
    "marginRight",
    "marginBottom",
    "plotLeft"
  ], Globals2.noop = function() {
  }, Globals2.supportsPassiveEvents = function() {
    let supportsPassive = false;
    if (!Globals2.isMS) {
      const opts = Object.defineProperty({}, "passive", {
        get: function() {
          supportsPassive = true;
        }
      });
      if (Globals2.win.addEventListener && Globals2.win.removeEventListener) {
        Globals2.win.addEventListener("testPassive", Globals2.noop, opts);
        Globals2.win.removeEventListener("testPassive", Globals2.noop, opts);
      }
    }
    return supportsPassive;
  }();
  Globals2.charts = [];
  Globals2.composed = [];
  Globals2.dateFormats = {};
  Globals2.seriesTypes = {};
  Globals2.symbolSizes = {};
  Globals2.chartCount = 0;
})(Globals || (Globals = {}));
var Globals_default = Globals;

// node_modules/highcharts/es-modules/Core/Utilities.js
var error = function(code, stop, chart, params) {
  const severity = stop ? "Highcharts error" : "Highcharts warning";
  if (code === 32) {
    code = `${severity}: Deprecated member`;
  }
  const isCode = isNumber(code);
  let message = isCode ? `${severity} #${code}: www.highcharts.com/errors/${code}/` : code.toString();
  const defaultHandler = function() {
    if (stop) {
      throw new Error(message);
    }
    if (win.console && error.messages.indexOf(message) === -1) {
      console.warn(message);
    }
  };
  if (typeof params !== "undefined") {
    let additionalMessages = "";
    if (isCode) {
      message += "?";
    }
    objectEach(params, function(value, key) {
      additionalMessages += `\n - ${key}: ${value}`;
      if (isCode) {
        message += encodeURI(key) + "=" + encodeURI(value);
      }
    });
    message += additionalMessages;
  }
  fireEvent(Globals_default, "displayError", { chart, code, message, params }, defaultHandler);
  error.messages.push(message);
};
var merge = function() {
  let i, args = arguments, ret = {};
  const doCopy = function(copy, original) {
    if (typeof copy !== "object") {
      copy = {};
    }
    objectEach(original, function(value, key) {
      if (key === "__proto__" || key === "constructor") {
        return;
      }
      if (isObject(value, true) && !isClass(value) && !isDOMElement(value)) {
        copy[key] = doCopy(copy[key] || {}, value);
      } else {
        copy[key] = original[key];
      }
    });
    return copy;
  };
  if (args[0] === true) {
    ret = args[1];
    args = Array.prototype.slice.call(args, 2);
  }
  const len = args.length;
  for (i = 0;i < len; i++) {
    ret = doCopy(ret, args[i]);
  }
  return ret;
};
var clamp = function(value, min, max) {
  return value > min ? value < max ? value : max : min;
};
var diffObjects = function(newer, older, keepOlder, collectionsWithUpdate) {
  const ret = {};
  function diff(newer2, older2, ret2, depth) {
    const keeper = keepOlder ? older2 : newer2;
    objectEach(newer2, function(newerVal, key) {
      if (!depth && collectionsWithUpdate && collectionsWithUpdate.indexOf(key) > -1 && older2[key]) {
        newerVal = splat(newerVal);
        ret2[key] = [];
        for (let i = 0;i < Math.max(newerVal.length, older2[key].length); i++) {
          if (older2[key][i]) {
            if (newerVal[i] === undefined) {
              ret2[key][i] = older2[key][i];
            } else {
              ret2[key][i] = {};
              diff(newerVal[i], older2[key][i], ret2[key][i], depth + 1);
            }
          }
        }
      } else if (isObject(newerVal, true) && !newerVal.nodeType) {
        ret2[key] = isArray(newerVal) ? [] : {};
        diff(newerVal, older2[key] || {}, ret2[key], depth + 1);
        if (Object.keys(ret2[key]).length === 0 && !(key === "colorAxis" && depth === 0)) {
          delete ret2[key];
        }
      } else if (newer2[key] !== older2[key] || key in newer2 && !(key in older2)) {
        if (key !== "__proto__" && key !== "constructor") {
          ret2[key] = keeper[key];
        }
      }
    });
  }
  diff(newer, older, ret, 0);
  return ret;
};
var pInt = function(s, mag) {
  return parseInt(s, mag || 10);
};
var isString = function(s) {
  return typeof s === "string";
};
var isArray = function(obj) {
  const str = Object.prototype.toString.call(obj);
  return str === "[object Array]" || str === "[object Array Iterator]";
};
var isObject = function(obj, strict) {
  return !!obj && typeof obj === "object" && (!strict || !isArray(obj));
};
var isDOMElement = function(obj) {
  return isObject(obj) && typeof obj.nodeType === "number";
};
var isClass = function(obj) {
  const c = obj && obj.constructor;
  return !!(isObject(obj, true) && !isDOMElement(obj) && (c && c.name && c.name !== "Object"));
};
var isNumber = function(n) {
  return typeof n === "number" && !isNaN(n) && n < Infinity && n > -Infinity;
};
var erase = function(arr, item) {
  let i = arr.length;
  while (i--) {
    if (arr[i] === item) {
      arr.splice(i, 1);
      break;
    }
  }
};
var insertItem = function(item, collection) {
  const indexOption = item.options.index, length = collection.length;
  let i;
  for (i = item.options.isInternal ? length : 0;i < length + 1; i++) {
    if (!collection[i] || isNumber(indexOption) && indexOption < pick(collection[i].options.index, collection[i]._i) || collection[i].options.isInternal) {
      collection.splice(i, 0, item);
      break;
    }
  }
  return i;
};
var pushUnique = function(array, item) {
  return array.indexOf(item) < 0 && !!array.push(item);
};
var defined = function(obj) {
  return typeof obj !== "undefined" && obj !== null;
};
var attr = function(elem, keyOrAttribs, value) {
  const isGetter = isString(keyOrAttribs) && !defined(value);
  let ret;
  const attrSingle = (value2, key) => {
    if (defined(value2)) {
      elem.setAttribute(key, value2);
    } else if (isGetter) {
      ret = elem.getAttribute(key);
      if (!ret && key === "class") {
        ret = elem.getAttribute(key + "Name");
      }
    } else {
      elem.removeAttribute(key);
    }
  };
  if (isString(keyOrAttribs)) {
    attrSingle(value, keyOrAttribs);
  } else {
    objectEach(keyOrAttribs, attrSingle);
  }
  return ret;
};
var splat = function(obj) {
  return isArray(obj) ? obj : [obj];
};
var syncTimeout = function(fn, delay, context) {
  if (delay > 0) {
    return setTimeout(fn, delay, context);
  }
  fn.call(0, context);
  return -1;
};
var internalClearTimeout = function(id) {
  if (defined(id)) {
    clearTimeout(id);
  }
};
var extend = function(a, b) {
  let n;
  if (!a) {
    a = {};
  }
  for (n in b) {
    a[n] = b[n];
  }
  return a;
};
var pick = function() {
  const args = arguments;
  const length = args.length;
  for (let i = 0;i < length; i++) {
    const arg = args[i];
    if (typeof arg !== "undefined" && arg !== null) {
      return arg;
    }
  }
};
var css = function(el, styles) {
  extend(el.style, styles);
};
var createElement = function(tag, attribs, styles, parent, nopad) {
  const el = doc.createElement(tag);
  if (attribs) {
    extend(el, attribs);
  }
  if (nopad) {
    css(el, { padding: "0", border: "none", margin: "0" });
  }
  if (styles) {
    css(el, styles);
  }
  if (parent) {
    parent.appendChild(el);
  }
  return el;
};
var extendClass = function(parent, members) {
  const obj = function() {
  };
  obj.prototype = new parent;
  extend(obj.prototype, members);
  return obj;
};
var pad = function(number, length, padder) {
  return new Array((length || 2) + 1 - String(number).replace("-", "").length).join(padder || "0") + number;
};
var relativeLength = function(value, base, offset) {
  return /%$/.test(value) ? base * parseFloat(value) / 100 + (offset || 0) : parseFloat(value);
};
var replaceNested = function(text, ...replacements) {
  let previous, replacement;
  do {
    previous = text;
    for (replacement of replacements) {
      text = text.replace(replacement[0], replacement[1]);
    }
  } while (text !== previous);
  return text;
};
var wrap = function(obj, method, func) {
  const proceed = obj[method];
  obj[method] = function() {
    const outerArgs = arguments, scope = this;
    return func.apply(this, [
      function() {
        return proceed.apply(scope, arguments.length ? arguments : outerArgs);
      }
    ].concat([].slice.call(arguments)));
  };
};
var getMagnitude = function(num) {
  return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
};
var normalizeTickInterval = function(interval, multiples, magnitude, allowDecimals, hasTickAmount) {
  let i, retInterval = interval;
  magnitude = pick(magnitude, getMagnitude(interval));
  const normalized = interval / magnitude;
  if (!multiples) {
    multiples = hasTickAmount ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10];
    if (allowDecimals === false) {
      if (magnitude === 1) {
        multiples = multiples.filter(function(num) {
          return num % 1 === 0;
        });
      } else if (magnitude <= 0.1) {
        multiples = [1 / magnitude];
      }
    }
  }
  for (i = 0;i < multiples.length; i++) {
    retInterval = multiples[i];
    if (hasTickAmount && retInterval * magnitude >= interval || !hasTickAmount && normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
      break;
    }
  }
  retInterval = correctFloat(retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10));
  return retInterval;
};
var stableSort = function(arr, sortFunction) {
  const length = arr.length;
  let sortValue, i;
  for (i = 0;i < length; i++) {
    arr[i].safeI = i;
  }
  arr.sort(function(a, b) {
    sortValue = sortFunction(a, b);
    return sortValue === 0 ? a.safeI - b.safeI : sortValue;
  });
  for (i = 0;i < length; i++) {
    delete arr[i].safeI;
  }
};
var arrayMin = function(data) {
  let i = data.length, min = data[0];
  while (i--) {
    if (data[i] < min) {
      min = data[i];
    }
  }
  return min;
};
var arrayMax = function(data) {
  let i = data.length, max = data[0];
  while (i--) {
    if (data[i] > max) {
      max = data[i];
    }
  }
  return max;
};
var destroyObjectProperties = function(obj, except, destructablesOnly) {
  objectEach(obj, function(val, n) {
    if (val !== except && val?.destroy) {
      val.destroy();
    }
    if (val?.destroy || !destructablesOnly) {
      delete obj[n];
    }
  });
};
var discardElement = function(element) {
  if (element && element.parentElement) {
    element.parentElement.removeChild(element);
  }
};
var correctFloat = function(num, prec) {
  return num > 100000000000000 ? num : parseFloat(num.toPrecision(prec || 14));
};
var getClosestDistance = function(arrays, onError) {
  const allowNegative = !onError;
  let closest, loopLength, distance, i;
  arrays.forEach((xData) => {
    if (xData.length > 1) {
      loopLength = xData.length - 1;
      for (i = loopLength;i > 0; i--) {
        distance = xData[i] - xData[i - 1];
        if (distance < 0 && !allowNegative) {
          onError?.();
          onError = undefined;
        } else if (distance && (typeof closest === "undefined" || distance < closest)) {
          closest = distance;
        }
      }
    }
  });
  return closest;
};
var getNestedProperty = function(path, parent) {
  const pathElements = path.split(".");
  while (pathElements.length && defined(parent)) {
    const pathElement = pathElements.shift();
    if (typeof pathElement === "undefined" || pathElement === "__proto__") {
      return;
    }
    if (pathElement === "this") {
      let thisProp;
      if (isObject(parent)) {
        thisProp = parent["@this"];
      }
      return thisProp ?? parent;
    }
    const child = parent[pathElement];
    if (!defined(child) || typeof child === "function" || typeof child.nodeType === "number" || child === win) {
      return;
    }
    parent = child;
  }
  return parent;
};
var getStyle = function(el, prop, toInt) {
  let style;
  if (prop === "width") {
    let offsetWidth = Math.min(el.offsetWidth, el.scrollWidth);
    const boundingClientRectWidth = el.getBoundingClientRect && el.getBoundingClientRect().width;
    if (boundingClientRectWidth < offsetWidth && boundingClientRectWidth >= offsetWidth - 1) {
      offsetWidth = Math.floor(boundingClientRectWidth);
    }
    return Math.max(0, offsetWidth - (getStyle(el, "padding-left", true) || 0) - (getStyle(el, "padding-right", true) || 0));
  }
  if (prop === "height") {
    return Math.max(0, Math.min(el.offsetHeight, el.scrollHeight) - (getStyle(el, "padding-top", true) || 0) - (getStyle(el, "padding-bottom", true) || 0));
  }
  const css2 = win.getComputedStyle(el, undefined);
  if (css2) {
    style = css2.getPropertyValue(prop);
    if (pick(toInt, prop !== "opacity")) {
      style = pInt(style);
    }
  }
  return style;
};
var inArray = function(item, arr, fromIndex) {
  error(32, false, undefined, { "Highcharts.inArray": "use Array.indexOf" });
  return arr.indexOf(item, fromIndex);
};
var keys = function(obj) {
  error(32, false, undefined, { "Highcharts.keys": "use Object.keys" });
  return Object.keys(obj);
};
var offset = function(el) {
  const docElem = doc.documentElement, box = el.parentElement || el.parentNode ? el.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 };
  return {
    top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
    left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),
    width: box.width,
    height: box.height
  };
};
var objectEach = function(obj, fn, ctx) {
  for (const key in obj) {
    if (Object.hasOwnProperty.call(obj, key)) {
      fn.call(ctx || obj[key], obj[key], key, obj);
    }
  }
};
var addEvent = function(el, type, fn, options = {}) {
  const owner = typeof el === "function" && el.prototype || el;
  if (!Object.hasOwnProperty.call(owner, "hcEvents")) {
    owner.hcEvents = {};
  }
  const events = owner.hcEvents;
  if (Globals_default.Point && el instanceof Globals_default.Point && el.series && el.series.chart) {
    el.series.chart.runTrackerClick = true;
  }
  const addEventListener = el.addEventListener;
  if (addEventListener) {
    addEventListener.call(el, type, fn, Globals_default.supportsPassiveEvents ? {
      passive: options.passive === undefined ? type.indexOf("touch") !== -1 : options.passive,
      capture: false
    } : false);
  }
  if (!events[type]) {
    events[type] = [];
  }
  const eventObject = {
    fn,
    order: typeof options.order === "number" ? options.order : Infinity
  };
  events[type].push(eventObject);
  events[type].sort((a, b) => a.order - b.order);
  return function() {
    removeEvent(el, type, fn);
  };
};
var removeEvent = function(el, type, fn) {
  function removeOneEvent(type2, fn2) {
    const removeEventListener = el.removeEventListener;
    if (removeEventListener) {
      removeEventListener.call(el, type2, fn2, false);
    }
  }
  function removeAllEvents(eventCollection) {
    let types, len;
    if (!el.nodeName) {
      return;
    }
    if (type) {
      types = {};
      types[type] = true;
    } else {
      types = eventCollection;
    }
    objectEach(types, function(_val, n) {
      if (eventCollection[n]) {
        len = eventCollection[n].length;
        while (len--) {
          removeOneEvent(n, eventCollection[n][len].fn);
        }
      }
    });
  }
  const owner = typeof el === "function" && el.prototype || el;
  if (Object.hasOwnProperty.call(owner, "hcEvents")) {
    const events = owner.hcEvents;
    if (type) {
      const typeEvents = events[type] || [];
      if (fn) {
        events[type] = typeEvents.filter(function(obj) {
          return fn !== obj.fn;
        });
        removeOneEvent(type, fn);
      } else {
        removeAllEvents(events);
        events[type] = [];
      }
    } else {
      removeAllEvents(events);
      delete owner.hcEvents;
    }
  }
};
var fireEvent = function(el, type, eventArguments, defaultFunction) {
  eventArguments = eventArguments || {};
  if (doc.createEvent && (el.dispatchEvent || el.fireEvent && el !== Globals_default)) {
    const e = doc.createEvent("Events");
    e.initEvent(type, true, true);
    eventArguments = extend(e, eventArguments);
    if (el.dispatchEvent) {
      el.dispatchEvent(eventArguments);
    } else {
      el.fireEvent(type, eventArguments);
    }
  } else if (el.hcEvents) {
    if (!eventArguments.target) {
      extend(eventArguments, {
        preventDefault: function() {
          eventArguments.defaultPrevented = true;
        },
        target: el,
        type
      });
    }
    const events = [];
    let object = el;
    let multilevel = false;
    while (object.hcEvents) {
      if (Object.hasOwnProperty.call(object, "hcEvents") && object.hcEvents[type]) {
        if (events.length) {
          multilevel = true;
        }
        events.unshift.apply(events, object.hcEvents[type]);
      }
      object = Object.getPrototypeOf(object);
    }
    if (multilevel) {
      events.sort((a, b) => a.order - b.order);
    }
    events.forEach((obj) => {
      if (obj.fn.call(el, eventArguments) === false) {
        eventArguments.preventDefault();
      }
    });
  }
  if (defaultFunction && !eventArguments.defaultPrevented) {
    defaultFunction.call(el, eventArguments);
  }
};
var useSerialIds = function(mode) {
  return serialMode = pick(mode, serialMode);
};
var isFunction = function(obj) {
  return typeof obj === "function";
};
var { charts, doc, win } = Globals_default;
(function(error2) {
  error2.messages = [];
})(error || (error = {}));
var crisp = (value, lineWidth = 0, inverted) => {
  const mod = lineWidth % 2 / 2, inverter = inverted ? -1 : 1;
  return (Math.round(value * inverter - mod) + mod) * inverter;
};
var timeUnits = {
  millisecond: 1,
  second: 1000,
  minute: 60000,
  hour: 3600000,
  day: 24 * 3600000,
  week: 7 * 24 * 3600000,
  month: 28 * 24 * 3600000,
  year: 364 * 24 * 3600000
};
Math.easeInOutSine = function(pos) {
  return -0.5 * (Math.cos(Math.PI * pos) - 1);
};
var find = Array.prototype.find ? function(arr, callback) {
  return arr.find(callback);
} : function(arr, callback) {
  let i;
  const length = arr.length;
  for (i = 0;i < length; i++) {
    if (callback(arr[i], i)) {
      return arr[i];
    }
  }
};
objectEach({
  map: "map",
  each: "forEach",
  grep: "filter",
  reduce: "reduce",
  some: "some"
}, function(val, key) {
  Globals_default[key] = function(arr) {
    error(32, false, undefined, { [`Highcharts.${key}`]: `use Array.${val}` });
    return Array.prototype[val].apply(arr, [].slice.call(arguments, 1));
  };
});
var serialMode;
var uniqueKey = function() {
  const hash = Math.random().toString(36).substring(2, 9) + "-";
  let id = 0;
  return function() {
    return "highcharts-" + (serialMode ? "" : hash) + id++;
  };
}();
if (win.jQuery) {
  win.jQuery.fn.highcharts = function() {
    const args = [].slice.call(arguments);
    if (this[0]) {
      if (args[0]) {
        new Globals_default[isString(args[0]) ? args.shift() : "Chart"](this[0], args[0], args[1]);
        return this;
      }
      return charts[attr(this[0], "data-highcharts-chart")];
    }
  };
}
var Utilities = {
  addEvent,
  arrayMax,
  arrayMin,
  attr,
  clamp,
  clearTimeout: internalClearTimeout,
  correctFloat,
  createElement,
  crisp,
  css,
  defined,
  destroyObjectProperties,
  diffObjects,
  discardElement,
  erase,
  error,
  extend,
  extendClass,
  find,
  fireEvent,
  getClosestDistance,
  getMagnitude,
  getNestedProperty,
  getStyle,
  inArray,
  insertItem,
  isArray,
  isClass,
  isDOMElement,
  isFunction,
  isNumber,
  isObject,
  isString,
  keys,
  merge,
  normalizeTickInterval,
  objectEach,
  offset,
  pad,
  pick,
  pInt,
  pushUnique,
  relativeLength,
  removeEvent,
  replaceNested,
  splat,
  stableSort,
  syncTimeout,
  timeUnits,
  uniqueKey,
  useSerialIds,
  wrap
};
var Utilities_default = Utilities;

// node_modules/highcharts/es-modules/Core/Chart/ChartDefaults.js
var ChartDefaults = {
  alignThresholds: false,
  panning: {
    enabled: false,
    type: "x"
  },
  styledMode: false,
  borderRadius: 0,
  colorCount: 10,
  allowMutatingData: true,
  ignoreHiddenSeries: true,
  spacing: [10, 10, 15, 10],
  resetZoomButton: {
    theme: {},
    position: {}
  },
  reflow: true,
  type: "line",
  zooming: {
    singleTouch: false,
    resetButton: {
      theme: {
        zIndex: 6
      },
      position: {
        align: "right",
        x: -10,
        y: 10
      }
    }
  },
  width: null,
  height: null,
  borderColor: "#334eff",
  backgroundColor: "#ffffff",
  plotBorderColor: "#cccccc"
};
var ChartDefaults_default = ChartDefaults;

// node_modules/highcharts/es-modules/Core/Color/Palettes.js
var SeriesPalettes = {
  colors: [
    "#2caffe",
    "#544fc5",
    "#00e272",
    "#fe6a35",
    "#6b8abc",
    "#d568fb",
    "#2ee0ca",
    "#fa4b42",
    "#feb56a",
    "#91e8e1"
  ]
};
var Palettes_default = SeriesPalettes;

// node_modules/highcharts/es-modules/Core/Time.js
var { win: win2 } = Globals_default;
var { defined: defined2, error: error2, extend: extend2, isNumber: isNumber2, isObject: isObject2, merge: merge2, objectEach: objectEach2, pad: pad2, pick: pick2, splat: splat2, timeUnits: timeUnits2 } = Utilities_default;
var hasNewSafariBug = Globals_default.isSafari && win2.Intl && win2.Intl.DateTimeFormat.prototype.formatRange;
var hasOldSafariBug = Globals_default.isSafari && win2.Intl && !win2.Intl.DateTimeFormat.prototype.formatRange;

class Time {
  constructor(options) {
    this.options = {};
    this.useUTC = false;
    this.variableTimezone = false;
    this.Date = win2.Date;
    this.getTimezoneOffset = this.timezoneOffsetFunction();
    this.update(options);
  }
  get(unit, date) {
    if (this.variableTimezone || this.timezoneOffset) {
      const realMs = date.getTime();
      const ms = realMs - this.getTimezoneOffset(date);
      date.setTime(ms);
      const ret = date["getUTC" + unit]();
      date.setTime(realMs);
      return ret;
    }
    if (this.useUTC) {
      return date["getUTC" + unit]();
    }
    return date["get" + unit]();
  }
  set(unit, date, value) {
    if (this.variableTimezone || this.timezoneOffset) {
      if (unit === "Milliseconds" || unit === "Seconds" || unit === "Minutes" && this.getTimezoneOffset(date) % 3600000 === 0) {
        return date["setUTC" + unit](value);
      }
      const offset2 = this.getTimezoneOffset(date);
      let ms = date.getTime() - offset2;
      date.setTime(ms);
      date["setUTC" + unit](value);
      const newOffset = this.getTimezoneOffset(date);
      ms = date.getTime() + newOffset;
      return date.setTime(ms);
    }
    if (this.useUTC || hasNewSafariBug && unit === "FullYear") {
      return date["setUTC" + unit](value);
    }
    return date["set" + unit](value);
  }
  update(options = {}) {
    const useUTC = pick2(options.useUTC, true);
    this.options = options = merge2(true, this.options, options);
    this.Date = options.Date || win2.Date || Date;
    this.useUTC = useUTC;
    this.timezoneOffset = useUTC && options.timezoneOffset || undefined;
    this.getTimezoneOffset = this.timezoneOffsetFunction();
    this.variableTimezone = useUTC && !!(options.getTimezoneOffset || options.timezone);
  }
  makeTime(year, month, date, hours, minutes, seconds) {
    let d, offset2, newOffset;
    if (this.useUTC) {
      d = this.Date.UTC.apply(0, arguments);
      offset2 = this.getTimezoneOffset(d);
      d += offset2;
      newOffset = this.getTimezoneOffset(d);
      if (offset2 !== newOffset) {
        d += newOffset - offset2;
      } else if (offset2 - 3600000 === this.getTimezoneOffset(d - 3600000) && !hasOldSafariBug) {
        d -= 3600000;
      }
    } else {
      d = new this.Date(year, month, pick2(date, 1), pick2(hours, 0), pick2(minutes, 0), pick2(seconds, 0)).getTime();
    }
    return d;
  }
  timezoneOffsetFunction() {
    const time = this, options = this.options, getTimezoneOffset = options.getTimezoneOffset;
    if (!this.useUTC) {
      return (timestamp) => new Date(timestamp.toString()).getTimezoneOffset() * 60000;
    }
    if (options.timezone) {
      return (timestamp) => {
        try {
          const cacheKey = `shortOffset,${options.timezone || ""}`, dateTimeFormat = Time.formatCache[cacheKey] = Time.formatCache[cacheKey] || Intl.DateTimeFormat("en", {
            timeZone: options.timezone,
            timeZoneName: "shortOffset"
          });
          const [date, gmt, hours, colon, minutes = 0] = dateTimeFormat.format(timestamp).split(/(GMT|:)/).map(Number), offset2 = -(hours + minutes / 60) * 60 * 60000;
          if (isNumber2(offset2)) {
            return offset2;
          }
        } catch (e) {
          error2(34);
        }
        return 0;
      };
    }
    if (this.useUTC && getTimezoneOffset) {
      return (timestamp) => getTimezoneOffset(timestamp.valueOf()) * 60000;
    }
    return () => (time.timezoneOffset || 0) * 60000;
  }
  dateFormat(format, timestamp, capitalize) {
    if (!defined2(timestamp) || isNaN(timestamp)) {
      return Globals_default.defaultOptions.lang && Globals_default.defaultOptions.lang.invalidDate || "";
    }
    format = pick2(format, "%Y-%m-%d %H:%M:%S");
    const time = this, date = new this.Date(timestamp), hours = this.get("Hours", date), day = this.get("Day", date), dayOfMonth = this.get("Date", date), month = this.get("Month", date), fullYear = this.get("FullYear", date), lang = Globals_default.defaultOptions.lang, langWeekdays = lang && lang.weekdays, shortWeekdays = lang && lang.shortWeekdays, replacements = extend2({
      a: shortWeekdays ? shortWeekdays[day] : langWeekdays[day].substr(0, 3),
      A: langWeekdays[day],
      d: pad2(dayOfMonth),
      e: pad2(dayOfMonth, 2, " "),
      w: day,
      b: lang.shortMonths[month],
      B: lang.months[month],
      m: pad2(month + 1),
      o: month + 1,
      y: fullYear.toString().substr(2, 2),
      Y: fullYear,
      H: pad2(hours),
      k: hours,
      I: pad2(hours % 12 || 12),
      l: hours % 12 || 12,
      M: pad2(this.get("Minutes", date)),
      p: hours < 12 ? "AM" : "PM",
      P: hours < 12 ? "am" : "pm",
      S: pad2(this.get("Seconds", date)),
      L: pad2(Math.floor(timestamp % 1000), 3)
    }, Globals_default.dateFormats);
    objectEach2(replacements, function(val, key) {
      while (format.indexOf("%" + key) !== -1) {
        format = format.replace("%" + key, typeof val === "function" ? val.call(time, timestamp) : val);
      }
    });
    return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
  }
  resolveDTLFormat(f) {
    if (!isObject2(f, true)) {
      f = splat2(f);
      return {
        main: f[0],
        from: f[1],
        to: f[2]
      };
    }
    return f;
  }
  getTimeTicks(normalizedInterval, min, max, startOfWeek) {
    const time = this, Date2 = time.Date, tickPositions = [], higherRanks = {}, minDate = new Date2(min), interval = normalizedInterval.unitRange, count = normalizedInterval.count || 1;
    let i, minYear, variableDayLength, minDay;
    startOfWeek = pick2(startOfWeek, 1);
    if (defined2(min)) {
      time.set("Milliseconds", minDate, interval >= timeUnits2.second ? 0 : count * Math.floor(time.get("Milliseconds", minDate) / count));
      if (interval >= timeUnits2.second) {
        time.set("Seconds", minDate, interval >= timeUnits2.minute ? 0 : count * Math.floor(time.get("Seconds", minDate) / count));
      }
      if (interval >= timeUnits2.minute) {
        time.set("Minutes", minDate, interval >= timeUnits2.hour ? 0 : count * Math.floor(time.get("Minutes", minDate) / count));
      }
      if (interval >= timeUnits2.hour) {
        time.set("Hours", minDate, interval >= timeUnits2.day ? 0 : count * Math.floor(time.get("Hours", minDate) / count));
      }
      if (interval >= timeUnits2.day) {
        time.set("Date", minDate, interval >= timeUnits2.month ? 1 : Math.max(1, count * Math.floor(time.get("Date", minDate) / count)));
      }
      if (interval >= timeUnits2.month) {
        time.set("Month", minDate, interval >= timeUnits2.year ? 0 : count * Math.floor(time.get("Month", minDate) / count));
        minYear = time.get("FullYear", minDate);
      }
      if (interval >= timeUnits2.year) {
        minYear -= minYear % count;
        time.set("FullYear", minDate, minYear);
      }
      if (interval === timeUnits2.week) {
        minDay = time.get("Day", minDate);
        time.set("Date", minDate, time.get("Date", minDate) - minDay + startOfWeek + (minDay < startOfWeek ? -7 : 0));
      }
      minYear = time.get("FullYear", minDate);
      const minMonth = time.get("Month", minDate), minDateDate = time.get("Date", minDate), minHours = time.get("Hours", minDate);
      min = minDate.getTime();
      if ((time.variableTimezone || !time.useUTC) && defined2(max)) {
        variableDayLength = max - min > 4 * timeUnits2.month || time.getTimezoneOffset(min) !== time.getTimezoneOffset(max);
      }
      let t = minDate.getTime();
      i = 1;
      while (t < max) {
        tickPositions.push(t);
        if (interval === timeUnits2.year) {
          t = time.makeTime(minYear + i * count, 0);
        } else if (interval === timeUnits2.month) {
          t = time.makeTime(minYear, minMonth + i * count);
        } else if (variableDayLength && (interval === timeUnits2.day || interval === timeUnits2.week)) {
          t = time.makeTime(minYear, minMonth, minDateDate + i * count * (interval === timeUnits2.day ? 1 : 7));
        } else if (variableDayLength && interval === timeUnits2.hour && count > 1) {
          t = time.makeTime(minYear, minMonth, minDateDate, minHours + i * count);
        } else {
          t += interval * count;
        }
        i++;
      }
      tickPositions.push(t);
      if (interval <= timeUnits2.hour && tickPositions.length < 1e4) {
        tickPositions.forEach(function(t2) {
          if (t2 % 1800000 === 0 && time.dateFormat("%H%M%S%L", t2) === "000000000") {
            higherRanks[t2] = "day";
          }
        });
      }
    }
    tickPositions.info = extend2(normalizedInterval, {
      higherRanks,
      totalRange: interval * count
    });
    return tickPositions;
  }
  getDateFormat(range, timestamp, startOfWeek, dateTimeLabelFormats) {
    const dateStr = this.dateFormat("%m-%d %H:%M:%S.%L", timestamp), blank = "01-01 00:00:00.000", strpos = {
      millisecond: 15,
      second: 12,
      minute: 9,
      hour: 6,
      day: 3
    };
    let n = "millisecond", lastN = n;
    for (n in timeUnits2) {
      if (range === timeUnits2.week && +this.dateFormat("%w", timestamp) === startOfWeek && dateStr.substr(6) === blank.substr(6)) {
        n = "week";
        break;
      }
      if (timeUnits2[n] > range) {
        n = lastN;
        break;
      }
      if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
        break;
      }
      if (n !== "week") {
        lastN = n;
      }
    }
    return this.resolveDTLFormat(dateTimeLabelFormats[n]).main;
  }
}
Time.formatCache = {};
var Time_default = Time;

// node_modules/highcharts/es-modules/Core/Defaults.js
var getOptions = function() {
  return defaultOptions;
};
var setOptions = function(options) {
  fireEvent2(Globals_default, "setOptions", { options });
  merge3(true, defaultOptions, options);
  if (options.time || options.global) {
    if (Globals_default.time) {
      Globals_default.time.update(merge3(defaultOptions.global, defaultOptions.time, options.global, options.time));
    } else {
      Globals_default.time = defaultTime;
    }
  }
  return defaultOptions;
};
var { isTouchDevice } = Globals_default;
var { fireEvent: fireEvent2, merge: merge3 } = Utilities_default;
var defaultOptions = {
  colors: Palettes_default.colors,
  symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
  lang: {
    loading: "Loading...",
    months: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ],
    shortMonths: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    weekdays: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ],
    decimalPoint: ".",
    numericSymbols: ["k", "M", "G", "T", "P", "E"],
    resetZoom: "Reset zoom",
    resetZoomTitle: "Reset zoom level 1:1",
    thousandsSep: " "
  },
  global: {
    buttonTheme: {
      fill: "#f7f7f7",
      padding: 8,
      r: 2,
      stroke: "#cccccc",
      "stroke-width": 1,
      style: {
        color: "#333333",
        cursor: "pointer",
        fontSize: "0.8em",
        fontWeight: "normal"
      },
      states: {
        hover: {
          fill: "#e6e6e6"
        },
        select: {
          fill: "#e6e9ff",
          style: {
            color: "#000000",
            fontWeight: "bold"
          }
        },
        disabled: {
          style: {
            color: "#cccccc"
          }
        }
      }
    }
  },
  time: {
    Date: undefined,
    getTimezoneOffset: undefined,
    timezone: undefined,
    timezoneOffset: 0,
    useUTC: true
  },
  chart: ChartDefaults_default,
  title: {
    style: {
      color: "#333333",
      fontWeight: "bold"
    },
    text: "Chart title",
    align: "center",
    margin: 15,
    widthAdjust: -44
  },
  subtitle: {
    style: {
      color: "#666666",
      fontSize: "0.8em"
    },
    text: "",
    align: "center",
    widthAdjust: -44
  },
  caption: {
    margin: 15,
    style: {
      color: "#666666",
      fontSize: "0.8em"
    },
    text: "",
    align: "left",
    verticalAlign: "bottom"
  },
  plotOptions: {},
  legend: {
    enabled: true,
    align: "center",
    alignColumns: true,
    className: "highcharts-no-tooltip",
    events: {},
    layout: "horizontal",
    itemMarginBottom: 2,
    itemMarginTop: 2,
    labelFormatter: function() {
      return this.name;
    },
    borderColor: "#999999",
    borderRadius: 0,
    navigation: {
      style: {
        fontSize: "0.8em"
      },
      activeColor: "#0022ff",
      inactiveColor: "#cccccc"
    },
    itemStyle: {
      color: "#333333",
      cursor: "pointer",
      fontSize: "0.8em",
      textDecoration: "none",
      textOverflow: "ellipsis"
    },
    itemHoverStyle: {
      color: "#000000"
    },
    itemHiddenStyle: {
      color: "#666666",
      textDecoration: "line-through"
    },
    shadow: false,
    itemCheckboxStyle: {
      position: "absolute",
      width: "13px",
      height: "13px"
    },
    squareSymbol: true,
    symbolPadding: 5,
    verticalAlign: "bottom",
    x: 0,
    y: 0,
    title: {
      style: {
        fontSize: "0.8em",
        fontWeight: "bold"
      }
    }
  },
  loading: {
    labelStyle: {
      fontWeight: "bold",
      position: "relative",
      top: "45%"
    },
    style: {
      position: "absolute",
      backgroundColor: "#ffffff",
      opacity: 0.5,
      textAlign: "center"
    }
  },
  tooltip: {
    enabled: true,
    animation: {
      duration: 300,
      easing: (x) => Math.sqrt(1 - Math.pow(x - 1, 2))
    },
    borderRadius: 3,
    dateTimeLabelFormats: {
      millisecond: "%A, %e %b, %H:%M:%S.%L",
      second: "%A, %e %b, %H:%M:%S",
      minute: "%A, %e %b, %H:%M",
      hour: "%A, %e %b, %H:%M",
      day: "%A, %e %b %Y",
      week: "Week from %A, %e %b %Y",
      month: "%B %Y",
      year: "%Y"
    },
    footerFormat: "",
    headerShape: "callout",
    hideDelay: 500,
    padding: 8,
    shape: "callout",
    shared: false,
    snap: isTouchDevice ? 25 : 10,
    headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>',
    pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
    backgroundColor: "#ffffff",
    borderWidth: undefined,
    shadow: true,
    stickOnContact: false,
    style: {
      color: "#333333",
      cursor: "default",
      fontSize: "0.8em"
    },
    useHTML: false
  },
  credits: {
    enabled: true,
    href: "https://www.highcharts.com?credits",
    position: {
      align: "right",
      x: -10,
      verticalAlign: "bottom",
      y: -5
    },
    style: {
      cursor: "pointer",
      color: "#999999",
      fontSize: "0.6em"
    },
    text: "Highcharts.com"
  }
};
defaultOptions.chart.styledMode = true;
defaultOptions.chart.styledMode = false;
var defaultTime = new Time_default(defaultOptions.time);
var DefaultOptions = {
  defaultOptions,
  defaultTime,
  getOptions,
  setOptions
};
var Defaults_default = DefaultOptions;

// node_modules/highcharts/es-modules/Core/Color/Color.js
var { isNumber: isNumber3, merge: merge4, pInt: pInt2 } = Utilities_default;

class Color {
  static parse(input) {
    return input ? new Color(input) : Color.None;
  }
  constructor(input) {
    this.rgba = [NaN, NaN, NaN, NaN];
    this.input = input;
    const GlobalColor = Globals_default.Color;
    if (GlobalColor && GlobalColor !== Color) {
      return new GlobalColor(input);
    }
    let result, rgba, i, parser;
    if (typeof input === "object" && typeof input.stops !== "undefined") {
      this.stops = input.stops.map((stop) => new Color(stop[1]));
    } else if (typeof input === "string") {
      this.input = input = Color.names[input.toLowerCase()] || input;
      if (input.charAt(0) === "#") {
        const len = input.length, col = parseInt(input.substr(1), 16);
        if (len === 7) {
          rgba = [
            (col & 16711680) >> 16,
            (col & 65280) >> 8,
            col & 255,
            1
          ];
        } else if (len === 4) {
          rgba = [
            (col & 3840) >> 4 | (col & 3840) >> 8,
            (col & 240) >> 4 | col & 240,
            (col & 15) << 4 | col & 15,
            1
          ];
        }
      }
      if (!rgba) {
        i = Color.parsers.length;
        while (i-- && !rgba) {
          parser = Color.parsers[i];
          result = parser.regex.exec(input);
          if (result) {
            rgba = parser.parse(result);
          }
        }
      }
    }
    if (rgba) {
      this.rgba = rgba;
    }
  }
  get(format) {
    const input = this.input, rgba = this.rgba;
    if (typeof input === "object" && typeof this.stops !== "undefined") {
      const ret = merge4(input);
      ret.stops = [].slice.call(ret.stops);
      this.stops.forEach((stop, i) => {
        ret.stops[i] = [
          ret.stops[i][0],
          stop.get(format)
        ];
      });
      return ret;
    }
    if (rgba && isNumber3(rgba[0])) {
      if (format === "rgb" || !format && rgba[3] === 1) {
        return "rgb(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + ")";
      }
      if (format === "a") {
        return `${rgba[3]}`;
      }
      return "rgba(" + rgba.join(",") + ")";
    }
    return input;
  }
  brighten(alpha) {
    const rgba = this.rgba;
    if (this.stops) {
      this.stops.forEach(function(stop) {
        stop.brighten(alpha);
      });
    } else if (isNumber3(alpha) && alpha !== 0) {
      for (let i = 0;i < 3; i++) {
        rgba[i] += pInt2(alpha * 255);
        if (rgba[i] < 0) {
          rgba[i] = 0;
        }
        if (rgba[i] > 255) {
          rgba[i] = 255;
        }
      }
    }
    return this;
  }
  setOpacity(alpha) {
    this.rgba[3] = alpha;
    return this;
  }
  tweenTo(to, pos) {
    const fromRgba = this.rgba, toRgba = to.rgba;
    if (!isNumber3(fromRgba[0]) || !isNumber3(toRgba[0])) {
      return to.input || "none";
    }
    const hasAlpha = toRgba[3] !== 1 || fromRgba[3] !== 1;
    return (hasAlpha ? "rgba(" : "rgb(") + Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) + "," + Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) + "," + Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) + (hasAlpha ? "," + (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos)) : "") + ")";
  }
}
Color.names = {
  white: "#ffffff",
  black: "#000000"
};
Color.parsers = [{
  regex: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/,
  parse: function(result) {
    return [
      pInt2(result[1]),
      pInt2(result[2]),
      pInt2(result[3]),
      parseFloat(result[4], 10)
    ];
  }
}, {
  regex: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/,
  parse: function(result) {
    return [pInt2(result[1]), pInt2(result[2]), pInt2(result[3]), 1];
  }
}];
Color.None = new Color("");
var Color_default = Color;

// node_modules/highcharts/es-modules/Core/Animation/Fx.js
var { parse: color } = Color_default;
var { win: win3 } = Globals_default;
var { isNumber: isNumber4, objectEach: objectEach3 } = Utilities_default;

class Fx {
  constructor(elem, options, prop) {
    this.pos = NaN;
    this.options = options;
    this.elem = elem;
    this.prop = prop;
  }
  dSetter() {
    const paths = this.paths, start = paths && paths[0], end = paths && paths[1], now = this.now || 0;
    let path = [];
    if (now === 1 || !start || !end) {
      path = this.toD || [];
    } else if (start.length === end.length && now < 1) {
      for (let i = 0;i < end.length; i++) {
        const startSeg = start[i];
        const endSeg = end[i];
        const tweenSeg = [];
        for (let j = 0;j < endSeg.length; j++) {
          const startItem = startSeg[j];
          const endItem = endSeg[j];
          if (isNumber4(startItem) && isNumber4(endItem) && !(endSeg[0] === "A" && (j === 4 || j === 5))) {
            tweenSeg[j] = startItem + now * (endItem - startItem);
          } else {
            tweenSeg[j] = endItem;
          }
        }
        path.push(tweenSeg);
      }
    } else {
      path = end;
    }
    this.elem.attr("d", path, undefined, true);
  }
  update() {
    const elem = this.elem, prop = this.prop, now = this.now, step = this.options.step;
    if (this[prop + "Setter"]) {
      this[prop + "Setter"]();
    } else if (elem.attr) {
      if (elem.element) {
        elem.attr(prop, now, null, true);
      }
    } else {
      elem.style[prop] = now + this.unit;
    }
    if (step) {
      step.call(elem, now, this);
    }
  }
  run(from, to, unit) {
    const self = this, options = self.options, timer = function(gotoEnd) {
      return timer.stopped ? false : self.step(gotoEnd);
    }, requestAnimationFrame = win3.requestAnimationFrame || function(step2) {
      setTimeout(step2, 13);
    }, step = function() {
      for (let i = 0;i < Fx.timers.length; i++) {
        if (!Fx.timers[i]()) {
          Fx.timers.splice(i--, 1);
        }
      }
      if (Fx.timers.length) {
        requestAnimationFrame(step);
      }
    };
    if (from === to && !this.elem["forceAnimate:" + this.prop]) {
      delete options.curAnim[this.prop];
      if (options.complete && Object.keys(options.curAnim).length === 0) {
        options.complete.call(this.elem);
      }
    } else {
      this.startTime = +new Date;
      this.start = from;
      this.end = to;
      this.unit = unit;
      this.now = this.start;
      this.pos = 0;
      timer.elem = this.elem;
      timer.prop = this.prop;
      if (timer() && Fx.timers.push(timer) === 1) {
        requestAnimationFrame(step);
      }
    }
  }
  step(gotoEnd) {
    const t = +new Date, options = this.options, elem = this.elem, complete = options.complete, duration = options.duration, curAnim = options.curAnim;
    let ret, done;
    if (!!elem.attr && !elem.element) {
      ret = false;
    } else if (gotoEnd || t >= duration + this.startTime) {
      this.now = this.end;
      this.pos = 1;
      this.update();
      curAnim[this.prop] = true;
      done = true;
      objectEach3(curAnim, function(val) {
        if (val !== true) {
          done = false;
        }
      });
      if (done && complete) {
        complete.call(elem);
      }
      ret = false;
    } else {
      this.pos = options.easing((t - this.startTime) / duration);
      this.now = this.start + (this.end - this.start) * this.pos;
      this.update();
      ret = true;
    }
    return ret;
  }
  initPath(elem, fromD, toD) {
    const { startX, endX } = elem, end = toD.slice(), isArea = elem.isArea, positionFactor = isArea ? 2 : 1, disableAnimation = fromD && toD.length > fromD.length && toD.hasStackedCliffs;
    let shift, fullLength, i, reverse, start = fromD && fromD.slice();
    if (!start || disableAnimation) {
      return [end, end];
    }
    function prepend(arr, other) {
      while (arr.length < fullLength) {
        const moveSegment = arr[0], otherSegment = other[fullLength - arr.length];
        if (otherSegment && moveSegment[0] === "M") {
          if (otherSegment[0] === "C") {
            arr[0] = [
              "C",
              moveSegment[1],
              moveSegment[2],
              moveSegment[1],
              moveSegment[2],
              moveSegment[1],
              moveSegment[2]
            ];
          } else {
            arr[0] = ["L", moveSegment[1], moveSegment[2]];
          }
        }
        arr.unshift(moveSegment);
        if (isArea) {
          const z = arr.pop();
          arr.push(arr[arr.length - 1], z);
        }
      }
    }
    function append(arr) {
      while (arr.length < fullLength) {
        const segmentToAdd = arr[Math.floor(arr.length / positionFactor) - 1].slice();
        if (segmentToAdd[0] === "C") {
          segmentToAdd[1] = segmentToAdd[5];
          segmentToAdd[2] = segmentToAdd[6];
        }
        if (!isArea) {
          arr.push(segmentToAdd);
        } else {
          const lowerSegmentToAdd = arr[Math.floor(arr.length / positionFactor)].slice();
          arr.splice(arr.length / 2, 0, segmentToAdd, lowerSegmentToAdd);
        }
      }
    }
    if (startX && endX && endX.length) {
      for (i = 0;i < startX.length; i++) {
        if (startX[i] === endX[0]) {
          shift = i;
          break;
        } else if (startX[0] === endX[endX.length - startX.length + i]) {
          shift = i;
          reverse = true;
          break;
        } else if (startX[startX.length - 1] === endX[endX.length - startX.length + i]) {
          shift = startX.length - i;
          break;
        }
      }
      if (typeof shift === "undefined") {
        start = [];
      }
    }
    if (start.length && isNumber4(shift)) {
      fullLength = end.length + shift * positionFactor;
      if (!reverse) {
        prepend(end, start);
        append(start);
      } else {
        prepend(start, end);
        append(end);
      }
    }
    return [start, end];
  }
  fillSetter() {
    Fx.prototype.strokeSetter.apply(this, arguments);
  }
  strokeSetter() {
    this.elem.attr(this.prop, color(this.start).tweenTo(color(this.end), this.pos), undefined, true);
  }
}
Fx.timers = [];
var Fx_default = Fx;

// node_modules/highcharts/es-modules/Core/Animation/AnimationUtilities.js
var setAnimation = function(animation, chart) {
  chart.renderer.globalAnimation = pick3(animation, chart.options.chart.animation, true);
};
var animObject = function(animation) {
  return isObject3(animation) ? merge5({ duration: 500, defer: 0 }, animation) : { duration: animation ? 500 : 0, defer: 0 };
};
var getDeferredAnimation = function(chart, animation, series) {
  const labelAnimation = animObject(animation), s = series ? [series] : chart.series;
  let defer = 0, duration = 0;
  s.forEach((series2) => {
    const seriesAnim = animObject(series2.options.animation);
    defer = isObject3(animation) && defined3(animation.defer) ? labelAnimation.defer : Math.max(defer, seriesAnim.duration + seriesAnim.defer);
    duration = Math.min(labelAnimation.duration, seriesAnim.duration);
  });
  if (chart.renderer.forExport) {
    defer = 0;
  }
  const anim = {
    defer: Math.max(0, defer - duration),
    duration: Math.min(defer, duration)
  };
  return anim;
};
var animate = function(el, params, opt) {
  let start, unit = "", end, fx, args;
  if (!isObject3(opt)) {
    args = arguments;
    opt = {
      duration: args[2],
      easing: args[3],
      complete: args[4]
    };
  }
  if (!isNumber5(opt.duration)) {
    opt.duration = 400;
  }
  opt.easing = typeof opt.easing === "function" ? opt.easing : Math[opt.easing] || Math.easeInOutSine;
  opt.curAnim = merge5(params);
  objectEach4(params, function(val, prop) {
    stop(el, prop);
    fx = new Fx_default(el, opt, prop);
    end = undefined;
    if (prop === "d" && isArray2(params.d)) {
      fx.paths = fx.initPath(el, el.pathArray, params.d);
      fx.toD = params.d;
      start = 0;
      end = 1;
    } else if (el.attr) {
      start = el.attr(prop);
    } else {
      start = parseFloat(getStyle2(el, prop)) || 0;
      if (prop !== "opacity") {
        unit = "px";
      }
    }
    if (!end) {
      end = val;
    }
    if (typeof end === "string" && end.match("px")) {
      end = end.replace(/px/g, "");
    }
    fx.run(start, end, unit);
  });
};
var stop = function(el, prop) {
  let i = Fx_default.timers.length;
  while (i--) {
    if (Fx_default.timers[i].elem === el && (!prop || prop === Fx_default.timers[i].prop)) {
      Fx_default.timers[i].stopped = true;
    }
  }
};
var { defined: defined3, getStyle: getStyle2, isArray: isArray2, isNumber: isNumber5, isObject: isObject3, merge: merge5, objectEach: objectEach4, pick: pick3 } = Utilities_default;
var animationExports = {
  animate,
  animObject,
  getDeferredAnimation,
  setAnimation,
  stop
};
var AnimationUtilities_default = animationExports;

// node_modules/highcharts/es-modules/Core/Renderer/HTML/AST.js
var { SVG_NS, win: win4 } = Globals_default;
var { attr: attr2, createElement: createElement2, css: css2, error: error3, isFunction: isFunction2, isString: isString2, objectEach: objectEach5, splat: splat3 } = Utilities_default;
var { trustedTypes } = win4;
var trustedTypesPolicy = trustedTypes && isFunction2(trustedTypes.createPolicy) && trustedTypes.createPolicy("highcharts", {
  createHTML: (s) => s
});
var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
var hasValidDOMParser = function() {
  try {
    return Boolean(new DOMParser().parseFromString(emptyHTML, "text/html"));
  } catch (e) {
    return false;
  }
}();

class AST {
  static filterUserAttributes(attributes) {
    objectEach5(attributes, (val, key) => {
      let valid = true;
      if (AST.allowedAttributes.indexOf(key) === -1) {
        valid = false;
      }
      if (["background", "dynsrc", "href", "lowsrc", "src"].indexOf(key) !== -1) {
        valid = isString2(val) && AST.allowedReferences.some((ref) => val.indexOf(ref) === 0);
      }
      if (!valid) {
        error3(33, false, undefined, {
          "Invalid attribute in config": `${key}`
        });
        delete attributes[key];
      }
      if (isString2(val) && attributes[key]) {
        attributes[key] = val.replace(/</g, "&lt;");
      }
    });
    return attributes;
  }
  static parseStyle(style) {
    return style.split(";").reduce((styles, line) => {
      const pair = line.split(":").map((s) => s.trim()), key = pair.shift();
      if (key && pair.length) {
        styles[key.replace(/-([a-z])/g, (g) => g[1].toUpperCase())] = pair.join(":");
      }
      return styles;
    }, {});
  }
  static setElementHTML(el, html) {
    el.innerHTML = AST.emptyHTML;
    if (html) {
      const ast = new AST(html);
      ast.addToDOM(el);
    }
  }
  constructor(source) {
    this.nodes = typeof source === "string" ? this.parseMarkup(source) : source;
  }
  addToDOM(parent) {
    function recurse(subtree, subParent) {
      let ret;
      splat3(subtree).forEach(function(item) {
        const tagName = item.tagName;
        const textNode = item.textContent ? Globals_default.doc.createTextNode(item.textContent) : undefined;
        const bypassHTMLFiltering = AST.bypassHTMLFiltering;
        let node;
        if (tagName) {
          if (tagName === "#text") {
            node = textNode;
          } else if (AST.allowedTags.indexOf(tagName) !== -1 || bypassHTMLFiltering) {
            const NS = tagName === "svg" ? SVG_NS : subParent.namespaceURI || SVG_NS;
            const element = Globals_default.doc.createElementNS(NS, tagName);
            const attributes = item.attributes || {};
            objectEach5(item, function(val, key) {
              if (key !== "tagName" && key !== "attributes" && key !== "children" && key !== "style" && key !== "textContent") {
                attributes[key] = val;
              }
            });
            attr2(element, bypassHTMLFiltering ? attributes : AST.filterUserAttributes(attributes));
            if (item.style) {
              css2(element, item.style);
            }
            if (textNode) {
              element.appendChild(textNode);
            }
            recurse(item.children || [], element);
            node = element;
          } else {
            error3(33, false, undefined, {
              "Invalid tagName in config": tagName
            });
          }
        }
        if (node) {
          subParent.appendChild(node);
        }
        ret = node;
      });
      return ret;
    }
    return recurse(this.nodes, parent);
  }
  parseMarkup(markup) {
    const nodes = [];
    markup = markup.trim().replace(/ style=(["'])/g, " data-style=$1");
    let doc2;
    if (hasValidDOMParser) {
      doc2 = new DOMParser().parseFromString(trustedTypesPolicy ? trustedTypesPolicy.createHTML(markup) : markup, "text/html");
    } else {
      const body = createElement2("div");
      body.innerHTML = markup;
      doc2 = { body };
    }
    const appendChildNodes = (node, addTo) => {
      const tagName = node.nodeName.toLowerCase();
      const astNode = {
        tagName
      };
      if (tagName === "#text") {
        astNode.textContent = node.textContent || "";
      }
      const parsedAttributes = node.attributes;
      if (parsedAttributes) {
        const attributes = {};
        [].forEach.call(parsedAttributes, (attrib) => {
          if (attrib.name === "data-style") {
            astNode.style = AST.parseStyle(attrib.value);
          } else {
            attributes[attrib.name] = attrib.value;
          }
        });
        astNode.attributes = attributes;
      }
      if (node.childNodes.length) {
        const children = [];
        [].forEach.call(node.childNodes, (childNode) => {
          appendChildNodes(childNode, children);
        });
        if (children.length) {
          astNode.children = children;
        }
      }
      addTo.push(astNode);
    };
    [].forEach.call(doc2.body.childNodes, (childNode) => appendChildNodes(childNode, nodes));
    return nodes;
  }
}
AST.allowedAttributes = [
  "alt",
  "aria-controls",
  "aria-describedby",
  "aria-expanded",
  "aria-haspopup",
  "aria-hidden",
  "aria-label",
  "aria-labelledby",
  "aria-live",
  "aria-pressed",
  "aria-readonly",
  "aria-roledescription",
  "aria-selected",
  "class",
  "clip-path",
  "color",
  "colspan",
  "cx",
  "cy",
  "d",
  "dx",
  "dy",
  "disabled",
  "fill",
  "filterUnits",
  "flood-color",
  "flood-opacity",
  "height",
  "href",
  "id",
  "in",
  "in2",
  "markerHeight",
  "markerWidth",
  "offset",
  "opacity",
  "operator",
  "orient",
  "padding",
  "paddingLeft",
  "paddingRight",
  "patternUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "role",
  "scope",
  "slope",
  "src",
  "startOffset",
  "stdDeviation",
  "stroke",
  "stroke-linecap",
  "stroke-width",
  "style",
  "tableValues",
  "result",
  "rowspan",
  "summary",
  "target",
  "tabindex",
  "text-align",
  "text-anchor",
  "textAnchor",
  "textLength",
  "title",
  "type",
  "valign",
  "width",
  "x",
  "x1",
  "x2",
  "xlink:href",
  "y",
  "y1",
  "y2",
  "zIndex"
];
AST.allowedReferences = [
  "https://",
  "http://",
  "mailto:",
  "/",
  "../",
  "./",
  "#"
];
AST.allowedTags = [
  "a",
  "abbr",
  "b",
  "br",
  "button",
  "caption",
  "circle",
  "clipPath",
  "code",
  "dd",
  "defs",
  "div",
  "dl",
  "dt",
  "em",
  "feComponentTransfer",
  "feComposite",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feMorphology",
  "feOffset",
  "feMerge",
  "feMergeNode",
  "filter",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "i",
  "img",
  "li",
  "linearGradient",
  "marker",
  "ol",
  "p",
  "path",
  "pattern",
  "pre",
  "rect",
  "small",
  "span",
  "stop",
  "strong",
  "style",
  "sub",
  "sup",
  "svg",
  "table",
  "text",
  "textPath",
  "thead",
  "title",
  "tbody",
  "tspan",
  "td",
  "th",
  "tr",
  "u",
  "ul",
  "#text"
];
AST.emptyHTML = emptyHTML;
AST.bypassHTMLFiltering = false;
var AST_default = AST;

// node_modules/highcharts/es-modules/Core/Templating.js
var dateFormat = function(format, timestamp, capitalize) {
  return defaultTime2.dateFormat(format, timestamp, capitalize);
};
var format = function(str = "", ctx, chart) {
  const regex = /\{([\w\:\.\,;\-\/<>%@"'= #\(\)]+)\}/g, subRegex = /\(([\w\:\.\,;\-\/<>%@"'= ]+)\)/g, matches = [], floatRegex = /f$/, decRegex = /\.(\d)/, lang = defaultOptions2.lang, time = chart && chart.time || defaultTime2, numberFormatter = chart && chart.numberFormatter || numberFormat;
  const resolveProperty = (key = "") => {
    let n;
    if (key === "true") {
      return true;
    }
    if (key === "false") {
      return false;
    }
    if ((n = Number(key)).toString() === key) {
      return n;
    }
    return getNestedProperty2(key, ctx);
  };
  let match, currentMatch, depth = 0, hasSub;
  while ((match = regex.exec(str)) !== null) {
    const subMatch = subRegex.exec(match[1]);
    if (subMatch) {
      match = subMatch;
      hasSub = true;
    }
    if (!currentMatch || !currentMatch.isBlock) {
      currentMatch = {
        ctx,
        expression: match[1],
        find: match[0],
        isBlock: match[1].charAt(0) === "#",
        start: match.index,
        startInner: match.index + match[0].length,
        length: match[0].length
      };
    }
    const fn = match[1].split(" ")[0].replace("#", "");
    if (helpers[fn]) {
      if (currentMatch.isBlock && fn === currentMatch.fn) {
        depth++;
      }
      if (!currentMatch.fn) {
        currentMatch.fn = fn;
      }
    }
    const startingElseSection = match[1] === "else";
    if (currentMatch.isBlock && currentMatch.fn && (match[1] === `/${currentMatch.fn}` || startingElseSection)) {
      if (!depth) {
        const start = currentMatch.startInner, body = str.substr(start, match.index - start);
        if (currentMatch.body === undefined) {
          currentMatch.body = body;
          currentMatch.startInner = match.index + match[0].length;
        } else {
          currentMatch.elseBody = body;
        }
        currentMatch.find += body + match[0];
        if (!startingElseSection) {
          matches.push(currentMatch);
          currentMatch = undefined;
        }
      } else if (!startingElseSection) {
        depth--;
      }
    } else if (!currentMatch.isBlock) {
      matches.push(currentMatch);
    }
    if (subMatch && !currentMatch?.isBlock) {
      break;
    }
  }
  matches.forEach((match2) => {
    const { body, elseBody, expression, fn } = match2;
    let replacement, i;
    if (fn) {
      const args = [match2], parts = expression.split(" ");
      i = helpers[fn].length;
      while (i--) {
        args.unshift(resolveProperty(parts[i + 1]));
      }
      replacement = helpers[fn].apply(ctx, args);
      if (match2.isBlock && typeof replacement === "boolean") {
        replacement = format(replacement ? body : elseBody, ctx, chart);
      }
    } else {
      const valueAndFormat = expression.split(":");
      replacement = resolveProperty(valueAndFormat.shift() || "");
      if (valueAndFormat.length && typeof replacement === "number") {
        const segment = valueAndFormat.join(":");
        if (floatRegex.test(segment)) {
          const decimals = parseInt((segment.match(decRegex) || ["", "-1"])[1], 10);
          if (replacement !== null) {
            replacement = numberFormatter(replacement, decimals, lang.decimalPoint, segment.indexOf(",") > -1 ? lang.thousandsSep : "");
          }
        } else {
          replacement = time.dateFormat(segment, replacement);
        }
      }
    }
    str = str.replace(match2.find, pick4(replacement, ""));
  });
  return hasSub ? format(str, ctx, chart) : str;
};
var numberFormat = function(number, decimals, decimalPoint, thousandsSep) {
  number = +number || 0;
  decimals = +decimals;
  let ret, fractionDigits;
  const lang = defaultOptions2.lang, origDec = (number.toString().split(".")[1] || "").split("e")[0].length, exponent = number.toString().split("e"), firstDecimals = decimals;
  if (decimals === -1) {
    decimals = Math.min(origDec, 20);
  } else if (!isNumber6(decimals)) {
    decimals = 2;
  } else if (decimals && exponent[1] && exponent[1] < 0) {
    fractionDigits = decimals + +exponent[1];
    if (fractionDigits >= 0) {
      exponent[0] = (+exponent[0]).toExponential(fractionDigits).split("e")[0];
      decimals = fractionDigits;
    } else {
      exponent[0] = exponent[0].split(".")[0] || 0;
      if (decimals < 20) {
        number = (exponent[0] * Math.pow(10, exponent[1])).toFixed(decimals);
      } else {
        number = 0;
      }
      exponent[1] = 0;
    }
  }
  const roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) + Math.pow(10, -Math.max(decimals, origDec) - 1)).toFixed(decimals);
  const strinteger = String(pInt3(roundedNumber));
  const thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;
  decimalPoint = pick4(decimalPoint, lang.decimalPoint);
  thousandsSep = pick4(thousandsSep, lang.thousandsSep);
  ret = number < 0 ? "-" : "";
  ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : "";
  if (+exponent[1] < 0 && !firstDecimals) {
    ret = "0";
  } else {
    ret += strinteger.substr(thousands).replace(/(\d{3})(?=\d)/g, "$1" + thousandsSep);
  }
  if (decimals) {
    ret += decimalPoint + roundedNumber.slice(-decimals);
  } else if (+ret === 0) {
    ret = "0";
  }
  if (exponent[1] && +ret !== 0) {
    ret += "e" + exponent[1];
  }
  return ret;
};
var { defaultOptions: defaultOptions2, defaultTime: defaultTime2 } = Defaults_default;
var { extend: extend3, getNestedProperty: getNestedProperty2, isArray: isArray3, isNumber: isNumber6, isObject: isObject4, pick: pick4, pInt: pInt3 } = Utilities_default;
var helpers = {
  add: (a, b) => a + b,
  divide: (a, b) => b !== 0 ? a / b : "",
  eq: (a, b) => a == b,
  each: function(arr) {
    const match = arguments[arguments.length - 1];
    return isArray3(arr) ? arr.map((item, i) => format(match.body, extend3(isObject4(item) ? item : { "@this": item }, {
      "@index": i,
      "@first": i === 0,
      "@last": i === arr.length - 1
    }))).join("") : false;
  },
  ge: (a, b) => a >= b,
  gt: (a, b) => a > b,
  if: (condition) => !!condition,
  le: (a, b) => a <= b,
  lt: (a, b) => a < b,
  multiply: (a, b) => a * b,
  ne: (a, b) => a != b,
  subtract: (a, b) => a - b,
  unless: (condition) => !condition
};
var Templating = {
  dateFormat,
  format,
  helpers,
  numberFormat
};
var Templating_default = Templating;

// node_modules/highcharts/es-modules/Core/Renderer/RendererRegistry.js
var RendererRegistry;
(function(RendererRegistry2) {
  RendererRegistry2.rendererTypes = {};
  let defaultRenderer;
  function getRendererType(rendererType = defaultRenderer) {
    return RendererRegistry2.rendererTypes[rendererType] || RendererRegistry2.rendererTypes[defaultRenderer];
  }
  RendererRegistry2.getRendererType = getRendererType;
  function registerRendererType(rendererType, rendererClass, setAsDefault) {
    RendererRegistry2.rendererTypes[rendererType] = rendererClass;
    if (!defaultRenderer || setAsDefault) {
      defaultRenderer = rendererType;
      Globals_default.Renderer = rendererClass;
    }
  }
  RendererRegistry2.registerRendererType = registerRendererType;
})(RendererRegistry || (RendererRegistry = {}));
var RendererRegistry_default = RendererRegistry;

// node_modules/highcharts/es-modules/Core/Renderer/RendererUtilities.js
var { clamp: clamp2, pick: pick5, pushUnique: pushUnique2, stableSort: stableSort2 } = Utilities_default;
var RendererUtilities;
(function(RendererUtilities2) {
  function distribute(boxes, len, maxDistance) {
    const origBoxes = boxes, reducedLen = origBoxes.reducedLen || len, sortByRank = (a, b) => (b.rank || 0) - (a.rank || 0), sortByTarget = (a, b) => a.target - b.target, restBoxes = [], boxesLength = boxes.length, forDeletion = [], push = restBoxes.push;
    let i, cursor, step, overlapping = true, box, target, total = 0, equalRank;
    i = boxesLength;
    while (i--) {
      total += boxes[i].size;
    }
    if (total > reducedLen) {
      stableSort2(boxes, sortByRank);
      equalRank = boxes[0].rank === boxes[boxes.length - 1].rank;
      step = equalRank ? boxesLength / 2 : -1;
      cursor = equalRank ? step : boxesLength - 1;
      while (step && total > reducedLen) {
        i = Math.floor(cursor);
        box = boxes[i];
        if (pushUnique2(forDeletion, i)) {
          total -= box.size;
        }
        cursor += step;
        if (equalRank && cursor >= boxes.length) {
          step /= 2;
          cursor = step;
        }
      }
      forDeletion.sort((a, b) => b - a).forEach((i2) => push.apply(restBoxes, boxes.splice(i2, 1)));
    }
    stableSort2(boxes, sortByTarget);
    boxes = boxes.map((box2) => ({
      size: box2.size,
      targets: [box2.target],
      align: pick5(box2.align, 0.5)
    }));
    while (overlapping) {
      i = boxes.length;
      while (i--) {
        box = boxes[i];
        target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;
        box.pos = clamp2(target - box.size * box.align, 0, len - box.size);
      }
      i = boxes.length;
      overlapping = false;
      while (i--) {
        if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {
          boxes[i - 1].size += boxes[i].size;
          boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);
          boxes[i - 1].align = 0.5;
          if (boxes[i - 1].pos + boxes[i - 1].size > len) {
            boxes[i - 1].pos = len - boxes[i - 1].size;
          }
          boxes.splice(i, 1);
          overlapping = true;
        }
      }
    }
    push.apply(origBoxes, restBoxes);
    i = 0;
    boxes.some((box2) => {
      let posInCompositeBox = 0;
      return (box2.targets || []).some(() => {
        origBoxes[i].pos = box2.pos + posInCompositeBox;
        if (typeof maxDistance !== "undefined" && Math.abs(origBoxes[i].pos - origBoxes[i].target) > maxDistance) {
          origBoxes.slice(0, i + 1).forEach((box3) => delete box3.pos);
          origBoxes.reducedLen = (origBoxes.reducedLen || len) - len * 0.1;
          if (origBoxes.reducedLen > len * 0.1) {
            distribute(origBoxes, len, maxDistance);
          }
          return true;
        }
        posInCompositeBox += origBoxes[i].size;
        i++;
        return false;
      });
    });
    stableSort2(origBoxes, sortByTarget);
    return origBoxes;
  }
  RendererUtilities2.distribute = distribute;
})(RendererUtilities || (RendererUtilities = {}));
var RendererUtilities_default = RendererUtilities;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGElement.js
var { animate: animate2, animObject: animObject2, stop: stop2 } = AnimationUtilities_default;
var { deg2rad, doc: doc2, svg, SVG_NS: SVG_NS2, win: win5 } = Globals_default;
var { addEvent: addEvent2, attr: attr3, createElement: createElement3, crisp: crisp2, css: css3, defined: defined4, erase: erase2, extend: extend4, fireEvent: fireEvent3, isArray: isArray4, isFunction: isFunction3, isObject: isObject5, isString: isString3, merge: merge6, objectEach: objectEach6, pick: pick6, pInt: pInt4, pushUnique: pushUnique3, replaceNested: replaceNested2, syncTimeout: syncTimeout2, uniqueKey: uniqueKey2 } = Utilities_default;

class SVGElement {
  _defaultGetter(key) {
    let ret = pick6(this[key + "Value"], this[key], this.element ? this.element.getAttribute(key) : null, 0);
    if (/^-?[\d\.]+$/.test(ret)) {
      ret = parseFloat(ret);
    }
    return ret;
  }
  _defaultSetter(value, key, element) {
    element.setAttribute(key, value);
  }
  add(parent) {
    const renderer = this.renderer, element = this.element;
    let inserted;
    if (parent) {
      this.parentGroup = parent;
    }
    if (typeof this.textStr !== "undefined" && this.element.nodeName === "text") {
      renderer.buildText(this);
    }
    this.added = true;
    if (!parent || parent.handleZ || this.zIndex) {
      inserted = this.zIndexSetter();
    }
    if (!inserted) {
      (parent ? parent.element : renderer.box).appendChild(element);
    }
    if (this.onAdd) {
      this.onAdd();
    }
    return this;
  }
  addClass(className, replace) {
    const currentClassName = replace ? "" : this.attr("class") || "";
    className = (className || "").split(/ /g).reduce(function(newClassName, name) {
      if (currentClassName.indexOf(name) === -1) {
        newClassName.push(name);
      }
      return newClassName;
    }, currentClassName ? [currentClassName] : []).join(" ");
    if (className !== currentClassName) {
      this.attr("class", className);
    }
    return this;
  }
  afterSetters() {
    if (this.doTransform) {
      this.updateTransform();
      this.doTransform = false;
    }
  }
  align(alignOptions, alignByTranslate, alignTo, redraw = true) {
    const attribs = {}, renderer = this.renderer, alignedObjects = renderer.alignedObjects, initialAlignment = Boolean(alignOptions);
    let x, y, alignFactor, vAlignFactor;
    if (alignOptions) {
      this.alignOptions = alignOptions;
      this.alignByTranslate = alignByTranslate;
      this.alignTo = alignTo;
    } else {
      alignOptions = this.alignOptions || {};
      alignByTranslate = this.alignByTranslate;
      alignTo = this.alignTo;
    }
    const alignToKey = !alignTo || isString3(alignTo) ? alignTo || "renderer" : undefined;
    if (alignToKey) {
      if (initialAlignment) {
        pushUnique3(alignedObjects, this);
      }
      alignTo = undefined;
    }
    const alignToBox = pick6(alignTo, renderer[alignToKey], renderer);
    const { align, verticalAlign: vAlign } = alignOptions;
    x = (alignToBox.x || 0) + (alignOptions.x || 0);
    y = (alignToBox.y || 0) + (alignOptions.y || 0);
    if (align === "right") {
      alignFactor = 1;
    } else if (align === "center") {
      alignFactor = 2;
    }
    if (alignFactor) {
      x += ((alignToBox.width || 0) - (alignOptions.width || 0)) / alignFactor;
    }
    attribs[alignByTranslate ? "translateX" : "x"] = Math.round(x);
    if (vAlign === "bottom") {
      vAlignFactor = 1;
    } else if (vAlign === "middle") {
      vAlignFactor = 2;
    }
    if (vAlignFactor) {
      y += ((alignToBox.height || 0) - (alignOptions.height || 0)) / vAlignFactor;
    }
    attribs[alignByTranslate ? "translateY" : "y"] = Math.round(y);
    if (redraw) {
      this[this.placed ? "animate" : "attr"](attribs);
      this.placed = true;
    }
    this.alignAttr = attribs;
    return this;
  }
  alignSetter(value) {
    const convert = {
      left: "start",
      center: "middle",
      right: "end"
    };
    if (convert[value]) {
      this.alignValue = value;
      this.element.setAttribute("text-anchor", convert[value]);
    }
  }
  animate(params, options, complete) {
    const animOptions = animObject2(pick6(options, this.renderer.globalAnimation, true)), deferTime = animOptions.defer;
    if (doc2.hidden) {
      animOptions.duration = 0;
    }
    if (animOptions.duration !== 0) {
      if (complete) {
        animOptions.complete = complete;
      }
      syncTimeout2(() => {
        if (this.element) {
          animate2(this, params, animOptions);
        }
      }, deferTime);
    } else {
      this.attr(params, undefined, complete || animOptions.complete);
      objectEach6(params, function(val, prop) {
        if (animOptions.step) {
          animOptions.step.call(this, val, { prop, pos: 1, elem: this });
        }
      }, this);
    }
    return this;
  }
  applyTextOutline(textOutline) {
    const elem = this.element, hasContrast = textOutline.indexOf("contrast") !== -1, styles = {};
    if (hasContrast) {
      styles.textOutline = textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
    }
    const parts = textOutline.split(" ");
    const color2 = parts[parts.length - 1];
    let strokeWidth = parts[0];
    if (strokeWidth && strokeWidth !== "none" && Globals_default.svg) {
      this.fakeTS = true;
      strokeWidth = strokeWidth.replace(/(^[\d\.]+)(.*?)$/g, function(match, digit, unit) {
        return 2 * Number(digit) + unit;
      });
      this.removeTextOutline();
      const outline = doc2.createElementNS(SVG_NS2, "tspan");
      attr3(outline, {
        class: "highcharts-text-outline",
        fill: color2,
        stroke: color2,
        "stroke-width": strokeWidth,
        "stroke-linejoin": "round"
      });
      const parentElem = elem.querySelector("textPath") || elem;
      [].forEach.call(parentElem.childNodes, (childNode) => {
        const clone = childNode.cloneNode(true);
        if (clone.removeAttribute) {
          ["fill", "stroke", "stroke-width", "stroke"].forEach((prop) => clone.removeAttribute(prop));
        }
        outline.appendChild(clone);
      });
      let totalHeight = 0;
      [].forEach.call(parentElem.querySelectorAll("text tspan"), (element) => {
        totalHeight += Number(element.getAttribute("dy"));
      });
      const br = doc2.createElementNS(SVG_NS2, "tspan");
      br.textContent = "\u200B";
      attr3(br, {
        x: Number(elem.getAttribute("x")),
        dy: -totalHeight
      });
      outline.appendChild(br);
      parentElem.insertBefore(outline, parentElem.firstChild);
    }
  }
  attr(hash, val, complete, continueAnimation) {
    const { element } = this, symbolCustomAttribs = SVGElement.symbolCustomAttribs;
    let key, hasSetSymbolSize, ret = this, skipAttr, setter;
    if (typeof hash === "string" && typeof val !== "undefined") {
      key = hash;
      hash = {};
      hash[key] = val;
    }
    if (typeof hash === "string") {
      ret = (this[hash + "Getter"] || this._defaultGetter).call(this, hash, element);
    } else {
      objectEach6(hash, function eachAttribute(val2, key2) {
        skipAttr = false;
        if (!continueAnimation) {
          stop2(this, key2);
        }
        if (this.symbolName && symbolCustomAttribs.indexOf(key2) !== -1) {
          if (!hasSetSymbolSize) {
            this.symbolAttr(hash);
            hasSetSymbolSize = true;
          }
          skipAttr = true;
        }
        if (this.rotation && (key2 === "x" || key2 === "y")) {
          this.doTransform = true;
        }
        if (!skipAttr) {
          setter = this[key2 + "Setter"] || this._defaultSetter;
          setter.call(this, val2, key2, element);
        }
      }, this);
      this.afterSetters();
    }
    if (complete) {
      complete.call(this);
    }
    return ret;
  }
  clip(clipElem) {
    if (clipElem && !clipElem.clipPath) {
      const id = uniqueKey2() + "-", clipPath = this.renderer.createElement("clipPath").attr({ id }).add(this.renderer.defs);
      extend4(clipElem, { clipPath, id, count: 0 });
      clipElem.add(clipPath);
    }
    return this.attr("clip-path", clipElem ? `url(${this.renderer.url}#${clipElem.id})` : "none");
  }
  crisp(rect, strokeWidth) {
    strokeWidth = Math.round(strokeWidth || rect.strokeWidth || 0);
    const x1 = rect.x || this.x || 0, y1 = rect.y || this.y || 0, x2 = (rect.width || this.width || 0) + x1, y2 = (rect.height || this.height || 0) + y1, x = crisp2(x1, strokeWidth), y = crisp2(y1, strokeWidth), x2Crisp = crisp2(x2, strokeWidth), y2Crisp = crisp2(y2, strokeWidth);
    extend4(rect, {
      x,
      y,
      width: x2Crisp - x,
      height: y2Crisp - y
    });
    if (defined4(rect.strokeWidth)) {
      rect.strokeWidth = strokeWidth;
    }
    return rect;
  }
  complexColor(colorOptions, prop, elem) {
    const renderer = this.renderer;
    let colorObject, gradName, gradAttr, radAttr, gradients, stops, stopColor, stopOpacity, radialReference, id, key = [], value;
    fireEvent3(this.renderer, "complexColor", {
      args: arguments
    }, function() {
      if (colorOptions.radialGradient) {
        gradName = "radialGradient";
      } else if (colorOptions.linearGradient) {
        gradName = "linearGradient";
      }
      if (gradName) {
        gradAttr = colorOptions[gradName];
        gradients = renderer.gradients;
        stops = colorOptions.stops;
        radialReference = elem.radialReference;
        if (isArray4(gradAttr)) {
          colorOptions[gradName] = gradAttr = {
            x1: gradAttr[0],
            y1: gradAttr[1],
            x2: gradAttr[2],
            y2: gradAttr[3],
            gradientUnits: "userSpaceOnUse"
          };
        }
        if (gradName === "radialGradient" && radialReference && !defined4(gradAttr.gradientUnits)) {
          radAttr = gradAttr;
          gradAttr = merge6(gradAttr, renderer.getRadialAttr(radialReference, radAttr), { gradientUnits: "userSpaceOnUse" });
        }
        objectEach6(gradAttr, function(value2, n) {
          if (n !== "id") {
            key.push(n, value2);
          }
        });
        objectEach6(stops, function(val) {
          key.push(val);
        });
        key = key.join(",");
        if (gradients[key]) {
          id = gradients[key].attr("id");
        } else {
          gradAttr.id = id = uniqueKey2();
          const gradientObject = gradients[key] = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);
          gradientObject.radAttr = radAttr;
          gradientObject.stops = [];
          stops.forEach(function(stop3) {
            if (stop3[1].indexOf("rgba") === 0) {
              colorObject = Color_default.parse(stop3[1]);
              stopColor = colorObject.get("rgb");
              stopOpacity = colorObject.get("a");
            } else {
              stopColor = stop3[1];
              stopOpacity = 1;
            }
            const stopObject = renderer.createElement("stop").attr({
              offset: stop3[0],
              "stop-color": stopColor,
              "stop-opacity": stopOpacity
            }).add(gradientObject);
            gradientObject.stops.push(stopObject);
          });
        }
        value = "url(" + renderer.url + "#" + id + ")";
        elem.setAttribute(prop, value);
        elem.gradient = key;
        colorOptions.toString = function() {
          return value;
        };
      }
    });
  }
  css(styles) {
    const oldStyles = this.styles, newStyles = {}, elem = this.element;
    let textWidth, hasNew = !oldStyles;
    if (oldStyles) {
      objectEach6(styles, function(value, n) {
        if (oldStyles && oldStyles[n] !== value) {
          newStyles[n] = value;
          hasNew = true;
        }
      });
    }
    if (hasNew) {
      if (oldStyles) {
        styles = extend4(oldStyles, newStyles);
      }
      if (styles.width === null || styles.width === "auto") {
        delete this.textWidth;
      } else if (elem.nodeName.toLowerCase() === "text" && styles.width) {
        textWidth = this.textWidth = pInt4(styles.width);
      }
      extend4(this.styles, styles);
      if (textWidth && (!svg && this.renderer.forExport)) {
        delete styles.width;
      }
      const stylesToApply = merge6(styles);
      if (elem.namespaceURI === this.SVG_NS) {
        ["textOutline", "textOverflow", "width"].forEach((key) => stylesToApply && delete stylesToApply[key]);
        if (stylesToApply.color) {
          stylesToApply.fill = stylesToApply.color;
        }
      }
      css3(elem, stylesToApply);
    }
    if (this.added) {
      if (this.element.nodeName === "text") {
        this.renderer.buildText(this);
      }
      if (styles.textOutline) {
        this.applyTextOutline(styles.textOutline);
      }
    }
    return this;
  }
  dashstyleSetter(value) {
    let i, strokeWidth = this["stroke-width"];
    if (strokeWidth === "inherit") {
      strokeWidth = 1;
    }
    value = value && value.toLowerCase();
    if (value) {
      const v = value.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
      i = v.length;
      while (i--) {
        v[i] = "" + pInt4(v[i]) * pick6(strokeWidth, NaN);
      }
      value = v.join(",").replace(/NaN/g, "none");
      this.element.setAttribute("stroke-dasharray", value);
    }
  }
  destroy() {
    const wrapper = this, element = wrapper.element || {}, renderer = wrapper.renderer, ownerSVGElement = element.ownerSVGElement;
    let parentToClean = element.nodeName === "SPAN" && wrapper.parentGroup || undefined, grandParent, i;
    element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
    stop2(wrapper);
    if (wrapper.clipPath && ownerSVGElement) {
      const clipPath = wrapper.clipPath;
      [].forEach.call(ownerSVGElement.querySelectorAll("[clip-path],[CLIP-PATH]"), function(el) {
        if (el.getAttribute("clip-path").indexOf(clipPath.element.id) > -1) {
          el.removeAttribute("clip-path");
        }
      });
      wrapper.clipPath = clipPath.destroy();
    }
    wrapper.connector = wrapper.connector?.destroy();
    if (wrapper.stops) {
      for (i = 0;i < wrapper.stops.length; i++) {
        wrapper.stops[i].destroy();
      }
      wrapper.stops.length = 0;
      wrapper.stops = undefined;
    }
    wrapper.safeRemoveChild(element);
    while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
      grandParent = parentToClean.parentGroup;
      wrapper.safeRemoveChild(parentToClean.div);
      delete parentToClean.div;
      parentToClean = grandParent;
    }
    if (wrapper.alignOptions) {
      erase2(renderer.alignedObjects, wrapper);
    }
    objectEach6(wrapper, function(val, key) {
      if (wrapper[key] && wrapper[key].parentGroup === wrapper && wrapper[key].destroy) {
        wrapper[key].destroy();
      }
      delete wrapper[key];
    });
    return;
  }
  dSetter(value, key, element) {
    if (isArray4(value)) {
      if (typeof value[0] === "string") {
        value = this.renderer.pathToSegments(value);
      }
      this.pathArray = value;
      value = value.reduce((acc, seg, i) => {
        if (!seg || !seg.join) {
          return (seg || "").toString();
        }
        return (i ? acc + " " : "") + seg.join(" ");
      }, "");
    }
    if (/(NaN| {2}|^$)/.test(value)) {
      value = "M 0 0";
    }
    if (this[key] !== value) {
      element.setAttribute(key, value);
      this[key] = value;
    }
  }
  fillSetter(value, key, element) {
    if (typeof value === "string") {
      element.setAttribute(key, value);
    } else if (value) {
      this.complexColor(value, key, element);
    }
  }
  hrefSetter(value, key, element) {
    element.setAttributeNS("http://www.w3.org/1999/xlink", key, value);
  }
  getBBox(reload, rot) {
    const wrapper = this, { alignValue, element, renderer, styles, textStr } = wrapper, { cache, cacheKeys } = renderer, isSVG = element.namespaceURI === wrapper.SVG_NS, rotation = pick6(rot, wrapper.rotation, 0), fontSize = renderer.styledMode ? element && SVGElement.prototype.getStyle.call(element, "font-size") : styles.fontSize;
    let bBox, height, toggleTextShadowShim, cacheKey;
    if (defined4(textStr)) {
      cacheKey = textStr.toString();
      if (cacheKey.indexOf("<") === -1) {
        cacheKey = cacheKey.replace(/\d/g, "0");
      }
      cacheKey += [
        "",
        renderer.rootFontSize,
        fontSize,
        rotation,
        wrapper.textWidth,
        alignValue,
        styles.textOverflow,
        styles.fontWeight
      ].join(",");
    }
    if (cacheKey && !reload) {
      bBox = cache[cacheKey];
    }
    if (!bBox || bBox.polygon) {
      if (isSVG || renderer.forExport) {
        try {
          toggleTextShadowShim = this.fakeTS && function(display) {
            const outline = element.querySelector(".highcharts-text-outline");
            if (outline) {
              css3(outline, { display });
            }
          };
          if (isFunction3(toggleTextShadowShim)) {
            toggleTextShadowShim("none");
          }
          bBox = element.getBBox ? extend4({}, element.getBBox()) : {
            width: element.offsetWidth,
            height: element.offsetHeight,
            x: 0,
            y: 0
          };
          if (isFunction3(toggleTextShadowShim)) {
            toggleTextShadowShim("");
          }
        } catch (e2) {
          "";
        }
        if (!bBox || bBox.width < 0) {
          bBox = { x: 0, y: 0, width: 0, height: 0 };
        }
      } else {
        bBox = wrapper.htmlGetBBox();
      }
      height = bBox.height;
      if (isSVG) {
        bBox.height = height = {
          "11px,17": 14,
          "13px,20": 16
        }[`${fontSize || ""},${Math.round(height)}`] || height;
      }
      if (rotation) {
        bBox = this.getRotatedBox(bBox, rotation);
      }
      const e = { bBox };
      fireEvent3(this, "afterGetBBox", e);
      bBox = e.bBox;
    }
    if (cacheKey && (textStr === "" || bBox.height > 0)) {
      while (cacheKeys.length > 250) {
        delete cache[cacheKeys.shift()];
      }
      if (!cache[cacheKey]) {
        cacheKeys.push(cacheKey);
      }
      cache[cacheKey] = bBox;
    }
    return bBox;
  }
  getRotatedBox(box, rotation) {
    const { x: boxX, y: boxY, width, height } = box, { alignValue, translateY, rotationOriginX = 0, rotationOriginY = 0 } = this, alignFactor = {
      right: 1,
      center: 0.5
    }[alignValue || 0] || 0, baseline = Number(this.element.getAttribute("y") || 0) - (translateY ? 0 : boxY), rad = rotation * deg2rad, rad90 = (rotation - 90) * deg2rad, cosRad = Math.cos(rad), sinRad = Math.sin(rad), wCosRad = width * cosRad, wSinRad = width * sinRad, cosRad90 = Math.cos(rad90), sinRad90 = Math.sin(rad90), [[xOriginCosRad, xOriginSinRad], [yOriginCosRad, yOriginSinRad]] = [
      rotationOriginX,
      rotationOriginY
    ].map((rotOrigin) => [
      rotOrigin - rotOrigin * cosRad,
      rotOrigin * sinRad
    ]), pX = boxX + alignFactor * (width - wCosRad) + xOriginCosRad + yOriginSinRad, pY = boxY + baseline - alignFactor * wSinRad - xOriginSinRad + yOriginCosRad, aX = pX + baseline * cosRad90, bX = aX + wCosRad, cX = bX - height * cosRad90, dX = cX - wCosRad, aY = pY + baseline * sinRad90, bY = aY + wSinRad, cY = bY - height * sinRad90, dY = cY - wSinRad;
    const x = Math.min(aX, bX, cX, dX), y = Math.min(aY, bY, cY, dY), boxWidth = Math.max(aX, bX, cX, dX) - x, boxHeight = Math.max(aY, bY, cY, dY) - y;
    return {
      x,
      y,
      width: boxWidth,
      height: boxHeight,
      polygon: [
        [aX, aY],
        [bX, bY],
        [cX, cY],
        [dX, dY]
      ]
    };
  }
  getStyle(prop) {
    return win5.getComputedStyle(this.element || this, "").getPropertyValue(prop);
  }
  hasClass(className) {
    return ("" + this.attr("class")).split(" ").indexOf(className) !== -1;
  }
  hide() {
    return this.attr({ visibility: "hidden" });
  }
  htmlGetBBox() {
    return { height: 0, width: 0, x: 0, y: 0 };
  }
  constructor(renderer, nodeName) {
    this.onEvents = {};
    this.opacity = 1;
    this.SVG_NS = SVG_NS2;
    this.element = nodeName === "span" || nodeName === "body" ? createElement3(nodeName) : doc2.createElementNS(this.SVG_NS, nodeName);
    this.renderer = renderer;
    this.styles = {};
    fireEvent3(this, "afterInit");
  }
  on(eventType, handler) {
    const { onEvents } = this;
    if (onEvents[eventType]) {
      onEvents[eventType]();
    }
    onEvents[eventType] = addEvent2(this.element, eventType, handler);
    return this;
  }
  opacitySetter(value, key, element) {
    const opacity = Number(Number(value).toFixed(3));
    this.opacity = opacity;
    element.setAttribute(key, opacity);
  }
  reAlign() {
    if (this.alignOptions?.width && this.alignOptions.align !== "left") {
      this.alignOptions.width = this.getBBox().width;
      this.placed = false;
      this.align();
    }
  }
  removeClass(className) {
    return this.attr("class", ("" + this.attr("class")).replace(isString3(className) ? new RegExp(`(^| )${className}( |\$)`) : className, " ").replace(/ +/g, " ").trim());
  }
  removeTextOutline() {
    const outline = this.element.querySelector("tspan.highcharts-text-outline");
    if (outline) {
      this.safeRemoveChild(outline);
    }
  }
  safeRemoveChild(element) {
    const parentNode = element.parentNode;
    if (parentNode) {
      parentNode.removeChild(element);
    }
  }
  setRadialReference(coordinates) {
    const existingGradient = this.element.gradient && this.renderer.gradients[this.element.gradient];
    this.element.radialReference = coordinates;
    if (existingGradient && existingGradient.radAttr) {
      existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));
    }
    return this;
  }
  shadow(shadowOptions) {
    const { renderer } = this, options = merge6(this.parentGroup?.rotation === 90 ? {
      offsetX: -1,
      offsetY: -1
    } : {}, isObject5(shadowOptions) ? shadowOptions : {}), id = renderer.shadowDefinition(options);
    return this.attr({
      filter: shadowOptions ? `url(${renderer.url}#${id})` : "none"
    });
  }
  show(inherit = true) {
    return this.attr({ visibility: inherit ? "inherit" : "visible" });
  }
  "stroke-widthSetter"(value, key, element) {
    this[key] = value;
    element.setAttribute(key, value);
  }
  strokeWidth() {
    if (!this.renderer.styledMode) {
      return this["stroke-width"] || 0;
    }
    const val = this.getStyle("stroke-width");
    let ret = 0, tempElement;
    if (/px$/.test(val)) {
      ret = pInt4(val);
    } else if (val !== "") {
      tempElement = doc2.createElementNS(SVG_NS2, "rect");
      attr3(tempElement, {
        width: val,
        "stroke-width": 0
      });
      this.element.parentNode.appendChild(tempElement);
      ret = tempElement.getBBox().width;
      tempElement.parentNode.removeChild(tempElement);
    }
    return ret;
  }
  symbolAttr(hash) {
    const wrapper = this;
    SVGElement.symbolCustomAttribs.forEach(function(key) {
      wrapper[key] = pick6(hash[key], wrapper[key]);
    });
    wrapper.attr({
      d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
    });
  }
  textSetter(value) {
    if (value !== this.textStr) {
      delete this.textPxLength;
      this.textStr = value;
      if (this.added) {
        this.renderer.buildText(this);
      }
      this.reAlign();
    }
  }
  titleSetter(value) {
    const el = this.element;
    const titleNode = el.getElementsByTagName("title")[0] || doc2.createElementNS(this.SVG_NS, "title");
    if (el.insertBefore) {
      el.insertBefore(titleNode, el.firstChild);
    } else {
      el.appendChild(titleNode);
    }
    titleNode.textContent = replaceNested2(pick6(value, ""), [/<[^>]*>/g, ""]).replace(/&lt;/g, "<").replace(/&gt;/g, ">");
  }
  toFront() {
    const element = this.element;
    element.parentNode.appendChild(element);
    return this;
  }
  translate(x, y) {
    return this.attr({
      translateX: x,
      translateY: y
    });
  }
  updateTransform(attrib = "transform") {
    const { element, matrix, rotation = 0, rotationOriginX, rotationOriginY, scaleX, scaleY, translateX = 0, translateY = 0 } = this;
    const transform = ["translate(" + translateX + "," + translateY + ")"];
    if (defined4(matrix)) {
      transform.push("matrix(" + matrix.join(",") + ")");
    }
    if (rotation) {
      transform.push("rotate(" + rotation + " " + pick6(rotationOriginX, element.getAttribute("x"), 0) + " " + pick6(rotationOriginY, element.getAttribute("y") || 0) + ")");
      if (this.text?.element.tagName === "SPAN") {
        this.text.attr({
          rotation,
          rotationOriginX: (rotationOriginX || 0) - this.padding,
          rotationOriginY: (rotationOriginY || 0) - this.padding
        });
      }
    }
    if (defined4(scaleX) || defined4(scaleY)) {
      transform.push("scale(" + pick6(scaleX, 1) + " " + pick6(scaleY, 1) + ")");
    }
    if (transform.length && !(this.text || this).textPath) {
      element.setAttribute(attrib, transform.join(" "));
    }
  }
  visibilitySetter(value, key, element) {
    if (value === "inherit") {
      element.removeAttribute(key);
    } else if (this[key] !== value) {
      element.setAttribute(key, value);
    }
    this[key] = value;
  }
  xGetter(key) {
    if (this.element.nodeName === "circle") {
      if (key === "x") {
        key = "cx";
      } else if (key === "y") {
        key = "cy";
      }
    }
    return this._defaultGetter(key);
  }
  zIndexSetter(value, key) {
    const renderer = this.renderer, parentGroup = this.parentGroup, parentWrapper = parentGroup || renderer, parentNode = parentWrapper.element || renderer.box, element = this.element, svgParent = parentNode === renderer.box;
    let childNodes, otherElement, otherZIndex, inserted = false, undefinedOtherZIndex, run = this.added, i;
    if (defined4(value)) {
      element.setAttribute("data-z-index", value);
      value = +value;
      if (this[key] === value) {
        run = false;
      }
    } else if (defined4(this[key])) {
      element.removeAttribute("data-z-index");
    }
    this[key] = value;
    if (run) {
      value = this.zIndex;
      if (value && parentGroup) {
        parentGroup.handleZ = true;
      }
      childNodes = parentNode.childNodes;
      for (i = childNodes.length - 1;i >= 0 && !inserted; i--) {
        otherElement = childNodes[i];
        otherZIndex = otherElement.getAttribute("data-z-index");
        undefinedOtherZIndex = !defined4(otherZIndex);
        if (otherElement !== element) {
          if (value < 0 && undefinedOtherZIndex && !svgParent && !i) {
            parentNode.insertBefore(element, childNodes[i]);
            inserted = true;
          } else if (pInt4(otherZIndex) <= value || undefinedOtherZIndex && (!defined4(value) || value >= 0)) {
            parentNode.insertBefore(element, childNodes[i + 1]);
            inserted = true;
          }
        }
      }
      if (!inserted) {
        parentNode.insertBefore(element, childNodes[svgParent ? 3 : 0]);
        inserted = true;
      }
    }
    return inserted;
  }
}
SVGElement.symbolCustomAttribs = [
  "anchorX",
  "anchorY",
  "clockwise",
  "end",
  "height",
  "innerR",
  "r",
  "start",
  "width",
  "x",
  "y"
];
SVGElement.prototype.strokeSetter = SVGElement.prototype.fillSetter;
SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
SVGElement.prototype.matrixSetter = SVGElement.prototype.rotationOriginXSetter = SVGElement.prototype.rotationOriginYSetter = SVGElement.prototype.rotationSetter = SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = SVGElement.prototype.verticalAlignSetter = function(value, key) {
  this[key] = value;
  this.doTransform = true;
};
var SVGElement_default = SVGElement;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGLabel.js
var { defined: defined5, extend: extend5, isNumber: isNumber7, merge: merge7, pick: pick7, removeEvent: removeEvent2 } = Utilities_default;

class SVGLabel extends SVGElement_default {
  constructor(renderer, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
    super(renderer, "g");
    this.paddingLeftSetter = this.paddingSetter;
    this.paddingRightSetter = this.paddingSetter;
    this.doUpdate = false;
    this.textStr = str;
    this.x = x;
    this.y = y;
    this.anchorX = anchorX;
    this.anchorY = anchorY;
    this.baseline = baseline;
    this.className = className;
    this.addClass(className === "button" ? "highcharts-no-tooltip" : "highcharts-label");
    if (className) {
      this.addClass("highcharts-" + className);
    }
    this.text = renderer.text(undefined, 0, 0, useHTML).attr({ zIndex: 1 });
    let hasBGImage;
    if (typeof shape === "string") {
      hasBGImage = /^url\((.*?)\)$/.test(shape);
      if (hasBGImage || this.renderer.symbols[shape]) {
        this.symbolKey = shape;
      }
    }
    this.bBox = SVGLabel.emptyBBox;
    this.padding = 3;
    this.baselineOffset = 0;
    this.needsBox = renderer.styledMode || hasBGImage;
    this.deferredAttr = {};
    this.alignFactor = 0;
  }
  alignSetter(value) {
    const alignFactor = {
      left: 0,
      center: 0.5,
      right: 1
    }[value];
    if (alignFactor !== this.alignFactor) {
      this.alignFactor = alignFactor;
      if (this.bBox && isNumber7(this.xSetting)) {
        this.attr({ x: this.xSetting });
      }
    }
  }
  anchorXSetter(value, key) {
    this.anchorX = value;
    this.boxAttr(key, Math.round(value) - this.getCrispAdjust() - this.xSetting);
  }
  anchorYSetter(value, key) {
    this.anchorY = value;
    this.boxAttr(key, value - this.ySetting);
  }
  boxAttr(key, value) {
    if (this.box) {
      this.box.attr(key, value);
    } else {
      this.deferredAttr[key] = value;
    }
  }
  css(styles) {
    if (styles) {
      const textStyles = {};
      styles = merge7(styles);
      SVGLabel.textProps.forEach((prop) => {
        if (typeof styles[prop] !== "undefined") {
          textStyles[prop] = styles[prop];
          delete styles[prop];
        }
      });
      this.text.css(textStyles);
      if ("fontSize" in textStyles || "fontWeight" in textStyles) {
        this.updateTextPadding();
      } else if ("width" in textStyles || "textOverflow" in textStyles) {
        this.updateBoxSize();
      }
    }
    return SVGElement_default.prototype.css.call(this, styles);
  }
  destroy() {
    removeEvent2(this.element, "mouseenter");
    removeEvent2(this.element, "mouseleave");
    if (this.text) {
      this.text.destroy();
    }
    if (this.box) {
      this.box = this.box.destroy();
    }
    SVGElement_default.prototype.destroy.call(this);
    return;
  }
  fillSetter(value, key) {
    if (value) {
      this.needsBox = true;
    }
    this.fill = value;
    this.boxAttr(key, value);
  }
  getBBox(reload, rot) {
    if (this.textStr && this.bBox.width === 0 && this.bBox.height === 0) {
      this.updateBoxSize();
    }
    const { padding, height = 0, translateX = 0, translateY = 0, width = 0 } = this, paddingLeft = pick7(this.paddingLeft, padding), rotation = rot ?? (this.rotation || 0);
    let bBox = {
      width,
      height,
      x: translateX + this.bBox.x - paddingLeft,
      y: translateY + this.bBox.y - padding + this.baselineOffset
    };
    if (rotation) {
      bBox = this.getRotatedBox(bBox, rotation);
    }
    return bBox;
  }
  getCrispAdjust() {
    return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
  }
  heightSetter(value) {
    this.heightSetting = value;
    this.doUpdate = true;
  }
  afterSetters() {
    super.afterSetters();
    if (this.doUpdate) {
      this.updateBoxSize();
      this.doUpdate = false;
    }
  }
  onAdd() {
    this.text.add(this);
    this.attr({
      text: pick7(this.textStr, ""),
      x: this.x || 0,
      y: this.y || 0
    });
    if (this.box && defined5(this.anchorX)) {
      this.attr({
        anchorX: this.anchorX,
        anchorY: this.anchorY
      });
    }
  }
  paddingSetter(value, key) {
    if (!isNumber7(value)) {
      this[key] = undefined;
    } else if (value !== this[key]) {
      this[key] = value;
      this.updateTextPadding();
    }
  }
  rSetter(value, key) {
    this.boxAttr(key, value);
  }
  strokeSetter(value, key) {
    this.stroke = value;
    this.boxAttr(key, value);
  }
  "stroke-widthSetter"(value, key) {
    if (value) {
      this.needsBox = true;
    }
    this["stroke-width"] = value;
    this.boxAttr(key, value);
  }
  "text-alignSetter"(value) {
    this.textAlign = value;
  }
  textSetter(text) {
    if (typeof text !== "undefined") {
      this.text.attr({ text });
    }
    this.updateTextPadding();
    this.reAlign();
  }
  updateBoxSize() {
    const text = this.text, attribs = {}, padding = this.padding, bBox = this.bBox = (!isNumber7(this.widthSetting) || !isNumber7(this.heightSetting) || this.textAlign) && defined5(text.textStr) ? text.getBBox(undefined, 0) : SVGLabel.emptyBBox;
    let crispAdjust;
    this.width = this.getPaddedWidth();
    this.height = (this.heightSetting || bBox.height || 0) + 2 * padding;
    const metrics = this.renderer.fontMetrics(text);
    this.baselineOffset = padding + Math.min((this.text.firstLineMetrics || metrics).b, bBox.height || Infinity);
    if (this.heightSetting) {
      this.baselineOffset += (this.heightSetting - metrics.h) / 2;
    }
    if (this.needsBox && !text.textPath) {
      if (!this.box) {
        const box = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
        box.addClass((this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : ""));
        box.add(this);
      }
      crispAdjust = this.getCrispAdjust();
      attribs.x = crispAdjust;
      attribs.y = (this.baseline ? -this.baselineOffset : 0) + crispAdjust;
      attribs.width = Math.round(this.width);
      attribs.height = Math.round(this.height);
      this.box.attr(extend5(attribs, this.deferredAttr));
      this.deferredAttr = {};
    }
  }
  updateTextPadding() {
    const text = this.text;
    if (!text.textPath) {
      this.updateBoxSize();
      const textY = this.baseline ? 0 : this.baselineOffset;
      let textX = pick7(this.paddingLeft, this.padding);
      if (defined5(this.widthSetting) && this.bBox && (this.textAlign === "center" || this.textAlign === "right")) {
        textX += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width);
      }
      if (textX !== text.x || textY !== text.y) {
        text.attr("x", textX);
        if (text.hasBoxWidthChanged) {
          this.bBox = text.getBBox(true);
        }
        if (typeof textY !== "undefined") {
          text.attr("y", textY);
        }
      }
      text.x = textX;
      text.y = textY;
    }
  }
  widthSetter(value) {
    this.widthSetting = isNumber7(value) ? value : undefined;
    this.doUpdate = true;
  }
  getPaddedWidth() {
    const padding = this.padding;
    const paddingLeft = pick7(this.paddingLeft, padding);
    const paddingRight = pick7(this.paddingRight, padding);
    return (this.widthSetting || this.bBox.width || 0) + paddingLeft + paddingRight;
  }
  xSetter(value) {
    this.x = value;
    if (this.alignFactor) {
      value -= this.alignFactor * this.getPaddedWidth();
      this["forceAnimate:x"] = true;
    }
    this.xSetting = Math.round(value);
    this.attr("translateX", this.xSetting);
  }
  ySetter(value) {
    this.ySetting = this.y = Math.round(value);
    this.attr("translateY", this.ySetting);
  }
}
SVGLabel.emptyBBox = {
  width: 0,
  height: 0,
  x: 0,
  y: 0
};
SVGLabel.textProps = [
  "color",
  "direction",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lineHeight",
  "textAlign",
  "textDecoration",
  "textOutline",
  "textOverflow",
  "whiteSpace",
  "width"
];
var SVGLabel_default = SVGLabel;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/Symbols.js
var arc = function(cx, cy, w, h, options) {
  const arc2 = [];
  if (options) {
    const start = options.start || 0, rx = pick8(options.r, w), ry = pick8(options.r, h || w), proximity = 0.0002 / Math.max(rx, 1), fullCircle = Math.abs((options.end || 0) - start - 2 * Math.PI) < proximity, end = (options.end || 0) - proximity, innerRadius = options.innerR, open = pick8(options.open, fullCircle), cosStart = Math.cos(start), sinStart = Math.sin(start), cosEnd = Math.cos(end), sinEnd = Math.sin(end), longArc = pick8(options.longArc, end - start - Math.PI < proximity ? 0 : 1);
    let arcSegment = [
      "A",
      rx,
      ry,
      0,
      longArc,
      pick8(options.clockwise, 1),
      cx + rx * cosEnd,
      cy + ry * sinEnd
    ];
    arcSegment.params = { start, end, cx, cy };
    arc2.push([
      "M",
      cx + rx * cosStart,
      cy + ry * sinStart
    ], arcSegment);
    if (defined6(innerRadius)) {
      arcSegment = [
        "A",
        innerRadius,
        innerRadius,
        0,
        longArc,
        defined6(options.clockwise) ? 1 - options.clockwise : 0,
        cx + innerRadius * cosStart,
        cy + innerRadius * sinStart
      ];
      arcSegment.params = {
        start: end,
        end: start,
        cx,
        cy
      };
      arc2.push(open ? [
        "M",
        cx + innerRadius * cosEnd,
        cy + innerRadius * sinEnd
      ] : [
        "L",
        cx + innerRadius * cosEnd,
        cy + innerRadius * sinEnd
      ], arcSegment);
    }
    if (!open) {
      arc2.push(["Z"]);
    }
  }
  return arc2;
};
var callout = function(x, y, w, h, options) {
  const arrowLength = 6, halfDistance = 6, r = Math.min(options && options.r || 0, w, h), safeDistance = r + halfDistance, anchorX = options && options.anchorX, anchorY = options && options.anchorY || 0;
  const path = roundedRect(x, y, w, h, { r });
  if (!isNumber8(anchorX)) {
    return path;
  }
  if (anchorX < w && anchorX > 0 && anchorY < h && anchorY > 0) {
    return path;
  }
  if (x + anchorX > w - safeDistance) {
    if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
      path.splice(3, 1, ["L", x + w, anchorY - halfDistance], ["L", x + w + arrowLength, anchorY], ["L", x + w, anchorY + halfDistance], ["L", x + w, y + h - r]);
    } else {
      if (anchorX < w) {
        const isTopCorner = anchorY < y + safeDistance, cornerY = isTopCorner ? y : y + h, sliceStart = isTopCorner ? 2 : 5;
        path.splice(sliceStart, 0, ["L", anchorX, anchorY], ["L", x + w - r, cornerY]);
      } else {
        path.splice(3, 1, ["L", x + w, h / 2], ["L", anchorX, anchorY], ["L", x + w, h / 2], ["L", x + w, y + h - r]);
      }
    }
  } else if (x + anchorX < safeDistance) {
    if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
      path.splice(7, 1, ["L", x, anchorY + halfDistance], ["L", x - arrowLength, anchorY], ["L", x, anchorY - halfDistance], ["L", x, y + r]);
    } else {
      if (anchorX > 0) {
        const isTopCorner = anchorY < y + safeDistance, cornerY = isTopCorner ? y : y + h, sliceStart = isTopCorner ? 1 : 6;
        path.splice(sliceStart, 0, ["L", anchorX, anchorY], ["L", x + r, cornerY]);
      } else {
        path.splice(7, 1, ["L", x, h / 2], ["L", anchorX, anchorY], ["L", x, h / 2], ["L", x, y + r]);
      }
    }
  } else if (anchorY > h && anchorX < w - safeDistance) {
    path.splice(5, 1, ["L", anchorX + halfDistance, y + h], ["L", anchorX, y + h + arrowLength], ["L", anchorX - halfDistance, y + h], ["L", x + r, y + h]);
  } else if (anchorY < 0 && anchorX > safeDistance) {
    path.splice(1, 1, ["L", anchorX - halfDistance, y], ["L", anchorX, y - arrowLength], ["L", anchorX + halfDistance, y], ["L", w - r, y]);
  }
  return path;
};
var circle = function(x, y, w, h) {
  return arc(x + w / 2, y + h / 2, w / 2, h / 2, {
    start: Math.PI * 0.5,
    end: Math.PI * 2.5,
    open: false
  });
};
var diamond = function(x, y, w, h) {
  return [
    ["M", x + w / 2, y],
    ["L", x + w, y + h / 2],
    ["L", x + w / 2, y + h],
    ["L", x, y + h / 2],
    ["Z"]
  ];
};
var rect = function(x, y, w, h, options) {
  if (options && options.r) {
    return roundedRect(x, y, w, h, options);
  }
  return [
    ["M", x, y],
    ["L", x + w, y],
    ["L", x + w, y + h],
    ["L", x, y + h],
    ["Z"]
  ];
};
var roundedRect = function(x, y, w, h, options) {
  const r = options?.r || 0;
  return [
    ["M", x + r, y],
    ["L", x + w - r, y],
    ["A", r, r, 0, 0, 1, x + w, y + r],
    ["L", x + w, y + h - r],
    ["A", r, r, 0, 0, 1, x + w - r, y + h],
    ["L", x + r, y + h],
    ["A", r, r, 0, 0, 1, x, y + h - r],
    ["L", x, y + r],
    ["A", r, r, 0, 0, 1, x + r, y],
    ["Z"]
  ];
};
var triangle = function(x, y, w, h) {
  return [
    ["M", x + w / 2, y],
    ["L", x + w, y + h],
    ["L", x, y + h],
    ["Z"]
  ];
};
var triangleDown = function(x, y, w, h) {
  return [
    ["M", x, y],
    ["L", x + w, y],
    ["L", x + w / 2, y + h],
    ["Z"]
  ];
};
var { defined: defined6, isNumber: isNumber8, pick: pick8 } = Utilities_default;
var Symbols = {
  arc,
  callout,
  circle,
  diamond,
  rect,
  roundedRect,
  square: rect,
  triangle,
  "triangle-down": triangleDown
};
var Symbols_default = Symbols;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/TextBuilder.js
var { doc: doc3, SVG_NS: SVG_NS3, win: win6 } = Globals_default;
var { attr: attr4, extend: extend6, fireEvent: fireEvent4, isString: isString4, objectEach: objectEach7, pick: pick9 } = Utilities_default;

class TextBuilder {
  constructor(svgElement) {
    const textStyles = svgElement.styles;
    this.renderer = svgElement.renderer;
    this.svgElement = svgElement;
    this.width = svgElement.textWidth;
    this.textLineHeight = textStyles && textStyles.lineHeight;
    this.textOutline = textStyles && textStyles.textOutline;
    this.ellipsis = Boolean(textStyles && textStyles.textOverflow === "ellipsis");
    this.noWrap = Boolean(textStyles && textStyles.whiteSpace === "nowrap");
  }
  buildSVG() {
    const wrapper = this.svgElement, textNode = wrapper.element, renderer = wrapper.renderer, textStr = pick9(wrapper.textStr, "").toString(), hasMarkup = textStr.indexOf("<") !== -1, childNodes = textNode.childNodes, tempParent = !wrapper.added && renderer.box, regexMatchBreaks = /<br.*?>/g, textCache = [
      textStr,
      this.ellipsis,
      this.noWrap,
      this.textLineHeight,
      this.textOutline,
      wrapper.getStyle("font-size"),
      this.width
    ].join(",");
    if (textCache === wrapper.textCache) {
      return;
    }
    wrapper.textCache = textCache;
    delete wrapper.actualWidth;
    for (let i = childNodes.length;i--; ) {
      textNode.removeChild(childNodes[i]);
    }
    if (!hasMarkup && !this.ellipsis && !this.width && !wrapper.textPath && (textStr.indexOf(" ") === -1 || this.noWrap && !regexMatchBreaks.test(textStr))) {
      textNode.appendChild(doc3.createTextNode(this.unescapeEntities(textStr)));
    } else if (textStr !== "") {
      if (tempParent) {
        tempParent.appendChild(textNode);
      }
      const ast = new AST_default(textStr);
      this.modifyTree(ast.nodes);
      ast.addToDOM(textNode);
      this.modifyDOM();
      if (this.ellipsis && (textNode.textContent || "").indexOf("\u2026") !== -1) {
        wrapper.attr("title", this.unescapeEntities(wrapper.textStr || "", ["&lt;", "&gt;"]));
      }
      if (tempParent) {
        tempParent.removeChild(textNode);
      }
    }
    if (isString4(this.textOutline) && wrapper.applyTextOutline) {
      wrapper.applyTextOutline(this.textOutline);
    }
  }
  modifyDOM() {
    const wrapper = this.svgElement;
    const x = attr4(wrapper.element, "x");
    wrapper.firstLineMetrics = undefined;
    let firstChild;
    while (firstChild = wrapper.element.firstChild) {
      if (/^[\s\u200B]*$/.test(firstChild.textContent || " ")) {
        wrapper.element.removeChild(firstChild);
      } else {
        break;
      }
    }
    [].forEach.call(wrapper.element.querySelectorAll("tspan.highcharts-br"), (br, i) => {
      if (br.nextSibling && br.previousSibling) {
        if (i === 0 && br.previousSibling.nodeType === 1) {
          wrapper.firstLineMetrics = wrapper.renderer.fontMetrics(br.previousSibling);
        }
        attr4(br, {
          dy: this.getLineHeight(br.nextSibling),
          x
        });
      }
    });
    const width = this.width || 0;
    if (!width) {
      return;
    }
    const modifyTextNode = (textNode, parentElement) => {
      const text = textNode.textContent || "";
      const words = text.replace(/([^\^])-/g, "$1- ").split(" ");
      const hasWhiteSpace = !this.noWrap && (words.length > 1 || wrapper.element.childNodes.length > 1);
      const dy = this.getLineHeight(parentElement);
      let lineNo = 0;
      let startAt = wrapper.actualWidth;
      if (this.ellipsis) {
        if (text) {
          this.truncate(textNode, text, undefined, 0, Math.max(0, width - 0.8 * dy), (text2, currentIndex) => text2.substring(0, currentIndex) + "\u2026");
        }
      } else if (hasWhiteSpace) {
        const lines = [];
        const precedingSiblings = [];
        while (parentElement.firstChild && parentElement.firstChild !== textNode) {
          precedingSiblings.push(parentElement.firstChild);
          parentElement.removeChild(parentElement.firstChild);
        }
        while (words.length) {
          if (words.length && !this.noWrap && lineNo > 0) {
            lines.push(textNode.textContent || "");
            textNode.textContent = words.join(" ").replace(/- /g, "-");
          }
          this.truncate(textNode, undefined, words, lineNo === 0 ? startAt || 0 : 0, width, (t, currentIndex) => words.slice(0, currentIndex).join(" ").replace(/- /g, "-"));
          startAt = wrapper.actualWidth;
          lineNo++;
        }
        precedingSiblings.forEach((childNode) => {
          parentElement.insertBefore(childNode, textNode);
        });
        lines.forEach((line) => {
          parentElement.insertBefore(doc3.createTextNode(line), textNode);
          const br = doc3.createElementNS(SVG_NS3, "tspan");
          br.textContent = "\u200B";
          attr4(br, { dy, x });
          parentElement.insertBefore(br, textNode);
        });
      }
    };
    const modifyChildren = (node) => {
      const childNodes = [].slice.call(node.childNodes);
      childNodes.forEach((childNode) => {
        if (childNode.nodeType === win6.Node.TEXT_NODE) {
          modifyTextNode(childNode, node);
        } else {
          if (childNode.className.baseVal.indexOf("highcharts-br") !== -1) {
            wrapper.actualWidth = 0;
          }
          modifyChildren(childNode);
        }
      });
    };
    modifyChildren(wrapper.element);
  }
  getLineHeight(node) {
    const element = node.nodeType === win6.Node.TEXT_NODE ? node.parentElement : node;
    return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(element || this.svgElement.element).h;
  }
  modifyTree(nodes) {
    const modifyChild = (node, i) => {
      const { attributes = {}, children, style = {}, tagName } = node, styledMode = this.renderer.styledMode;
      if (tagName === "b" || tagName === "strong") {
        if (styledMode) {
          attributes["class"] = "highcharts-strong";
        } else {
          style.fontWeight = "bold";
        }
      } else if (tagName === "i" || tagName === "em") {
        if (styledMode) {
          attributes["class"] = "highcharts-emphasized";
        } else {
          style.fontStyle = "italic";
        }
      }
      if (style && style.color) {
        style.fill = style.color;
      }
      if (tagName === "br") {
        attributes["class"] = "highcharts-br";
        node.textContent = "\u200B";
        const nextNode = nodes[i + 1];
        if (nextNode && nextNode.textContent) {
          nextNode.textContent = nextNode.textContent.replace(/^ +/gm, "");
        }
      } else if (tagName === "a" && children && children.some((child) => child.tagName === "#text")) {
        node.children = [{ children, tagName: "tspan" }];
      }
      if (tagName !== "#text" && tagName !== "a") {
        node.tagName = "tspan";
      }
      extend6(node, { attributes, style });
      if (children) {
        children.filter((c) => c.tagName !== "#text").forEach(modifyChild);
      }
    };
    nodes.forEach(modifyChild);
    fireEvent4(this.svgElement, "afterModifyTree", { nodes });
  }
  truncate(textNode, text, words, startAt, width, getString) {
    const svgElement = this.svgElement;
    const { rotation } = svgElement;
    const lengths = [];
    let minIndex = words ? 1 : 0;
    let maxIndex = (text || words || "").length;
    let currentIndex = maxIndex;
    let str;
    let actualWidth;
    const getSubStringLength = function(charEnd, concatenatedEnd) {
      const end = concatenatedEnd || charEnd;
      const parentNode = textNode.parentNode;
      if (parentNode && typeof lengths[end] === "undefined") {
        if (parentNode.getSubStringLength) {
          try {
            lengths[end] = startAt + parentNode.getSubStringLength(0, words ? end + 1 : end);
          } catch (e) {
            "";
          }
        }
      }
      return lengths[end];
    };
    svgElement.rotation = 0;
    actualWidth = getSubStringLength(textNode.textContent.length);
    if (startAt + actualWidth > width) {
      while (minIndex <= maxIndex) {
        currentIndex = Math.ceil((minIndex + maxIndex) / 2);
        if (words) {
          str = getString(words, currentIndex);
        }
        actualWidth = getSubStringLength(currentIndex, str && str.length - 1);
        if (minIndex === maxIndex) {
          minIndex = maxIndex + 1;
        } else if (actualWidth > width) {
          maxIndex = currentIndex - 1;
        } else {
          minIndex = currentIndex;
        }
      }
      if (maxIndex === 0) {
        textNode.textContent = "";
      } else if (!(text && maxIndex === text.length - 1)) {
        textNode.textContent = str || getString(text || words, currentIndex);
      }
    }
    if (words) {
      words.splice(0, currentIndex);
    }
    svgElement.actualWidth = actualWidth;
    svgElement.rotation = rotation;
  }
  unescapeEntities(inputStr, except) {
    objectEach7(this.renderer.escapes, function(value, key) {
      if (!except || except.indexOf(value) === -1) {
        inputStr = inputStr.toString().replace(new RegExp(value, "g"), key);
      }
    });
    return inputStr;
  }
}
var TextBuilder_default = TextBuilder;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGRenderer.js
var { defaultOptions: defaultOptions3 } = Defaults_default;
var { charts: charts2, deg2rad: deg2rad2, doc: doc4, isFirefox, isMS, isWebKit, noop, SVG_NS: SVG_NS4, symbolSizes, win: win7 } = Globals_default;
var { addEvent: addEvent3, attr: attr5, createElement: createElement4, crisp: crisp3, css: css4, defined: defined7, destroyObjectProperties: destroyObjectProperties2, extend: extend7, isArray: isArray5, isNumber: isNumber9, isObject: isObject6, isString: isString5, merge: merge8, pick: pick10, pInt: pInt5, replaceNested: replaceNested3, uniqueKey: uniqueKey3 } = Utilities_default;
var hasInternalReferenceBug;

class SVGRenderer {
  constructor(container, width, height, style, forExport, allowHTML, styledMode) {
    const renderer = this, boxWrapper = renderer.createElement("svg").attr({
      version: "1.1",
      class: "highcharts-root"
    }), element = boxWrapper.element;
    if (!styledMode) {
      boxWrapper.css(this.getStyle(style || {}));
    }
    container.appendChild(element);
    attr5(container, "dir", "ltr");
    if (container.innerHTML.indexOf("xmlns") === -1) {
      attr5(element, "xmlns", this.SVG_NS);
    }
    this.box = element;
    this.boxWrapper = boxWrapper;
    this.alignedObjects = [];
    this.url = this.getReferenceURL();
    const desc = this.createElement("desc").add();
    desc.element.appendChild(doc4.createTextNode("Created with @product.name@ @product.version@"));
    this.defs = this.createElement("defs").add();
    this.allowHTML = allowHTML;
    this.forExport = forExport;
    this.styledMode = styledMode;
    this.gradients = {};
    this.cache = {};
    this.cacheKeys = [];
    this.imgCount = 0;
    this.rootFontSize = boxWrapper.getStyle("font-size");
    renderer.setSize(width, height, false);
    let subPixelFix, rect2;
    if (isFirefox && container.getBoundingClientRect) {
      subPixelFix = function() {
        css4(container, { left: 0, top: 0 });
        rect2 = container.getBoundingClientRect();
        css4(container, {
          left: Math.ceil(rect2.left) - rect2.left + "px",
          top: Math.ceil(rect2.top) - rect2.top + "px"
        });
      };
      subPixelFix();
      renderer.unSubPixelFix = addEvent3(win7, "resize", subPixelFix);
    }
  }
  definition(def) {
    const ast = new AST_default([def]);
    return ast.addToDOM(this.defs.element);
  }
  getReferenceURL() {
    if ((isFirefox || isWebKit) && doc4.getElementsByTagName("base").length) {
      if (!defined7(hasInternalReferenceBug)) {
        const id = uniqueKey3();
        const ast = new AST_default([{
          tagName: "svg",
          attributes: {
            width: 8,
            height: 8
          },
          children: [{
            tagName: "defs",
            children: [{
              tagName: "clipPath",
              attributes: {
                id
              },
              children: [{
                tagName: "rect",
                attributes: {
                  width: 4,
                  height: 4
                }
              }]
            }]
          }, {
            tagName: "rect",
            attributes: {
              id: "hitme",
              width: 8,
              height: 8,
              "clip-path": `url(#${id})`,
              fill: "rgba(0,0,0,0.001)"
            }
          }]
        }]);
        const svg2 = ast.addToDOM(doc4.body);
        css4(svg2, {
          position: "fixed",
          top: 0,
          left: 0,
          zIndex: 900000
        });
        const hitElement = doc4.elementFromPoint(6, 6);
        hasInternalReferenceBug = (hitElement && hitElement.id) === "hitme";
        doc4.body.removeChild(svg2);
      }
      if (hasInternalReferenceBug) {
        return replaceNested3(win7.location.href.split("#")[0], [/<[^>]*>/g, ""], [/([\('\)])/g, "\\$1"], [/ /g, "%20"]);
      }
    }
    return "";
  }
  getStyle(style) {
    this.style = extend7({
      fontFamily: "Helvetica, Arial, sans-serif",
      fontSize: "1rem"
    }, style);
    return this.style;
  }
  setStyle(style) {
    this.boxWrapper.css(this.getStyle(style));
  }
  isHidden() {
    return !this.boxWrapper.getBBox().width;
  }
  destroy() {
    const renderer = this, rendererDefs = renderer.defs;
    renderer.box = null;
    renderer.boxWrapper = renderer.boxWrapper.destroy();
    destroyObjectProperties2(renderer.gradients || {});
    renderer.gradients = null;
    renderer.defs = rendererDefs.destroy();
    if (renderer.unSubPixelFix) {
      renderer.unSubPixelFix();
    }
    renderer.alignedObjects = null;
    return null;
  }
  createElement(nodeName) {
    return new this.Element(this, nodeName);
  }
  getRadialAttr(radialReference, gradAttr) {
    return {
      cx: radialReference[0] - radialReference[2] / 2 + (gradAttr.cx || 0) * radialReference[2],
      cy: radialReference[1] - radialReference[2] / 2 + (gradAttr.cy || 0) * radialReference[2],
      r: (gradAttr.r || 0) * radialReference[2]
    };
  }
  shadowDefinition(shadowOptions) {
    const id = [
      `highcharts-drop-shadow-${this.chartIndex}`,
      ...Object.keys(shadowOptions).map((key) => `${key}-${shadowOptions[key]}`)
    ].join("-").toLowerCase().replace(/[^a-z\d\-]/g, ""), options = merge8({
      color: "#000000",
      offsetX: 1,
      offsetY: 1,
      opacity: 0.15,
      width: 5
    }, shadowOptions);
    if (!this.defs.element.querySelector(`#${id}`)) {
      this.definition({
        tagName: "filter",
        attributes: {
          id,
          filterUnits: options.filterUnits
        },
        children: this.getShadowFilterContent(options)
      });
    }
    return id;
  }
  getShadowFilterContent(options) {
    return [{
      tagName: "feDropShadow",
      attributes: {
        dx: options.offsetX,
        dy: options.offsetY,
        "flood-color": options.color,
        "flood-opacity": Math.min(options.opacity * 5, 1),
        stdDeviation: options.width / 2
      }
    }];
  }
  buildText(wrapper) {
    new TextBuilder_default(wrapper).buildSVG();
  }
  getContrast(color2) {
    const rgba = Color_default.parse(color2).rgba.map((b8) => {
      const c = b8 / 255;
      return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    });
    const l = 0.2126 * rgba[0] + 0.7152 * rgba[1] + 0.0722 * rgba[2];
    return 1.05 / (l + 0.05) > (l + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
  }
  button(text, x, y, callback, theme = {}, hoverState, selectState, disabledState, shape, useHTML) {
    const label = this.label(text, x, y, shape, undefined, undefined, useHTML, undefined, "button"), styledMode = this.styledMode, args = arguments;
    let curState = 0;
    theme = merge8(defaultOptions3.global.buttonTheme, theme);
    if (styledMode) {
      delete theme.fill;
      delete theme.stroke;
      delete theme["stroke-width"];
    }
    const states = theme.states || {}, normalStyle = theme.style || {};
    delete theme.states;
    delete theme.style;
    const stateAttribs = [
      AST_default.filterUserAttributes(theme)
    ], stateStyles = [normalStyle];
    if (!styledMode) {
      ["hover", "select", "disabled"].forEach((stateName, i) => {
        stateAttribs.push(merge8(stateAttribs[0], AST_default.filterUserAttributes(args[i + 5] || states[stateName] || {})));
        stateStyles.push(stateAttribs[i + 1].style);
        delete stateAttribs[i + 1].style;
      });
    }
    addEvent3(label.element, isMS ? "mouseover" : "mouseenter", function() {
      if (curState !== 3) {
        label.setState(1);
      }
    });
    addEvent3(label.element, isMS ? "mouseout" : "mouseleave", function() {
      if (curState !== 3) {
        label.setState(curState);
      }
    });
    label.setState = (state = 0) => {
      if (state !== 1) {
        label.state = curState = state;
      }
      label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][state]);
      if (!styledMode) {
        label.attr(stateAttribs[state]);
        const css5 = stateStyles[state];
        if (isObject6(css5)) {
          label.css(css5);
        }
      }
    };
    label.attr(stateAttribs[0]);
    if (!styledMode) {
      label.css(extend7({ cursor: "default" }, normalStyle));
      if (useHTML) {
        label.text.css({ pointerEvents: "none" });
      }
    }
    return label.on("touchstart", (e) => e.stopPropagation()).on("click", function(e) {
      if (curState !== 3) {
        callback.call(label, e);
      }
    });
  }
  crispLine(points, width) {
    const [start, end] = points;
    if (defined7(start[1]) && start[1] === end[1]) {
      start[1] = end[1] = crisp3(start[1], width);
    }
    if (defined7(start[2]) && start[2] === end[2]) {
      start[2] = end[2] = crisp3(start[2], width);
    }
    return points;
  }
  path(path) {
    const attribs = this.styledMode ? {} : {
      fill: "none"
    };
    if (isArray5(path)) {
      attribs.d = path;
    } else if (isObject6(path)) {
      extend7(attribs, path);
    }
    return this.createElement("path").attr(attribs);
  }
  circle(x, y, r) {
    const attribs = isObject6(x) ? x : typeof x === "undefined" ? {} : { x, y, r }, wrapper = this.createElement("circle");
    wrapper.xSetter = wrapper.ySetter = function(value, key, element) {
      element.setAttribute("c" + key, value);
    };
    return wrapper.attr(attribs);
  }
  arc(x, y, r, innerR, start, end) {
    let options;
    if (isObject6(x)) {
      options = x;
      y = options.y;
      r = options.r;
      innerR = options.innerR;
      start = options.start;
      end = options.end;
      x = options.x;
    } else {
      options = { innerR, start, end };
    }
    const arc2 = this.symbol("arc", x, y, r, r, options);
    arc2.r = r;
    return arc2;
  }
  rect(x, y, width, height, r, strokeWidth) {
    const attribs = isObject6(x) ? x : typeof x === "undefined" ? {} : {
      x,
      y,
      r,
      width: Math.max(width || 0, 0),
      height: Math.max(height || 0, 0)
    }, wrapper = this.createElement("rect");
    if (!this.styledMode) {
      if (typeof strokeWidth !== "undefined") {
        attribs["stroke-width"] = strokeWidth;
        extend7(attribs, wrapper.crisp(attribs));
      }
      attribs.fill = "none";
    }
    wrapper.rSetter = function(value, _key, element) {
      wrapper.r = value;
      attr5(element, {
        rx: value,
        ry: value
      });
    };
    wrapper.rGetter = function() {
      return wrapper.r || 0;
    };
    return wrapper.attr(attribs);
  }
  roundedRect(attribs) {
    return this.symbol("roundedRect").attr(attribs);
  }
  setSize(width, height, animate3) {
    const renderer = this;
    renderer.width = width;
    renderer.height = height;
    renderer.boxWrapper.animate({
      width,
      height
    }, {
      step: function() {
        this.attr({
          viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
        });
      },
      duration: pick10(animate3, true) ? undefined : 0
    });
    renderer.alignElements();
  }
  g(name) {
    const elem = this.createElement("g");
    return name ? elem.attr({ class: "highcharts-" + name }) : elem;
  }
  image(href, x, y, width, height, onload) {
    const attribs = { preserveAspectRatio: "none" };
    if (isNumber9(x)) {
      attribs.x = x;
    }
    if (isNumber9(y)) {
      attribs.y = y;
    }
    if (isNumber9(width)) {
      attribs.width = width;
    }
    if (isNumber9(height)) {
      attribs.height = height;
    }
    const elemWrapper = this.createElement("image").attr(attribs), onDummyLoad = function(e) {
      elemWrapper.attr({ href });
      onload.call(elemWrapper, e);
    };
    if (onload) {
      elemWrapper.attr({
        href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
      });
      const dummy = new win7.Image;
      addEvent3(dummy, "load", onDummyLoad);
      dummy.src = href;
      if (dummy.complete) {
        onDummyLoad({});
      }
    } else {
      elemWrapper.attr({ href });
    }
    return elemWrapper;
  }
  symbol(symbol, x, y, width, height, options) {
    const ren = this, imageRegex = /^url\((.*?)\)$/, isImage = imageRegex.test(symbol), sym = !isImage && (this.symbols[symbol] ? symbol : "circle"), symbolFn = sym && this.symbols[sym];
    let obj, path, imageSrc, centerImage;
    if (symbolFn) {
      if (typeof x === "number") {
        path = symbolFn.call(this.symbols, x || 0, y || 0, width || 0, height || 0, options);
      }
      obj = this.path(path);
      if (!ren.styledMode) {
        obj.attr("fill", "none");
      }
      extend7(obj, {
        symbolName: sym || undefined,
        x,
        y,
        width,
        height
      });
      if (options) {
        extend7(obj, options);
      }
    } else if (isImage) {
      imageSrc = symbol.match(imageRegex)[1];
      const img = obj = this.image(imageSrc);
      img.imgwidth = pick10(options && options.width, symbolSizes[imageSrc] && symbolSizes[imageSrc].width);
      img.imgheight = pick10(options && options.height, symbolSizes[imageSrc] && symbolSizes[imageSrc].height);
      centerImage = (obj2) => obj2.attr({
        width: obj2.width,
        height: obj2.height
      });
      ["width", "height"].forEach((key) => {
        img[`${key}Setter`] = function(value, key2) {
          this[key2] = value;
          const { alignByTranslate, element, width: width2, height: height2, imgwidth, imgheight } = this, imgSize = key2 === "width" ? imgwidth : imgheight;
          let scale = 1;
          if (options && options.backgroundSize === "within" && width2 && height2 && imgwidth && imgheight) {
            scale = Math.min(width2 / imgwidth, height2 / imgheight);
            attr5(element, {
              width: Math.round(imgwidth * scale),
              height: Math.round(imgheight * scale)
            });
          } else if (element && imgSize) {
            element.setAttribute(key2, imgSize);
          }
          if (!alignByTranslate && imgwidth && imgheight) {
            this.translate(((width2 || 0) - imgwidth * scale) / 2, ((height2 || 0) - imgheight * scale) / 2);
          }
        };
      });
      if (defined7(x)) {
        img.attr({
          x,
          y
        });
      }
      img.isImg = true;
      if (defined7(img.imgwidth) && defined7(img.imgheight)) {
        centerImage(img);
      } else {
        img.attr({ width: 0, height: 0 });
        createElement4("img", {
          onload: function() {
            const chart = charts2[ren.chartIndex];
            if (this.width === 0) {
              css4(this, {
                position: "absolute",
                top: "-999em"
              });
              doc4.body.appendChild(this);
            }
            symbolSizes[imageSrc] = {
              width: this.width,
              height: this.height
            };
            img.imgwidth = this.width;
            img.imgheight = this.height;
            if (img.element) {
              centerImage(img);
            }
            if (this.parentNode) {
              this.parentNode.removeChild(this);
            }
            ren.imgCount--;
            if (!ren.imgCount && chart && !chart.hasLoaded) {
              chart.onload();
            }
          },
          src: imageSrc
        });
        this.imgCount++;
      }
    }
    return obj;
  }
  clipRect(x, y, width, height) {
    return this.rect(x, y, width, height, 0);
  }
  text(str, x, y, useHTML) {
    const renderer = this, attribs = {};
    if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
      return renderer.html(str, x, y);
    }
    attribs.x = Math.round(x || 0);
    if (y) {
      attribs.y = Math.round(y);
    }
    if (defined7(str)) {
      attribs.text = str;
    }
    const wrapper = renderer.createElement("text").attr(attribs);
    if (!useHTML || renderer.forExport && !renderer.allowHTML) {
      wrapper.xSetter = function(value, key, element) {
        const tspans = element.getElementsByTagName("tspan"), parentVal = element.getAttribute(key);
        for (let i = 0, tspan;i < tspans.length; i++) {
          tspan = tspans[i];
          if (tspan.getAttribute(key) === parentVal) {
            tspan.setAttribute(key, value);
          }
        }
        element.setAttribute(key, value);
      };
    }
    return wrapper;
  }
  fontMetrics(element) {
    const f = pInt5(SVGElement_default.prototype.getStyle.call(element, "font-size") || 0);
    const h = f < 24 ? f + 3 : Math.round(f * 1.2), b = Math.round(h * 0.8);
    return {
      h,
      b,
      f
    };
  }
  rotCorr(baseline, rotation, alterY) {
    let y = baseline;
    if (rotation && alterY) {
      y = Math.max(y * Math.cos(rotation * deg2rad2), 4);
    }
    return {
      x: -baseline / 3 * Math.sin(rotation * deg2rad2),
      y
    };
  }
  pathToSegments(path) {
    const ret = [];
    const segment = [];
    const commandLength = {
      A: 8,
      C: 7,
      H: 2,
      L: 3,
      M: 3,
      Q: 5,
      S: 5,
      T: 3,
      V: 2
    };
    for (let i = 0;i < path.length; i++) {
      if (isString5(segment[0]) && isNumber9(path[i]) && segment.length === commandLength[segment[0].toUpperCase()]) {
        path.splice(i, 0, segment[0].replace("M", "L").replace("m", "l"));
      }
      if (typeof path[i] === "string") {
        if (segment.length) {
          ret.push(segment.slice(0));
        }
        segment.length = 0;
      }
      segment.push(path[i]);
    }
    ret.push(segment.slice(0));
    return ret;
  }
  label(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
    return new SVGLabel_default(this, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className);
  }
  alignElements() {
    this.alignedObjects.forEach((el) => el.align());
  }
}
extend7(SVGRenderer.prototype, {
  Element: SVGElement_default,
  SVG_NS: SVG_NS4,
  escapes: {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "'": "&#39;",
    '"': "&quot;"
  },
  symbols: Symbols_default,
  draw: noop
});
RendererRegistry_default.registerRendererType("svg", SVGRenderer, true);
var SVGRenderer_default = SVGRenderer;

// node_modules/highcharts/es-modules/Core/Renderer/HTML/HTMLElement.js
var commonSetter = function(value, key, elem) {
  const style = this.div?.style || elem.style;
  SVGElement_default.prototype[`${key}Setter`].call(this, value, key, elem);
  if (style) {
    style[key] = value;
  }
};
var { composed } = Globals_default;
var { attr: attr6, css: css5, createElement: createElement5, defined: defined8, extend: extend8, pInt: pInt6, pushUnique: pushUnique4 } = Utilities_default;
var decorateSVGGroup = (g, container) => {
  if (!g.div) {
    const className = attr6(g.element, "class"), cssProto = g.css;
    const div = createElement5("div", className ? { className } : undefined, {
      position: "absolute",
      left: `${g.translateX || 0}px`,
      top: `${g.translateY || 0}px`,
      ...g.styles,
      display: g.display,
      opacity: g.opacity,
      visibility: g.visibility
    }, g.parentGroup?.div || container);
    g.classSetter = (value, key, element) => {
      element.setAttribute("class", value);
      div.className = value;
    };
    g.translateXSetter = g.translateYSetter = (value, key) => {
      g[key] = value;
      div.style[key === "translateX" ? "left" : "top"] = `${value}px`;
      g.doTransform = true;
    };
    g.opacitySetter = g.visibilitySetter = commonSetter;
    g.css = (styles) => {
      cssProto.call(g, styles);
      if (styles.cursor) {
        div.style.cursor = styles.cursor;
      }
      if (styles.pointerEvents) {
        div.style.pointerEvents = styles.pointerEvents;
      }
      return g;
    };
    g.on = function() {
      SVGElement_default.prototype.on.apply({
        element: div,
        onEvents: g.onEvents
      }, arguments);
      return g;
    };
    g.div = div;
  }
  return g.div;
};

class HTMLElement extends SVGElement_default {
  static compose(SVGRendererClass) {
    if (pushUnique4(composed, this.compose)) {
      SVGRendererClass.prototype.html = function(str, x, y) {
        return new HTMLElement(this, "span").attr({
          text: str,
          x: Math.round(x),
          y: Math.round(y)
        });
      };
    }
  }
  constructor(renderer, nodeName) {
    super(renderer, nodeName);
    this.css({
      position: "absolute",
      ...renderer.styledMode ? {} : {
        fontFamily: renderer.style.fontFamily,
        fontSize: renderer.style.fontSize
      }
    });
    this.element.style.whiteSpace = "nowrap";
  }
  getSpanCorrection(width, baseline, alignCorrection) {
    this.xCorr = -width * alignCorrection;
    this.yCorr = -baseline;
  }
  css(styles) {
    const { element } = this, isSettingWidth = element.tagName === "SPAN" && styles && "width" in styles, textWidth = isSettingWidth && styles.width;
    let doTransform;
    if (isSettingWidth) {
      delete styles.width;
      this.textWidth = pInt6(textWidth) || undefined;
      doTransform = true;
    }
    if (styles?.textOverflow === "ellipsis") {
      styles.whiteSpace = "nowrap";
      styles.overflow = "hidden";
    }
    extend8(this.styles, styles);
    css5(element, styles);
    if (doTransform) {
      this.updateTransform();
    }
    return this;
  }
  htmlGetBBox() {
    const { element } = this;
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  updateTransform() {
    if (!this.added) {
      this.alignOnAdd = true;
      return;
    }
    const { element, renderer, rotation, rotationOriginX, rotationOriginY, styles, textAlign = "left", textWidth, translateX = 0, translateY = 0, x = 0, y = 0 } = this, alignCorrection = {
      left: 0,
      center: 0.5,
      right: 1
    }[textAlign], whiteSpace = styles.whiteSpace;
    const getTextPxLength = () => {
      if (this.textPxLength) {
        return this.textPxLength;
      }
      css5(element, {
        width: "",
        whiteSpace: whiteSpace || "nowrap"
      });
      return element.offsetWidth;
    };
    css5(element, {
      marginLeft: `${translateX}px`,
      marginTop: `${translateY}px`
    });
    if (element.tagName === "SPAN") {
      const currentTextTransform = [
        rotation,
        textAlign,
        element.innerHTML,
        textWidth,
        this.textAlign
      ].join(","), parentPadding = this.parentGroup?.padding * -1 || 0;
      let baseline, hasBoxWidthChanged = false;
      if (textWidth !== this.oldTextWidth) {
        const textPxLength = getTextPxLength(), textWidthNum = textWidth || 0;
        if ((textWidthNum > this.oldTextWidth || textPxLength > textWidthNum) && (/[ \-]/.test(element.textContent || element.innerText) || element.style.textOverflow === "ellipsis")) {
          css5(element, {
            width: textPxLength > textWidthNum || rotation ? textWidth + "px" : "auto",
            display: "block",
            whiteSpace: whiteSpace || "normal"
          });
          this.oldTextWidth = textWidth;
          hasBoxWidthChanged = true;
        }
      }
      this.hasBoxWidthChanged = hasBoxWidthChanged;
      if (currentTextTransform !== this.cTT) {
        baseline = renderer.fontMetrics(element).b;
        if (defined8(rotation) && (rotation !== (this.oldRotation || 0) || textAlign !== this.oldAlign)) {
          this.setSpanRotation(rotation, parentPadding, parentPadding);
        }
        this.getSpanCorrection(!defined8(rotation) && this.textPxLength || element.offsetWidth, baseline, alignCorrection);
      }
      const { xCorr = 0, yCorr = 0 } = this, rotOriginX = (rotationOriginX ?? x) - xCorr - x - parentPadding, rotOriginY = (rotationOriginY ?? y) - yCorr - y - parentPadding, styles2 = {
        left: `${x + xCorr}px`,
        top: `${y + yCorr}px`,
        transformOrigin: `${rotOriginX}px ${rotOriginY}px`
      };
      css5(element, styles2);
      this.cTT = currentTextTransform;
      this.oldRotation = rotation;
      this.oldAlign = textAlign;
    }
  }
  setSpanRotation(rotation, originX, originY) {
    css5(this.element, {
      transform: `rotate(${rotation}deg)`,
      transformOrigin: `${originX}% ${originY}px`
    });
  }
  add(parentGroup) {
    const container = this.renderer.box.parentNode, parents = [];
    let div;
    this.parentGroup = parentGroup;
    if (parentGroup) {
      div = parentGroup.div;
      if (!div) {
        let svgGroup = parentGroup;
        while (svgGroup) {
          parents.push(svgGroup);
          svgGroup = svgGroup.parentGroup;
        }
        for (const parentGroup2 of parents.reverse()) {
          div = decorateSVGGroup(parentGroup2, container);
        }
      }
    }
    (div || container).appendChild(this.element);
    this.added = true;
    if (this.alignOnAdd) {
      this.updateTransform();
    }
    return this;
  }
  textSetter(value) {
    if (value !== this.textStr) {
      delete this.bBox;
      delete this.oldTextWidth;
      AST_default.setElementHTML(this.element, value ?? "");
      this.textStr = value;
      this.doTransform = true;
    }
  }
  alignSetter(value) {
    this.alignValue = this.textAlign = value;
    this.doTransform = true;
  }
  xSetter(value, key) {
    this[key] = value;
    this.doTransform = true;
  }
}
var proto = HTMLElement.prototype;
proto.visibilitySetter = proto.opacitySetter = commonSetter;
proto.ySetter = proto.rotationSetter = proto.rotationOriginXSetter = proto.rotationOriginYSetter = proto.xSetter;
var HTMLElement_default = HTMLElement;

// node_modules/highcharts/es-modules/Core/Axis/AxisDefaults.js
var AxisDefaults;
(function(AxisDefaults2) {
  AxisDefaults2.xAxis = {
    alignTicks: true,
    allowDecimals: undefined,
    panningEnabled: true,
    zIndex: 2,
    zoomEnabled: true,
    dateTimeLabelFormats: {
      millisecond: {
        main: "%H:%M:%S.%L",
        range: false
      },
      second: {
        main: "%H:%M:%S",
        range: false
      },
      minute: {
        main: "%H:%M",
        range: false
      },
      hour: {
        main: "%H:%M",
        range: false
      },
      day: {
        main: "%e %b"
      },
      week: {
        main: "%e %b"
      },
      month: {
        main: "%b \'%y"
      },
      year: {
        main: "%Y"
      }
    },
    endOnTick: false,
    gridLineDashStyle: "Solid",
    gridZIndex: 1,
    labels: {
      autoRotationLimit: 80,
      distance: 15,
      enabled: true,
      indentation: 10,
      overflow: "justify",
      reserveSpace: undefined,
      rotation: undefined,
      staggerLines: 0,
      step: 0,
      useHTML: false,
      zIndex: 7,
      style: {
        color: "#333333",
        cursor: "default",
        fontSize: "0.8em"
      }
    },
    maxPadding: 0.01,
    minorGridLineDashStyle: "Solid",
    minorTickLength: 2,
    minorTickPosition: "outside",
    minorTicksPerMajor: 5,
    minPadding: 0.01,
    offset: undefined,
    reversed: undefined,
    reversedStacks: false,
    showEmpty: true,
    showFirstLabel: true,
    showLastLabel: true,
    startOfWeek: 1,
    startOnTick: false,
    tickLength: 10,
    tickPixelInterval: 100,
    tickmarkPlacement: "between",
    tickPosition: "outside",
    title: {
      align: "middle",
      useHTML: false,
      x: 0,
      y: 0,
      style: {
        color: "#666666",
        fontSize: "0.8em"
      }
    },
    type: "linear",
    uniqueNames: true,
    visible: true,
    minorGridLineColor: "#f2f2f2",
    minorGridLineWidth: 1,
    minorTickColor: "#999999",
    lineColor: "#333333",
    lineWidth: 1,
    gridLineColor: "#e6e6e6",
    gridLineWidth: undefined,
    tickColor: "#333333"
  };
  AxisDefaults2.yAxis = {
    reversedStacks: true,
    endOnTick: true,
    maxPadding: 0.05,
    minPadding: 0.05,
    tickPixelInterval: 72,
    showLastLabel: true,
    labels: {
      x: undefined
    },
    startOnTick: true,
    title: {
      text: "Values"
    },
    stackLabels: {
      animation: {},
      allowOverlap: false,
      enabled: false,
      crop: true,
      overflow: "justify",
      formatter: function() {
        const { numberFormatter } = this.axis.chart;
        return numberFormatter(this.total || 0, -1);
      },
      style: {
        color: "#000000",
        fontSize: "0.7em",
        fontWeight: "bold",
        textOutline: "1px contrast"
      }
    },
    gridLineWidth: 1,
    lineWidth: 0
  };
})(AxisDefaults || (AxisDefaults = {}));
var AxisDefaults_default = AxisDefaults;

// node_modules/highcharts/es-modules/Core/Foundation.js
var { addEvent: addEvent4, isFunction: isFunction4, objectEach: objectEach8, removeEvent: removeEvent3 } = Utilities_default;
var Foundation;
(function(Foundation2) {
  function registerEventOptions(component, options) {
    component.eventOptions = component.eventOptions || {};
    objectEach8(options.events, function(event, eventType) {
      if (component.eventOptions[eventType] !== event) {
        if (component.eventOptions[eventType]) {
          removeEvent3(component, eventType, component.eventOptions[eventType]);
          delete component.eventOptions[eventType];
        }
        if (isFunction4(event)) {
          component.eventOptions[eventType] = event;
          addEvent4(component, eventType, event, {
            order: 0
          });
        }
      }
    });
  }
  Foundation2.registerEventOptions = registerEventOptions;
})(Foundation || (Foundation = {}));
var Foundation_default = Foundation;

// node_modules/highcharts/es-modules/Core/Axis/Tick.js
var { deg2rad: deg2rad3 } = Globals_default;
var { clamp: clamp3, correctFloat: correctFloat2, defined: defined9, destroyObjectProperties: destroyObjectProperties3, extend: extend9, fireEvent: fireEvent5, isNumber: isNumber10, merge: merge9, objectEach: objectEach9, pick: pick11 } = Utilities_default;

class Tick {
  constructor(axis, pos, type, noLabel, parameters) {
    this.isNew = true;
    this.isNewLabel = true;
    this.axis = axis;
    this.pos = pos;
    this.type = type || "";
    this.parameters = parameters || {};
    this.tickmarkOffset = this.parameters.tickmarkOffset;
    this.options = this.parameters.options;
    fireEvent5(this, "init");
    if (!type && !noLabel) {
      this.addLabel();
    }
  }
  addLabel() {
    const tick = this, axis = tick.axis, options = axis.options, chart = axis.chart, categories = axis.categories, log = axis.logarithmic, names = axis.names, pos = tick.pos, labelOptions = pick11(tick.options && tick.options.labels, options.labels), tickPositions = axis.tickPositions, isFirst = pos === tickPositions[0], isLast = pos === tickPositions[tickPositions.length - 1], animateLabels = (!labelOptions.step || labelOptions.step === 1) && axis.tickInterval === 1, tickPositionInfo = tickPositions.info;
    let label = tick.label, dateTimeLabelFormat, dateTimeLabelFormats, i;
    let value = this.parameters.category || (categories ? pick11(categories[pos], names[pos], pos) : pos);
    if (log && isNumber10(value)) {
      value = correctFloat2(log.lin2log(value));
    }
    if (axis.dateTime) {
      if (tickPositionInfo) {
        dateTimeLabelFormats = chart.time.resolveDTLFormat(options.dateTimeLabelFormats[!options.grid && tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName]);
        dateTimeLabelFormat = dateTimeLabelFormats.main;
      } else if (isNumber10(value)) {
        dateTimeLabelFormat = axis.dateTime.getXDateFormat(value, options.dateTimeLabelFormats || {});
      }
    }
    tick.isFirst = isFirst;
    tick.isLast = isLast;
    const ctx = {
      axis,
      chart,
      dateTimeLabelFormat,
      isFirst,
      isLast,
      pos,
      tick,
      tickPositionInfo,
      value
    };
    fireEvent5(this, "labelFormat", ctx);
    const labelFormatter = (ctx2) => {
      if (labelOptions.formatter) {
        return labelOptions.formatter.call(ctx2, ctx2);
      }
      if (labelOptions.format) {
        ctx2.text = axis.defaultLabelFormatter.call(ctx2);
        return Templating_default.format(labelOptions.format, ctx2, chart);
      }
      return axis.defaultLabelFormatter.call(ctx2);
    };
    const str = labelFormatter.call(ctx, ctx);
    const list = dateTimeLabelFormats && dateTimeLabelFormats.list;
    if (list) {
      tick.shortenLabel = function() {
        for (i = 0;i < list.length; i++) {
          extend9(ctx, { dateTimeLabelFormat: list[i] });
          label.attr({
            text: labelFormatter.call(ctx, ctx)
          });
          if (label.getBBox().width < axis.getSlotWidth(tick) - 2 * (labelOptions.padding || 0)) {
            return;
          }
        }
        label.attr({
          text: ""
        });
      };
    } else {
      tick.shortenLabel = undefined;
    }
    if (animateLabels && axis._addedPlotLB) {
      tick.moveLabel(str, labelOptions);
    }
    if (!defined9(label) && !tick.movedLabel) {
      tick.label = label = tick.createLabel(str, labelOptions);
      tick.rotation = 0;
    } else if (label && label.textStr !== str && !animateLabels) {
      if (label.textWidth && !labelOptions.style.width && !label.styles.width) {
        label.css({ width: null });
      }
      label.attr({ text: str });
      label.textPxLength = label.getBBox().width;
    }
  }
  createLabel(str, labelOptions, xy) {
    const axis = this.axis, chart = axis.chart, label = defined9(str) && labelOptions.enabled ? chart.renderer.text(str, xy?.x, xy?.y, labelOptions.useHTML).add(axis.labelGroup) : undefined;
    if (label) {
      if (!chart.styledMode) {
        label.css(merge9(labelOptions.style));
      }
      label.textPxLength = label.getBBox().width;
    }
    return label;
  }
  destroy() {
    destroyObjectProperties3(this, this.axis);
  }
  getPosition(horiz, tickPos, tickmarkOffset, old) {
    const axis = this.axis, chart = axis.chart, cHeight = old && chart.oldChartHeight || chart.chartHeight, pos = {
      x: horiz ? correctFloat2(axis.translate(tickPos + tickmarkOffset, undefined, undefined, old) + axis.transB) : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),
      y: horiz ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : correctFloat2(cHeight - axis.translate(tickPos + tickmarkOffset, undefined, undefined, old) - axis.transB)
    };
    pos.y = clamp3(pos.y, -1e5, 1e5);
    fireEvent5(this, "afterGetPosition", { pos });
    return pos;
  }
  getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
    const axis = this.axis, transA = axis.transA, reversed = axis.isLinked && axis.linkedParent ? axis.linkedParent.reversed : axis.reversed, staggerLines = axis.staggerLines, rotCorr = axis.tickRotCorr || { x: 0, y: 0 }, labelOffsetCorrection = !horiz && !axis.reserveSpaceDefault ? -axis.labelOffset * (axis.labelAlign === "center" ? 0.5 : 1) : 0, distance = labelOptions.distance, pos = {};
    let yOffset, line;
    if (axis.side === 0) {
      yOffset = label.rotation ? -distance : -label.getBBox().height;
    } else if (axis.side === 2) {
      yOffset = rotCorr.y + distance;
    } else {
      yOffset = Math.cos(label.rotation * deg2rad3) * (rotCorr.y - label.getBBox(false, 0).height / 2);
    }
    if (defined9(labelOptions.y)) {
      yOffset = axis.side === 0 && axis.horiz ? labelOptions.y + yOffset : labelOptions.y;
    }
    x = x + pick11(labelOptions.x, [0, 1, 0, -1][axis.side] * distance) + labelOffsetCorrection + rotCorr.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
    y = y + yOffset - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
    if (staggerLines) {
      line = index / (step || 1) % staggerLines;
      if (axis.opposite) {
        line = staggerLines - line - 1;
      }
      y += line * (axis.labelOffset / staggerLines);
    }
    pos.x = x;
    pos.y = Math.round(y);
    fireEvent5(this, "afterGetLabelPosition", { pos, tickmarkOffset, index });
    return pos;
  }
  getLabelSize() {
    return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
  }
  getMarkPath(x, y, tickLength, tickWidth, horiz = false, renderer) {
    return renderer.crispLine([[
      "M",
      x,
      y
    ], [
      "L",
      x + (horiz ? 0 : -tickLength),
      y + (horiz ? tickLength : 0)
    ]], tickWidth);
  }
  handleOverflow(xy) {
    const tick = this, axis = this.axis, labelOptions = axis.options.labels, pxPos = xy.x, chartWidth = axis.chart.chartWidth, spacing = axis.chart.spacing, leftBound = pick11(axis.labelLeft, Math.min(axis.pos, spacing[3])), rightBound = pick11(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1])), label = this.label, rotation = this.rotation, factor = {
      left: 0,
      center: 0.5,
      right: 1
    }[axis.labelAlign || label.attr("align")], labelWidth = label.getBBox().width, slotWidth = axis.getSlotWidth(tick), xCorrection = factor, css6 = {};
    let modifiedSlotWidth = slotWidth, goRight = 1, leftPos, rightPos, textWidth;
    if (!rotation && labelOptions.overflow === "justify") {
      leftPos = pxPos - factor * labelWidth;
      rightPos = pxPos + (1 - factor) * labelWidth;
      if (leftPos < leftBound) {
        modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
      } else if (rightPos > rightBound) {
        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
        goRight = -1;
      }
      modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth);
      if (modifiedSlotWidth < slotWidth && axis.labelAlign === "center") {
        xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));
      }
      if (labelWidth > modifiedSlotWidth || axis.autoRotation && (label.styles || {}).width) {
        textWidth = modifiedSlotWidth;
      }
    } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
      textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad3) - leftBound);
    } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
      textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad3));
    }
    if (textWidth) {
      if (tick.shortenLabel) {
        tick.shortenLabel();
      } else {
        css6.width = Math.floor(textWidth) + "px";
        if (!(labelOptions.style || {}).textOverflow) {
          css6.textOverflow = "ellipsis";
        }
        label.css(css6);
      }
    }
  }
  moveLabel(str, labelOptions) {
    const tick = this, label = tick.label, axis = tick.axis;
    let moved = false, labelPos;
    if (label && label.textStr === str) {
      tick.movedLabel = label;
      moved = true;
      delete tick.label;
    } else {
      objectEach9(axis.ticks, function(currentTick) {
        if (!moved && !currentTick.isNew && currentTick !== tick && currentTick.label && currentTick.label.textStr === str) {
          tick.movedLabel = currentTick.label;
          moved = true;
          currentTick.labelPos = tick.movedLabel.xy;
          delete currentTick.label;
        }
      });
    }
    if (!moved && (tick.labelPos || label)) {
      labelPos = tick.labelPos || label.xy;
      tick.movedLabel = tick.createLabel(str, labelOptions, labelPos);
      if (tick.movedLabel) {
        tick.movedLabel.attr({ opacity: 0 });
      }
    }
  }
  render(index, old, opacity) {
    const tick = this, axis = tick.axis, horiz = axis.horiz, pos = tick.pos, tickmarkOffset = pick11(tick.tickmarkOffset, axis.tickmarkOffset), xy = tick.getPosition(horiz, pos, tickmarkOffset, old), x = xy.x, y = xy.y, axisStart = axis.pos, axisEnd = axisStart + axis.len, pxPos = horiz ? x : y;
    if (!axis.chart.polar && tick.isNew && (correctFloat2(pxPos) < axisStart || pxPos > axisEnd)) {
      opacity = 0;
    }
    const labelOpacity = pick11(opacity, tick.label && tick.label.newOpacity, 1);
    opacity = pick11(opacity, 1);
    this.isActive = true;
    this.renderGridLine(old, opacity);
    this.renderMark(xy, opacity);
    this.renderLabel(xy, old, labelOpacity, index);
    tick.isNew = false;
    fireEvent5(this, "afterRender");
  }
  renderGridLine(old, opacity) {
    const tick = this, axis = tick.axis, options = axis.options, attribs = {}, pos = tick.pos, type = tick.type, tickmarkOffset = pick11(tick.tickmarkOffset, axis.tickmarkOffset), renderer = axis.chart.renderer;
    let gridLine = tick.gridLine, gridLinePath, gridLineWidth = options.gridLineWidth, gridLineColor = options.gridLineColor, dashStyle = options.gridLineDashStyle;
    if (tick.type === "minor") {
      gridLineWidth = options.minorGridLineWidth;
      gridLineColor = options.minorGridLineColor;
      dashStyle = options.minorGridLineDashStyle;
    }
    if (!gridLine) {
      if (!axis.chart.styledMode) {
        attribs.stroke = gridLineColor;
        attribs["stroke-width"] = gridLineWidth || 0;
        attribs.dashstyle = dashStyle;
      }
      if (!type) {
        attribs.zIndex = 1;
      }
      if (old) {
        opacity = 0;
      }
      tick.gridLine = gridLine = renderer.path().attr(attribs).addClass("highcharts-" + (type ? type + "-" : "") + "grid-line").add(axis.gridGroup);
    }
    if (gridLine) {
      gridLinePath = axis.getPlotLinePath({
        value: pos + tickmarkOffset,
        lineWidth: gridLine.strokeWidth(),
        force: "pass",
        old,
        acrossPanes: false
      });
      if (gridLinePath) {
        gridLine[old || tick.isNew ? "attr" : "animate"]({
          d: gridLinePath,
          opacity
        });
      }
    }
  }
  renderMark(xy, opacity) {
    const tick = this, axis = tick.axis, options = axis.options, renderer = axis.chart.renderer, type = tick.type, tickSize = axis.tickSize(type ? type + "Tick" : "tick"), x = xy.x, y = xy.y, tickWidth = pick11(options[type !== "minor" ? "tickWidth" : "minorTickWidth"], !type && axis.isXAxis ? 1 : 0), tickColor = options[type !== "minor" ? "tickColor" : "minorTickColor"];
    let mark = tick.mark;
    const isNewMark = !mark;
    if (tickSize) {
      if (axis.opposite) {
        tickSize[0] = -tickSize[0];
      }
      if (!mark) {
        tick.mark = mark = renderer.path().addClass("highcharts-" + (type ? type + "-" : "") + "tick").add(axis.axisGroup);
        if (!axis.chart.styledMode) {
          mark.attr({
            stroke: tickColor,
            "stroke-width": tickWidth
          });
        }
      }
      mark[isNewMark ? "attr" : "animate"]({
        d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth(), axis.horiz, renderer),
        opacity
      });
    }
  }
  renderLabel(xy, old, opacity, index) {
    const tick = this, axis = tick.axis, horiz = axis.horiz, options = axis.options, label = tick.label, labelOptions = options.labels, step = labelOptions.step, tickmarkOffset = pick11(tick.tickmarkOffset, axis.tickmarkOffset), x = xy.x, y = xy.y;
    let show = true;
    if (label && isNumber10(x)) {
      label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
      if (tick.isFirst && !tick.isLast && !options.showFirstLabel || tick.isLast && !tick.isFirst && !options.showLastLabel) {
        show = false;
      } else if (horiz && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
        tick.handleOverflow(xy);
      }
      if (step && index % step) {
        show = false;
      }
      if (show && isNumber10(xy.y)) {
        xy.opacity = opacity;
        label[tick.isNewLabel ? "attr" : "animate"](xy).show(true);
        tick.isNewLabel = false;
      } else {
        label.hide();
        tick.isNewLabel = true;
      }
    }
  }
  replaceMovedLabel() {
    const tick = this, label = tick.label, axis = tick.axis;
    if (label && !tick.isNew) {
      label.animate({ opacity: 0 }, undefined, label.destroy);
      delete tick.label;
    }
    axis.isDirty = true;
    tick.label = tick.movedLabel;
    delete tick.movedLabel;
  }
}
var Tick_default = Tick;

// node_modules/highcharts/es-modules/Core/Axis/Axis.js
var { animObject: animObject3 } = AnimationUtilities_default;
var { xAxis, yAxis } = AxisDefaults_default;
var { defaultOptions: defaultOptions4 } = Defaults_default;
var { registerEventOptions } = Foundation_default;
var { deg2rad: deg2rad4 } = Globals_default;
var { arrayMax: arrayMax2, arrayMin: arrayMin2, clamp: clamp4, correctFloat: correctFloat3, defined: defined10, destroyObjectProperties: destroyObjectProperties4, erase: erase3, error: error4, extend: extend10, fireEvent: fireEvent6, getClosestDistance: getClosestDistance2, insertItem: insertItem2, isArray: isArray6, isNumber: isNumber11, isString: isString6, merge: merge10, normalizeTickInterval: normalizeTickInterval2, objectEach: objectEach10, pick: pick12, relativeLength: relativeLength2, removeEvent: removeEvent4, splat: splat4, syncTimeout: syncTimeout3 } = Utilities_default;
var getNormalizedTickInterval = (axis, tickInterval) => normalizeTickInterval2(tickInterval, undefined, undefined, pick12(axis.options.allowDecimals, tickInterval < 0.5 || axis.tickAmount !== undefined), !!axis.tickAmount);
extend10(defaultOptions4, { xAxis, yAxis: merge10(xAxis, yAxis) });

class Axis {
  constructor(chart, userOptions, coll) {
    this.init(chart, userOptions, coll);
  }
  init(chart, userOptions, coll = this.coll) {
    const isXAxis = coll === "xAxis", axis = this, horiz = axis.isZAxis || (chart.inverted ? !isXAxis : isXAxis);
    axis.chart = chart;
    axis.horiz = horiz;
    axis.isXAxis = isXAxis;
    axis.coll = coll;
    fireEvent6(this, "init", { userOptions });
    axis.opposite = pick12(userOptions.opposite, axis.opposite);
    axis.side = pick12(userOptions.side, axis.side, horiz ? axis.opposite ? 0 : 2 : axis.opposite ? 1 : 3);
    axis.setOptions(userOptions);
    const options = this.options, labelsOptions = options.labels, type = options.type;
    axis.userOptions = userOptions;
    axis.minPixelPadding = 0;
    axis.reversed = pick12(options.reversed, axis.reversed);
    axis.visible = options.visible;
    axis.zoomEnabled = options.zoomEnabled;
    axis.hasNames = type === "category" || options.categories === true;
    axis.categories = isArray6(options.categories) && options.categories || (axis.hasNames ? [] : undefined);
    if (!axis.names) {
      axis.names = [];
      axis.names.keys = {};
    }
    axis.plotLinesAndBandsGroups = {};
    axis.positiveValuesOnly = !!axis.logarithmic;
    axis.isLinked = defined10(options.linkedTo);
    axis.ticks = {};
    axis.labelEdge = [];
    axis.minorTicks = {};
    axis.plotLinesAndBands = [];
    axis.alternateBands = {};
    axis.len ?? (axis.len = 0);
    axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
    axis.range = options.range;
    axis.offset = options.offset || 0;
    axis.max = undefined;
    axis.min = undefined;
    const crosshair = pick12(options.crosshair, splat4(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1]);
    axis.crosshair = crosshair === true ? {} : crosshair;
    if (chart.axes.indexOf(axis) === -1) {
      if (isXAxis) {
        chart.axes.splice(chart.xAxis.length, 0, axis);
      } else {
        chart.axes.push(axis);
      }
      insertItem2(this, chart[this.coll]);
    }
    chart.orderItems(axis.coll);
    axis.series = axis.series || [];
    if (chart.inverted && !axis.isZAxis && isXAxis && !defined10(axis.reversed)) {
      axis.reversed = true;
    }
    axis.labelRotation = isNumber11(labelsOptions.rotation) ? labelsOptions.rotation : undefined;
    registerEventOptions(axis, options);
    fireEvent6(this, "afterInit");
  }
  setOptions(userOptions) {
    const sideSpecific = this.horiz ? {
      labels: {
        autoRotation: [-45],
        padding: 4
      },
      margin: 15
    } : {
      labels: {
        padding: 1
      },
      title: {
        rotation: 90 * this.side
      }
    };
    this.options = merge10(sideSpecific, defaultOptions4[this.coll], userOptions);
    fireEvent6(this, "afterSetOptions", { userOptions });
  }
  defaultLabelFormatter() {
    const axis = this.axis, chart = this.chart, { numberFormatter } = chart, value = isNumber11(this.value) ? this.value : NaN, time = axis.chart.time, categories = axis.categories, dateTimeLabelFormat = this.dateTimeLabelFormat, lang = defaultOptions4.lang, numericSymbols = lang.numericSymbols, numSymMagnitude = lang.numericSymbolMagnitude || 1000, numericSymbolDetector = axis.logarithmic ? Math.abs(value) : axis.tickInterval;
    let i = numericSymbols && numericSymbols.length, multi, ret;
    if (categories) {
      ret = `${this.value}`;
    } else if (dateTimeLabelFormat) {
      ret = time.dateFormat(dateTimeLabelFormat, value);
    } else if (i && numericSymbols && numericSymbolDetector >= 1000) {
      while (i-- && typeof ret === "undefined") {
        multi = Math.pow(numSymMagnitude, i + 1);
        if (numericSymbolDetector >= multi && value * 10 % multi === 0 && numericSymbols[i] !== null && value !== 0) {
          ret = numberFormatter(value / multi, -1) + numericSymbols[i];
        }
      }
    }
    if (typeof ret === "undefined") {
      if (Math.abs(value) >= 1e4) {
        ret = numberFormatter(value, -1);
      } else {
        ret = numberFormatter(value, -1, undefined, "");
      }
    }
    return ret;
  }
  getSeriesExtremes() {
    const axis = this;
    let xExtremes;
    fireEvent6(this, "getSeriesExtremes", null, function() {
      axis.hasVisibleSeries = false;
      axis.dataMin = axis.dataMax = axis.threshold = undefined;
      axis.softThreshold = !axis.isXAxis;
      axis.series.forEach((series) => {
        if (series.reserveSpace()) {
          const seriesOptions = series.options;
          let xData, threshold = seriesOptions.threshold, seriesDataMin, seriesDataMax;
          axis.hasVisibleSeries = true;
          if (axis.positiveValuesOnly && (threshold || 0) <= 0) {
            threshold = undefined;
          }
          if (axis.isXAxis) {
            xData = series.xData;
            if (xData && xData.length) {
              xData = axis.logarithmic ? xData.filter((x) => x > 0) : xData;
              xExtremes = series.getXExtremes(xData);
              seriesDataMin = xExtremes.min;
              seriesDataMax = xExtremes.max;
              if (!isNumber11(seriesDataMin) && !(seriesDataMin instanceof Date)) {
                xData = xData.filter(isNumber11);
                xExtremes = series.getXExtremes(xData);
                seriesDataMin = xExtremes.min;
                seriesDataMax = xExtremes.max;
              }
              if (xData.length) {
                axis.dataMin = Math.min(pick12(axis.dataMin, seriesDataMin), seriesDataMin);
                axis.dataMax = Math.max(pick12(axis.dataMax, seriesDataMax), seriesDataMax);
              }
            }
          } else {
            const dataExtremes = series.applyExtremes();
            if (isNumber11(dataExtremes.dataMin)) {
              seriesDataMin = dataExtremes.dataMin;
              axis.dataMin = Math.min(pick12(axis.dataMin, seriesDataMin), seriesDataMin);
            }
            if (isNumber11(dataExtremes.dataMax)) {
              seriesDataMax = dataExtremes.dataMax;
              axis.dataMax = Math.max(pick12(axis.dataMax, seriesDataMax), seriesDataMax);
            }
            if (defined10(threshold)) {
              axis.threshold = threshold;
            }
            if (!seriesOptions.softThreshold || axis.positiveValuesOnly) {
              axis.softThreshold = false;
            }
          }
        }
      });
    });
    fireEvent6(this, "afterGetSeriesExtremes");
  }
  translate(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
    const axis = this.linkedParent || this, localMin = old && axis.old ? axis.old.min : axis.min;
    if (!isNumber11(localMin)) {
      return NaN;
    }
    const minPixelPadding = axis.minPixelPadding, doPostTranslate = (axis.isOrdinal || axis.brokenAxis?.hasBreaks || axis.logarithmic && handleLog) && axis.lin2val;
    let sign = 1, cvsOffset = 0, localA = old && axis.old ? axis.old.transA : axis.transA, returnValue = 0;
    if (!localA) {
      localA = axis.transA;
    }
    if (cvsCoord) {
      sign *= -1;
      cvsOffset = axis.len;
    }
    if (axis.reversed) {
      sign *= -1;
      cvsOffset -= sign * (axis.sector || axis.len);
    }
    if (backwards) {
      val = val * sign + cvsOffset;
      val -= minPixelPadding;
      returnValue = val / localA + localMin;
      if (doPostTranslate) {
        returnValue = axis.lin2val(returnValue);
      }
    } else {
      if (doPostTranslate) {
        val = axis.val2lin(val);
      }
      const value = sign * (val - localMin) * localA;
      returnValue = value + cvsOffset + sign * minPixelPadding + (isNumber11(pointPlacement) ? localA * pointPlacement : 0);
      if (!axis.isRadial) {
        returnValue = correctFloat3(returnValue);
      }
    }
    return returnValue;
  }
  toPixels(value, paneCoordinates) {
    return this.translate(value, false, !this.horiz, undefined, true) + (paneCoordinates ? 0 : this.pos);
  }
  toValue(pixel, paneCoordinates) {
    return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, undefined, true);
  }
  getPlotLinePath(options) {
    const axis = this, chart = axis.chart, axisLeft = axis.left, axisTop = axis.top, old = options.old, value = options.value, lineWidth = options.lineWidth, cHeight = old && chart.oldChartHeight || chart.chartHeight, cWidth = old && chart.oldChartWidth || chart.chartWidth, transB = axis.transB;
    let { translatedValue, force } = options, x1, y1, x2, y2, skip;
    function between(x, a, b) {
      if (force !== "pass" && (x < a || x > b)) {
        if (force) {
          x = clamp4(x, a, b);
        } else {
          skip = true;
        }
      }
      return x;
    }
    const evt = {
      value,
      lineWidth,
      old,
      force,
      acrossPanes: options.acrossPanes,
      translatedValue
    };
    fireEvent6(this, "getPlotLinePath", evt, function(e) {
      translatedValue = pick12(translatedValue, axis.translate(value, undefined, undefined, old));
      translatedValue = clamp4(translatedValue, -1e5, 1e5);
      x1 = x2 = translatedValue + transB;
      y1 = y2 = cHeight - translatedValue - transB;
      if (!isNumber11(translatedValue)) {
        skip = true;
        force = false;
      } else if (axis.horiz) {
        y1 = axisTop;
        y2 = cHeight - axis.bottom + (chart.scrollablePixelsY || 0);
        x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
      } else {
        x1 = axisLeft;
        x2 = cWidth - axis.right + (chart.scrollablePixelsX || 0);
        y1 = y2 = between(y1, axisTop, axisTop + axis.height);
      }
      e.path = skip && !force ? undefined : chart.renderer.crispLine([["M", x1, y1], ["L", x2, y2]], lineWidth || 1);
    });
    return evt.path;
  }
  getLinearTickPositions(tickInterval, min, max) {
    const roundedMin = correctFloat3(Math.floor(min / tickInterval) * tickInterval), roundedMax = correctFloat3(Math.ceil(max / tickInterval) * tickInterval), tickPositions = [];
    let pos, lastPos, precision;
    if (correctFloat3(roundedMin + tickInterval) === roundedMin) {
      precision = 20;
    }
    if (this.single) {
      return [min];
    }
    pos = roundedMin;
    while (pos <= roundedMax) {
      tickPositions.push(pos);
      pos = correctFloat3(pos + tickInterval, precision);
      if (pos === lastPos) {
        break;
      }
      lastPos = pos;
    }
    return tickPositions;
  }
  getMinorTickInterval() {
    const { minorTicks, minorTickInterval } = this.options;
    if (minorTicks === true) {
      return pick12(minorTickInterval, "auto");
    }
    if (minorTicks === false) {
      return;
    }
    return minorTickInterval;
  }
  getMinorTickPositions() {
    const axis = this, options = axis.options, tickPositions = axis.tickPositions, minorTickInterval = axis.minorTickInterval, pointRangePadding = axis.pointRangePadding || 0, min = (axis.min || 0) - pointRangePadding, max = (axis.max || 0) + pointRangePadding, range = max - min;
    let minorTickPositions = [], pos;
    if (range && range / minorTickInterval < axis.len / 3) {
      const logarithmic = axis.logarithmic;
      if (logarithmic) {
        this.paddedTicks.forEach(function(_pos, i, paddedTicks) {
          if (i) {
            minorTickPositions.push.apply(minorTickPositions, logarithmic.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));
          }
        });
      } else if (axis.dateTime && this.getMinorTickInterval() === "auto") {
        minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval), min, max, options.startOfWeek));
      } else {
        for (pos = min + (tickPositions[0] - min) % minorTickInterval;pos <= max; pos += minorTickInterval) {
          if (pos === minorTickPositions[0]) {
            break;
          }
          minorTickPositions.push(pos);
        }
      }
    }
    if (minorTickPositions.length !== 0) {
      axis.trimTicks(minorTickPositions);
    }
    return minorTickPositions;
  }
  adjustForMinRange() {
    const axis = this, options = axis.options, logarithmic = axis.logarithmic;
    let { max, min, minRange } = axis, zoomOffset, spaceAvailable, closestDataRange, minArgs, maxArgs;
    if (axis.isXAxis && typeof minRange === "undefined" && !logarithmic) {
      if (defined10(options.min) || defined10(options.max) || defined10(options.floor) || defined10(options.ceiling)) {
        minRange = null;
      } else {
        closestDataRange = getClosestDistance2(axis.series.map((s) => (s.xIncrement ? s.xData?.slice(0, 2) : s.xData) || [])) || 0;
        minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);
      }
    }
    if (isNumber11(max) && isNumber11(min) && isNumber11(minRange) && max - min < minRange) {
      spaceAvailable = axis.dataMax - axis.dataMin >= minRange;
      zoomOffset = (minRange - max + min) / 2;
      minArgs = [
        min - zoomOffset,
        pick12(options.min, min - zoomOffset)
      ];
      if (spaceAvailable) {
        minArgs[2] = logarithmic ? logarithmic.log2lin(axis.dataMin) : axis.dataMin;
      }
      min = arrayMax2(minArgs);
      maxArgs = [
        min + minRange,
        pick12(options.max, min + minRange)
      ];
      if (spaceAvailable) {
        maxArgs[2] = logarithmic ? logarithmic.log2lin(axis.dataMax) : axis.dataMax;
      }
      max = arrayMin2(maxArgs);
      if (max - min < minRange) {
        minArgs[0] = max - minRange;
        minArgs[1] = pick12(options.min, max - minRange);
        min = arrayMax2(minArgs);
      }
    }
    axis.minRange = minRange;
    axis.min = min;
    axis.max = max;
  }
  getClosest() {
    let closestSingleDistance, closestDistance;
    if (this.categories) {
      closestDistance = 1;
    } else {
      const singleXs = [];
      this.series.forEach(function(series) {
        const seriesClosest = series.closestPointRange;
        if (series.xData?.length === 1) {
          singleXs.push(series.xData[0]);
        } else if (!series.noSharedTooltip && defined10(seriesClosest) && series.reserveSpace()) {
          closestDistance = defined10(closestDistance) ? Math.min(closestDistance, seriesClosest) : seriesClosest;
        }
      });
      if (singleXs.length) {
        singleXs.sort((a, b) => a - b);
        closestSingleDistance = getClosestDistance2([singleXs]);
      }
    }
    if (closestSingleDistance && closestDistance) {
      return Math.min(closestSingleDistance, closestDistance);
    }
    return closestSingleDistance || closestDistance;
  }
  nameToX(point) {
    const explicitCategories = isArray6(this.options.categories), names = explicitCategories ? this.categories : this.names;
    let nameX = point.options.x, x;
    point.series.requireSorting = false;
    if (!defined10(nameX)) {
      nameX = this.options.uniqueNames && names ? explicitCategories ? names.indexOf(point.name) : pick12(names.keys[point.name], -1) : point.series.autoIncrement();
    }
    if (nameX === -1) {
      if (!explicitCategories && names) {
        x = names.length;
      }
    } else {
      x = nameX;
    }
    if (typeof x !== "undefined") {
      this.names[x] = point.name;
      this.names.keys[point.name] = x;
    } else if (point.x) {
      x = point.x;
    }
    return x;
  }
  updateNames() {
    const axis = this, names = this.names, i = names.length;
    if (i > 0) {
      Object.keys(names.keys).forEach(function(key) {
        delete names.keys[key];
      });
      names.length = 0;
      this.minRange = this.userMinRange;
      (this.series || []).forEach((series) => {
        series.xIncrement = null;
        if (!series.points || series.isDirtyData) {
          axis.max = Math.max(axis.max, series.xData.length - 1);
          series.processData();
          series.generatePoints();
        }
        series.data.forEach(function(point, i2) {
          let x;
          if (point?.options && typeof point.name !== "undefined") {
            x = axis.nameToX(point);
            if (typeof x !== "undefined" && x !== point.x) {
              point.x = x;
              series.xData[i2] = x;
            }
          }
        });
      });
    }
  }
  setAxisTranslation() {
    const axis = this, range = axis.max - axis.min, linkedParent = axis.linkedParent, hasCategories = !!axis.categories, isXAxis = axis.isXAxis;
    let pointRange = axis.axisPointRange || 0, closestPointRange, minPointOffset = 0, pointRangePadding = 0, ordinalCorrection, transA = axis.transA;
    if (isXAxis || hasCategories || pointRange) {
      closestPointRange = axis.getClosest();
      if (linkedParent) {
        minPointOffset = linkedParent.minPointOffset;
        pointRangePadding = linkedParent.pointRangePadding;
      } else {
        axis.series.forEach(function(series) {
          const seriesPointRange = hasCategories ? 1 : isXAxis ? pick12(series.options.pointRange, closestPointRange, 0) : axis.axisPointRange || 0, pointPlacement = series.options.pointPlacement;
          pointRange = Math.max(pointRange, seriesPointRange);
          if (!axis.single || hasCategories) {
            const isPointPlacementAxis = series.is("xrange") ? !isXAxis : isXAxis;
            minPointOffset = Math.max(minPointOffset, isPointPlacementAxis && isString6(pointPlacement) ? 0 : seriesPointRange / 2);
            pointRangePadding = Math.max(pointRangePadding, isPointPlacementAxis && pointPlacement === "on" ? 0 : seriesPointRange);
          }
        });
      }
      ordinalCorrection = axis.ordinal && axis.ordinal.slope && closestPointRange ? axis.ordinal.slope / closestPointRange : 1;
      axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
      axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;
      axis.pointRange = Math.min(pointRange, axis.single && hasCategories ? 1 : range);
      if (isXAxis && closestPointRange) {
        axis.closestPointRange = closestPointRange;
      }
    }
    axis.translationSlope = axis.transA = transA = axis.staticScale || axis.len / (range + pointRangePadding || 1);
    axis.transB = axis.horiz ? axis.left : axis.bottom;
    axis.minPixelPadding = transA * minPointOffset;
    fireEvent6(this, "afterSetAxisTranslation");
  }
  minFromRange() {
    const { max, min } = this;
    return isNumber11(max) && isNumber11(min) && max - min || undefined;
  }
  setTickInterval(secondPass) {
    const axis = this, { categories, chart, dataMax, dataMin, dateTime, isXAxis, logarithmic, options, softThreshold } = axis, threshold = isNumber11(axis.threshold) ? axis.threshold : undefined, minRange = axis.minRange || 0, { ceiling, floor, linkedTo, softMax, softMin } = options, linkedParent = isNumber11(linkedTo) && chart[axis.coll]?.[linkedTo], tickPixelIntervalOption = options.tickPixelInterval;
    let { maxPadding, minPadding } = options, range = 0, linkedParentExtremes, tickIntervalOption = isNumber11(options.tickInterval) && options.tickInterval >= 0 ? options.tickInterval : undefined, thresholdMin, thresholdMax, hardMin, hardMax;
    if (!dateTime && !categories && !linkedParent) {
      this.getTickAmount();
    }
    hardMin = pick12(axis.userMin, options.min);
    hardMax = pick12(axis.userMax, options.max);
    if (linkedParent) {
      axis.linkedParent = linkedParent;
      linkedParentExtremes = linkedParent.getExtremes();
      axis.min = pick12(linkedParentExtremes.min, linkedParentExtremes.dataMin);
      axis.max = pick12(linkedParentExtremes.max, linkedParentExtremes.dataMax);
      if (options.type !== linkedParent.options.type) {
        error4(11, true, chart);
      }
    } else {
      if (softThreshold && defined10(threshold) && isNumber11(dataMax) && isNumber11(dataMin)) {
        if (dataMin >= threshold) {
          thresholdMin = threshold;
          minPadding = 0;
        } else if (dataMax <= threshold) {
          thresholdMax = threshold;
          maxPadding = 0;
        }
      }
      axis.min = pick12(hardMin, thresholdMin, dataMin);
      axis.max = pick12(hardMax, thresholdMax, dataMax);
    }
    if (isNumber11(axis.max) && isNumber11(axis.min)) {
      if (logarithmic) {
        if (axis.positiveValuesOnly && !secondPass && Math.min(axis.min, pick12(dataMin, axis.min)) <= 0) {
          error4(10, true, chart);
        }
        axis.min = correctFloat3(logarithmic.log2lin(axis.min), 16);
        axis.max = correctFloat3(logarithmic.log2lin(axis.max), 16);
      }
      if (axis.range && isNumber11(dataMin)) {
        axis.userMin = axis.min = hardMin = Math.max(dataMin, axis.minFromRange() || 0);
        axis.userMax = hardMax = axis.max;
        axis.range = undefined;
      }
    }
    fireEvent6(axis, "foundExtremes");
    axis.adjustForMinRange();
    if (isNumber11(axis.min) && isNumber11(axis.max)) {
      if (!isNumber11(axis.userMin) && isNumber11(softMin) && softMin < axis.min) {
        axis.min = hardMin = softMin;
      }
      if (!isNumber11(axis.userMax) && isNumber11(softMax) && softMax > axis.max) {
        axis.max = hardMax = softMax;
      }
      if (!categories && !axis.axisPointRange && !axis.stacking?.usePercentage && !linkedParent) {
        range = axis.max - axis.min;
        if (range) {
          if (!defined10(hardMin) && minPadding) {
            axis.min -= range * minPadding;
          }
          if (!defined10(hardMax) && maxPadding) {
            axis.max += range * maxPadding;
          }
        }
      }
      if (!isNumber11(axis.userMin) && isNumber11(floor)) {
        axis.min = Math.max(axis.min, floor);
      }
      if (!isNumber11(axis.userMax) && isNumber11(ceiling)) {
        axis.max = Math.min(axis.max, ceiling);
      }
      if (softThreshold && isNumber11(dataMin) && isNumber11(dataMax)) {
        const numThreshold = threshold || 0;
        if (!defined10(hardMin) && axis.min < numThreshold && dataMin >= numThreshold) {
          axis.min = options.minRange ? Math.min(numThreshold, axis.max - minRange) : numThreshold;
        } else if (!defined10(hardMax) && axis.max > numThreshold && dataMax <= numThreshold) {
          axis.max = options.minRange ? Math.max(numThreshold, axis.min + minRange) : numThreshold;
        }
      }
      if (!chart.polar && axis.min > axis.max) {
        if (defined10(options.min)) {
          axis.max = axis.min;
        } else if (defined10(options.max)) {
          axis.min = axis.max;
        }
      }
      range = axis.max - axis.min;
    }
    if (axis.min === axis.max || !isNumber11(axis.min) || !isNumber11(axis.max)) {
      axis.tickInterval = 1;
    } else if (linkedParent && !tickIntervalOption && tickPixelIntervalOption === linkedParent.options.tickPixelInterval) {
      axis.tickInterval = tickIntervalOption = linkedParent.tickInterval;
    } else {
      axis.tickInterval = pick12(tickIntervalOption, this.tickAmount ? range / Math.max(this.tickAmount - 1, 1) : undefined, categories ? 1 : range * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption));
    }
    if (isXAxis && !secondPass) {
      const hasExtremesChanged = axis.min !== axis.old?.min || axis.max !== axis.old?.max;
      axis.series.forEach(function(series) {
        series.forceCrop = series.forceCropping?.();
        series.processData(hasExtremesChanged);
      });
      fireEvent6(this, "postProcessData", { hasExtremesChanged });
    }
    axis.setAxisTranslation();
    fireEvent6(this, "initialAxisTranslation");
    if (axis.pointRange && !tickIntervalOption) {
      axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
    }
    const minTickInterval = pick12(options.minTickInterval, dateTime && !axis.series.some((s) => s.noSharedTooltip) ? axis.closestPointRange : 0);
    if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
      axis.tickInterval = minTickInterval;
    }
    if (!dateTime && !logarithmic && !tickIntervalOption) {
      axis.tickInterval = getNormalizedTickInterval(axis, axis.tickInterval);
    }
    if (!this.tickAmount) {
      axis.tickInterval = axis.unsquish();
    }
    this.setTickPositions();
  }
  setTickPositions() {
    const axis = this, options = this.options, tickPositionsOption = options.tickPositions, tickPositioner = options.tickPositioner, minorTickIntervalOption = this.getMinorTickInterval(), allowEndOnTick = !this.isPanning, startOnTick = allowEndOnTick && options.startOnTick, endOnTick = allowEndOnTick && options.endOnTick;
    let tickPositions = [], tickPositionerResult;
    this.tickmarkOffset = this.categories && options.tickmarkPlacement === "between" && this.tickInterval === 1 ? 0.5 : 0;
    this.minorTickInterval = minorTickIntervalOption === "auto" && this.tickInterval ? this.tickInterval / options.minorTicksPerMajor : minorTickIntervalOption;
    this.single = this.min === this.max && defined10(this.min) && !this.tickAmount && (this.min % 1 === 0 || options.allowDecimals !== false);
    if (tickPositionsOption) {
      tickPositions = tickPositionsOption.slice();
    } else if (isNumber11(this.min) && isNumber11(this.max)) {
      if (!axis.ordinal?.positions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) {
        tickPositions = [this.min, this.max];
        error4(19, false, this.chart);
      } else if (axis.dateTime) {
        tickPositions = axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, axis.ordinal?.positions, this.closestPointRange, true);
      } else if (axis.logarithmic) {
        tickPositions = axis.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
      } else {
        const startingTickInterval = this.tickInterval;
        let adjustedTickInterval = startingTickInterval;
        while (adjustedTickInterval <= startingTickInterval * 2) {
          tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
          if (this.tickAmount && tickPositions.length > this.tickAmount) {
            this.tickInterval = getNormalizedTickInterval(this, adjustedTickInterval *= 1.1);
          } else {
            break;
          }
        }
      }
      if (tickPositions.length > this.len) {
        tickPositions = [
          tickPositions[0],
          tickPositions[tickPositions.length - 1]
        ];
        if (tickPositions[0] === tickPositions[1]) {
          tickPositions.length = 1;
        }
      }
      if (tickPositioner) {
        this.tickPositions = tickPositions;
        tickPositionerResult = tickPositioner.apply(axis, [this.min, this.max]);
        if (tickPositionerResult) {
          tickPositions = tickPositionerResult;
        }
      }
    }
    this.tickPositions = tickPositions;
    this.paddedTicks = tickPositions.slice(0);
    this.trimTicks(tickPositions, startOnTick, endOnTick);
    if (!this.isLinked && isNumber11(this.min) && isNumber11(this.max)) {
      if (this.single && tickPositions.length < 2 && !this.categories && !this.series.some((s) => s.is("heatmap") && s.options.pointPlacement === "between")) {
        this.min -= 0.5;
        this.max += 0.5;
      }
      if (!tickPositionsOption && !tickPositionerResult) {
        this.adjustTickAmount();
      }
    }
    fireEvent6(this, "afterSetTickPositions");
  }
  trimTicks(tickPositions, startOnTick, endOnTick) {
    const roundedMin = tickPositions[0], roundedMax = tickPositions[tickPositions.length - 1], minPointOffset = !this.isOrdinal && this.minPointOffset || 0;
    fireEvent6(this, "trimTicks");
    if (!this.isLinked) {
      if (startOnTick && roundedMin !== -Infinity) {
        this.min = roundedMin;
      } else {
        while (this.min - minPointOffset > tickPositions[0]) {
          tickPositions.shift();
        }
      }
      if (endOnTick) {
        this.max = roundedMax;
      } else {
        while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
          tickPositions.pop();
        }
      }
      if (tickPositions.length === 0 && defined10(roundedMin) && !this.options.tickPositions) {
        tickPositions.push((roundedMax + roundedMin) / 2);
      }
    }
  }
  alignToOthers() {
    const axis = this, chart = axis.chart, alignedAxes = [this], options = axis.options, chartOptions = chart.options.chart, alignThresholds = this.coll === "yAxis" && chartOptions.alignThresholds, thresholdAlignments = [];
    let hasOther;
    axis.thresholdAlignment = undefined;
    if ((chartOptions.alignTicks !== false && options.alignTicks || alignThresholds) && options.startOnTick !== false && options.endOnTick !== false && !axis.logarithmic) {
      const getKey = (axis2) => {
        const { horiz, options: options2 } = axis2;
        return [
          horiz ? options2.left : options2.top,
          options2.width,
          options2.height,
          options2.pane
        ].join(",");
      };
      const thisKey = getKey(this);
      chart[this.coll].forEach(function(otherAxis) {
        const { series } = otherAxis;
        if (series.length && series.some((s) => s.visible) && otherAxis !== axis && getKey(otherAxis) === thisKey) {
          hasOther = true;
          alignedAxes.push(otherAxis);
        }
      });
    }
    if (hasOther && alignThresholds) {
      alignedAxes.forEach((otherAxis) => {
        const threshAlign = otherAxis.getThresholdAlignment(axis);
        if (isNumber11(threshAlign)) {
          thresholdAlignments.push(threshAlign);
        }
      });
      const thresholdAlignment = thresholdAlignments.length > 1 ? thresholdAlignments.reduce((sum, n) => sum += n, 0) / thresholdAlignments.length : undefined;
      alignedAxes.forEach((axis2) => {
        axis2.thresholdAlignment = thresholdAlignment;
      });
    }
    return hasOther;
  }
  getThresholdAlignment(callerAxis) {
    if (!isNumber11(this.dataMin) || this !== callerAxis && this.series.some((s) => s.isDirty || s.isDirtyData)) {
      this.getSeriesExtremes();
    }
    if (isNumber11(this.threshold)) {
      let thresholdAlignment = clamp4((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
      if (this.options.reversed) {
        thresholdAlignment = 1 - thresholdAlignment;
      }
      return thresholdAlignment;
    }
  }
  getTickAmount() {
    const axis = this, options = this.options, tickPixelInterval = options.tickPixelInterval;
    let tickAmount = options.tickAmount;
    if (!defined10(options.tickInterval) && !tickAmount && this.len < tickPixelInterval && !this.isRadial && !axis.logarithmic && options.startOnTick && options.endOnTick) {
      tickAmount = 2;
    }
    if (!tickAmount && this.alignToOthers()) {
      tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
    }
    if (tickAmount < 4) {
      this.finalTickAmt = tickAmount;
      tickAmount = 5;
    }
    this.tickAmount = tickAmount;
  }
  adjustTickAmount() {
    const axis = this, { finalTickAmt, max, min, options, tickPositions, tickAmount, thresholdAlignment } = axis, currentTickAmount = tickPositions?.length, threshold = pick12(axis.threshold, axis.softThreshold ? 0 : null);
    let len, i, tickInterval = axis.tickInterval, thresholdTickIndex;
    const append = () => tickPositions.push(correctFloat3(tickPositions[tickPositions.length - 1] + tickInterval)), prepend = () => tickPositions.unshift(correctFloat3(tickPositions[0] - tickInterval));
    if (isNumber11(thresholdAlignment)) {
      thresholdTickIndex = thresholdAlignment < 0.5 ? Math.ceil(thresholdAlignment * (tickAmount - 1)) : Math.floor(thresholdAlignment * (tickAmount - 1));
      if (options.reversed) {
        thresholdTickIndex = tickAmount - 1 - thresholdTickIndex;
      }
    }
    if (axis.hasData() && isNumber11(min) && isNumber11(max)) {
      const adjustExtremes = () => {
        axis.transA *= (currentTickAmount - 1) / (tickAmount - 1);
        axis.min = options.startOnTick ? tickPositions[0] : Math.min(min, tickPositions[0]);
        axis.max = options.endOnTick ? tickPositions[tickPositions.length - 1] : Math.max(max, tickPositions[tickPositions.length - 1]);
      };
      if (isNumber11(thresholdTickIndex) && isNumber11(axis.threshold)) {
        while (tickPositions[thresholdTickIndex] !== threshold || tickPositions.length !== tickAmount || tickPositions[0] > min || tickPositions[tickPositions.length - 1] < max) {
          tickPositions.length = 0;
          tickPositions.push(axis.threshold);
          while (tickPositions.length < tickAmount) {
            if (tickPositions[thresholdTickIndex] === undefined || tickPositions[thresholdTickIndex] > axis.threshold) {
              prepend();
            } else {
              append();
            }
          }
          if (tickInterval > axis.tickInterval * 8) {
            break;
          }
          tickInterval *= 2;
        }
        adjustExtremes();
      } else if (currentTickAmount < tickAmount) {
        while (tickPositions.length < tickAmount) {
          if (tickPositions.length % 2 || min === threshold) {
            append();
          } else {
            prepend();
          }
        }
        adjustExtremes();
      }
      if (defined10(finalTickAmt)) {
        i = len = tickPositions.length;
        while (i--) {
          if (finalTickAmt === 3 && i % 2 === 1 || finalTickAmt <= 2 && i > 0 && i < len - 1) {
            tickPositions.splice(i, 1);
          }
        }
        axis.finalTickAmt = undefined;
      }
    }
  }
  setScale() {
    const axis = this, { coll, stacking } = axis;
    let isDirtyData = false, isXAxisDirty = false;
    axis.series.forEach((series) => {
      isDirtyData = isDirtyData || series.isDirtyData || series.isDirty;
      isXAxisDirty = isXAxisDirty || series.xAxis && series.xAxis.isDirty || false;
    });
    axis.setAxisSize();
    const isDirtyAxisLength = axis.len !== (axis.old && axis.old.len);
    if (isDirtyAxisLength || isDirtyData || isXAxisDirty || axis.isLinked || axis.forceRedraw || axis.userMin !== (axis.old && axis.old.userMin) || axis.userMax !== (axis.old && axis.old.userMax) || axis.alignToOthers()) {
      if (stacking && coll === "yAxis") {
        stacking.buildStacks();
      }
      axis.forceRedraw = false;
      if (!axis.userMinRange) {
        axis.minRange = undefined;
      }
      axis.getSeriesExtremes();
      axis.setTickInterval();
      if (stacking && coll === "xAxis") {
        stacking.buildStacks();
      }
      if (!axis.isDirty) {
        axis.isDirty = isDirtyAxisLength || axis.min !== axis.old?.min || axis.max !== axis.old?.max;
      }
    } else if (stacking) {
      stacking.cleanStacks();
    }
    if (isDirtyData) {
      delete axis.allExtremes;
    }
    fireEvent6(this, "afterSetScale");
  }
  setExtremes(min, max, redraw = true, animation, eventArguments) {
    this.series.forEach((serie) => {
      delete serie.kdTree;
    });
    eventArguments = extend10(eventArguments, { min, max });
    fireEvent6(this, "setExtremes", eventArguments, (e) => {
      this.userMin = e.min;
      this.userMax = e.max;
      this.eventArgs = e;
      if (redraw) {
        this.chart.redraw(animation);
      }
    });
  }
  setAxisSize() {
    const chart = this.chart, options = this.options, offsets = options.offsets || [0, 0, 0, 0], horiz = this.horiz, width = this.width = Math.round(relativeLength2(pick12(options.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth)), height = this.height = Math.round(relativeLength2(pick12(options.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight)), top = this.top = Math.round(relativeLength2(pick12(options.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop)), left = this.left = Math.round(relativeLength2(pick12(options.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft));
    this.bottom = chart.chartHeight - height - top;
    this.right = chart.chartWidth - width - left;
    this.len = Math.max(horiz ? width : height, 0);
    this.pos = horiz ? left : top;
  }
  getExtremes() {
    const axis = this, log = axis.logarithmic;
    return {
      min: log ? correctFloat3(log.lin2log(axis.min)) : axis.min,
      max: log ? correctFloat3(log.lin2log(axis.max)) : axis.max,
      dataMin: axis.dataMin,
      dataMax: axis.dataMax,
      userMin: axis.userMin,
      userMax: axis.userMax
    };
  }
  getThreshold(threshold) {
    const axis = this, log = axis.logarithmic, realMin = log ? log.lin2log(axis.min) : axis.min, realMax = log ? log.lin2log(axis.max) : axis.max;
    if (threshold === null || threshold === -Infinity) {
      threshold = realMin;
    } else if (threshold === Infinity) {
      threshold = realMax;
    } else if (realMin > threshold) {
      threshold = realMin;
    } else if (realMax < threshold) {
      threshold = realMax;
    }
    return axis.translate(threshold, 0, 1, 0, 1);
  }
  autoLabelAlign(rotation) {
    const angle = (pick12(rotation, 0) - this.side * 90 + 720) % 360, evt = { align: "center" };
    fireEvent6(this, "autoLabelAlign", evt, function(e) {
      if (angle > 15 && angle < 165) {
        e.align = "right";
      } else if (angle > 195 && angle < 345) {
        e.align = "left";
      }
    });
    return evt.align;
  }
  tickSize(prefix) {
    const options = this.options, tickWidth = pick12(options[prefix === "tick" ? "tickWidth" : "minorTickWidth"], prefix === "tick" && this.isXAxis && !this.categories ? 1 : 0);
    let tickLength = options[prefix === "tick" ? "tickLength" : "minorTickLength"], tickSize;
    if (tickWidth && tickLength) {
      if (options[prefix + "Position"] === "inside") {
        tickLength = -tickLength;
      }
      tickSize = [tickLength, tickWidth];
    }
    const e = { tickSize };
    fireEvent6(this, "afterTickSize", e);
    return e.tickSize;
  }
  labelMetrics() {
    const renderer = this.chart.renderer, ticks = this.ticks, tick = ticks[Object.keys(ticks)[0]] || {};
    return this.chart.renderer.fontMetrics(tick.label || tick.movedLabel || renderer.box);
  }
  unsquish() {
    const labelOptions = this.options.labels, padding = labelOptions.padding || 0, horiz = this.horiz, tickInterval = this.tickInterval, slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval), rotationOption = labelOptions.rotation, lineHeight = correctFloat3(this.labelMetrics().h * 0.8), range = Math.max(this.max - this.min, 0), getStep = function(spaceNeeded) {
      let step = (spaceNeeded + 2 * padding) / (slotSize || 1);
      step = step > 1 ? Math.ceil(step) : 1;
      if (step * tickInterval > range && spaceNeeded !== Infinity && slotSize !== Infinity && range) {
        step = Math.ceil(range / tickInterval);
      }
      return correctFloat3(step * tickInterval);
    };
    let newTickInterval = tickInterval, rotation, bestScore = Number.MAX_VALUE, autoRotation;
    if (horiz) {
      if (!labelOptions.staggerLines) {
        if (isNumber11(rotationOption)) {
          autoRotation = [rotationOption];
        } else if (slotSize < labelOptions.autoRotationLimit) {
          autoRotation = labelOptions.autoRotation;
        }
      }
      if (autoRotation) {
        let step, score;
        for (const rot of autoRotation) {
          if (rot === rotationOption || rot && rot >= -90 && rot <= 90) {
            step = getStep(Math.abs(lineHeight / Math.sin(deg2rad4 * rot)));
            score = step + Math.abs(rot / 360);
            if (score < bestScore) {
              bestScore = score;
              rotation = rot;
              newTickInterval = step;
            }
          }
        }
      }
    } else {
      newTickInterval = getStep(lineHeight * 0.75);
    }
    this.autoRotation = autoRotation;
    this.labelRotation = pick12(rotation, isNumber11(rotationOption) ? rotationOption : 0);
    return labelOptions.step ? tickInterval : newTickInterval;
  }
  getSlotWidth(tick) {
    const chart = this.chart, horiz = this.horiz, labelOptions = this.options.labels, slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), marginLeft = chart.margin[3];
    if (tick && isNumber11(tick.slotWidth)) {
      return tick.slotWidth;
    }
    if (horiz && labelOptions.step < 2) {
      if (labelOptions.rotation) {
        return 0;
      }
      return (this.staggerLines || 1) * this.len / slotCount;
    }
    if (!horiz) {
      const cssWidth = labelOptions.style.width;
      if (cssWidth !== undefined) {
        return parseInt(String(cssWidth), 10);
      }
      if (marginLeft) {
        return marginLeft - chart.spacing[3];
      }
    }
    return chart.chartWidth * 0.33;
  }
  renderUnsquish() {
    const chart = this.chart, renderer = chart.renderer, tickPositions = this.tickPositions, ticks = this.ticks, labelOptions = this.options.labels, labelStyleOptions = labelOptions.style, horiz = this.horiz, slotWidth = this.getSlotWidth(), innerWidth = Math.max(1, Math.round(slotWidth - (horiz ? 2 * (labelOptions.padding || 0) : labelOptions.distance || 0))), attr7 = {}, labelMetrics = this.labelMetrics(), textOverflowOption = labelStyleOptions.textOverflow;
    let commonWidth, commonTextOverflow, maxLabelLength = 0, label, i, pos;
    if (!isString6(labelOptions.rotation)) {
      attr7.rotation = labelOptions.rotation || 0;
    }
    tickPositions.forEach(function(tickPosition) {
      const tick = ticks[tickPosition];
      if (tick.movedLabel) {
        tick.replaceMovedLabel();
      }
      if (tick && tick.label && tick.label.textPxLength > maxLabelLength) {
        maxLabelLength = tick.label.textPxLength;
      }
    });
    this.maxLabelLength = maxLabelLength;
    if (this.autoRotation) {
      if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {
        attr7.rotation = this.labelRotation;
      } else {
        this.labelRotation = 0;
      }
    } else if (slotWidth) {
      commonWidth = innerWidth;
      if (!textOverflowOption) {
        commonTextOverflow = "clip";
        i = tickPositions.length;
        while (!horiz && i--) {
          pos = tickPositions[i];
          label = ticks[pos].label;
          if (label) {
            if (label.styles.textOverflow === "ellipsis") {
              label.css({ textOverflow: "clip" });
            } else if (label.textPxLength > slotWidth) {
              label.css({ width: slotWidth + "px" });
            }
            if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
              label.specificTextOverflow = "ellipsis";
            }
          }
        }
      }
    }
    if (attr7.rotation) {
      commonWidth = maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : maxLabelLength;
      if (!textOverflowOption) {
        commonTextOverflow = "ellipsis";
      }
    }
    this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);
    if (this.labelAlign) {
      attr7.align = this.labelAlign;
    }
    tickPositions.forEach(function(pos2) {
      const tick = ticks[pos2], label2 = tick && tick.label, widthOption = labelStyleOptions.width, css6 = {};
      if (label2) {
        label2.attr(attr7);
        if (tick.shortenLabel) {
          tick.shortenLabel();
        } else if (commonWidth && !widthOption && labelStyleOptions.whiteSpace !== "nowrap" && (commonWidth < label2.textPxLength || label2.element.tagName === "SPAN")) {
          css6.width = commonWidth + "px";
          if (!textOverflowOption) {
            css6.textOverflow = label2.specificTextOverflow || commonTextOverflow;
          }
          label2.css(css6);
        } else if (label2.styles.width && !css6.width && !widthOption) {
          label2.css({ width: null });
        }
        delete label2.specificTextOverflow;
        tick.rotation = attr7.rotation;
      }
    }, this);
    this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
  }
  hasData() {
    return this.series.some(function(s) {
      return s.hasData();
    }) || this.options.showEmpty && defined10(this.min) && defined10(this.max);
  }
  addTitle(display) {
    const axis = this, renderer = axis.chart.renderer, horiz = axis.horiz, opposite = axis.opposite, options = axis.options, axisTitleOptions = options.title, styledMode = axis.chart.styledMode;
    let textAlign;
    if (!axis.axisTitle) {
      textAlign = axisTitleOptions.textAlign;
      if (!textAlign) {
        textAlign = (horiz ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: opposite ? "right" : "left",
          middle: "center",
          high: opposite ? "left" : "right"
        })[axisTitleOptions.align];
      }
      axis.axisTitle = renderer.text(axisTitleOptions.text || "", 0, 0, axisTitleOptions.useHTML).attr({
        zIndex: 7,
        rotation: axisTitleOptions.rotation || 0,
        align: textAlign
      }).addClass("highcharts-axis-title");
      if (!styledMode) {
        axis.axisTitle.css(merge10(axisTitleOptions.style));
      }
      axis.axisTitle.add(axis.axisGroup);
      axis.axisTitle.isNew = true;
    }
    if (!styledMode && !axisTitleOptions.style.width && !axis.isRadial) {
      axis.axisTitle.css({
        width: axis.len + "px"
      });
    }
    axis.axisTitle[display ? "show" : "hide"](display);
  }
  generateTick(pos) {
    const axis = this, ticks = axis.ticks;
    if (!ticks[pos]) {
      ticks[pos] = new Tick_default(axis, pos);
    } else {
      ticks[pos].addLabel();
    }
  }
  createGroups() {
    const {
      axisParent,
      chart,
      coll,
      options
    } = this, renderer = chart.renderer;
    const createGroup = (name, suffix, zIndex) => renderer.g(name).attr({ zIndex }).addClass(`highcharts-${coll.toLowerCase()}${suffix} ` + (this.isRadial ? `highcharts-radial-axis${suffix} ` : "") + (options.className || "")).add(axisParent);
    if (!this.axisGroup) {
      this.gridGroup = createGroup("grid", "-grid", options.gridZIndex);
      this.axisGroup = createGroup("axis", "", options.zIndex);
      this.labelGroup = createGroup("axis-labels", "-labels", options.labels.zIndex);
    }
  }
  getOffset() {
    const axis = this, { chart, horiz, options, side, ticks, tickPositions, coll } = axis, invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side, hasData = axis.hasData(), axisTitleOptions = options.title, labelOptions = options.labels, hasCrossing = isNumber11(options.crossing), axisOffset = chart.axisOffset, clipOffset = chart.clipOffset, directionFactor = [-1, 1, 1, -1][side];
    let showAxis, titleOffset = 0, titleOffsetOption, titleMargin = 0, labelOffset = 0, labelOffsetPadded, lineHeightCorrection;
    axis.showAxis = showAxis = hasData || options.showEmpty;
    axis.staggerLines = axis.horiz && labelOptions.staggerLines || undefined;
    axis.createGroups();
    if (hasData || axis.isLinked) {
      tickPositions.forEach(function(pos) {
        axis.generateTick(pos);
      });
      axis.renderUnsquish();
      axis.reserveSpaceDefault = side === 0 || side === 2 || { 1: "left", 3: "right" }[side] === axis.labelAlign;
      if (pick12(labelOptions.reserveSpace, hasCrossing ? false : null, axis.labelAlign === "center" ? true : null, axis.reserveSpaceDefault)) {
        tickPositions.forEach(function(pos) {
          labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);
        });
      }
      if (axis.staggerLines) {
        labelOffset *= axis.staggerLines;
      }
      axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
    } else {
      objectEach10(ticks, function(tick, n) {
        tick.destroy();
        delete ticks[n];
      });
    }
    if (axisTitleOptions?.text && axisTitleOptions.enabled !== false) {
      axis.addTitle(showAxis);
      if (showAxis && !hasCrossing && axisTitleOptions.reserveSpace !== false) {
        axis.titleOffset = titleOffset = axis.axisTitle.getBBox()[horiz ? "height" : "width"];
        titleOffsetOption = axisTitleOptions.offset;
        titleMargin = defined10(titleOffsetOption) ? 0 : pick12(axisTitleOptions.margin, horiz ? 5 : 10);
      }
    }
    axis.renderLine();
    axis.offset = directionFactor * pick12(options.offset, axisOffset[side] ? axisOffset[side] + (options.margin || 0) : 0);
    axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 };
    if (side === 0) {
      lineHeightCorrection = -axis.labelMetrics().h;
    } else if (side === 2) {
      lineHeightCorrection = axis.tickRotCorr.y;
    } else {
      lineHeightCorrection = 0;
    }
    labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
    if (labelOffset) {
      labelOffsetPadded -= lineHeightCorrection;
      labelOffsetPadded += directionFactor * (horiz ? pick12(labelOptions.y, axis.tickRotCorr.y + directionFactor * labelOptions.distance) : pick12(labelOptions.x, directionFactor * labelOptions.distance));
    }
    axis.axisTitleMargin = pick12(titleOffsetOption, labelOffsetPadded);
    if (axis.getMaxLabelDimensions) {
      axis.maxLabelDimensions = axis.getMaxLabelDimensions(ticks, tickPositions);
    }
    if (coll !== "colorAxis" && clipOffset) {
      const tickSize = this.tickSize("tick");
      axisOffset[side] = Math.max(axisOffset[side], (axis.axisTitleMargin || 0) + titleOffset + directionFactor * axis.offset, labelOffsetPadded, tickPositions && tickPositions.length && tickSize ? tickSize[0] + directionFactor * axis.offset : 0);
      const clip = !axis.axisLine || options.offset ? 0 : axis.axisLine.strokeWidth() / 2;
      clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);
    }
    fireEvent6(this, "afterGetOffset");
  }
  getLinePath(lineWidth) {
    const chart = this.chart, opposite = this.opposite, offset2 = this.offset, horiz = this.horiz, lineLeft = this.left + (opposite ? this.width : 0) + offset2, lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset2;
    if (opposite) {
      lineWidth *= -1;
    }
    return chart.renderer.crispLine([
      [
        "M",
        horiz ? this.left : lineLeft,
        horiz ? lineTop : this.top
      ],
      [
        "L",
        horiz ? chart.chartWidth - this.right : lineLeft,
        horiz ? lineTop : chart.chartHeight - this.bottom
      ]
    ], lineWidth);
  }
  renderLine() {
    if (!this.axisLine) {
      this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup);
      if (!this.chart.styledMode) {
        this.axisLine.attr({
          stroke: this.options.lineColor,
          "stroke-width": this.options.lineWidth,
          zIndex: 7
        });
      }
    }
  }
  getTitlePosition(axisTitle) {
    const horiz = this.horiz, axisLeft = this.left, axisTop = this.top, axisLength = this.len, axisTitleOptions = this.options.title, margin = horiz ? axisLeft : axisTop, opposite = this.opposite, offset2 = this.offset, xOption = axisTitleOptions.x, yOption = axisTitleOptions.y, fontMetrics = this.chart.renderer.fontMetrics(axisTitle), textHeightOvershoot = axisTitle ? Math.max(axisTitle.getBBox(false, 0).height - fontMetrics.h - 1, 0) : 0, alongAxis = {
      low: margin + (horiz ? 0 : axisLength),
      middle: margin + axisLength / 2,
      high: margin + (horiz ? axisLength : 0)
    }[axisTitleOptions.align], offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * (opposite ? -1 : 1) * (this.axisTitleMargin || 0) + [
      -textHeightOvershoot,
      textHeightOvershoot,
      fontMetrics.f,
      -textHeightOvershoot
    ][this.side], titlePosition = {
      x: horiz ? alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset2 + xOption,
      y: horiz ? offAxis + yOption - (opposite ? this.height : 0) + offset2 : alongAxis + yOption
    };
    fireEvent6(this, "afterGetTitlePosition", { titlePosition });
    return titlePosition;
  }
  renderMinorTick(pos, slideIn) {
    const axis = this;
    const minorTicks = axis.minorTicks;
    if (!minorTicks[pos]) {
      minorTicks[pos] = new Tick_default(axis, pos, "minor");
    }
    if (slideIn && minorTicks[pos].isNew) {
      minorTicks[pos].render(null, true);
    }
    minorTicks[pos].render(null, false, 1);
  }
  renderTick(pos, i, slideIn) {
    const axis = this, isLinked = axis.isLinked, ticks = axis.ticks;
    if (!isLinked || pos >= axis.min && pos <= axis.max || axis.grid && axis.grid.isColumn) {
      if (!ticks[pos]) {
        ticks[pos] = new Tick_default(axis, pos);
      }
      if (slideIn && ticks[pos].isNew) {
        ticks[pos].render(i, true, -1);
      }
      ticks[pos].render(i);
    }
  }
  render() {
    const axis = this, chart = axis.chart, log = axis.logarithmic, renderer = chart.renderer, options = axis.options, isLinked = axis.isLinked, tickPositions = axis.tickPositions, axisTitle = axis.axisTitle, ticks = axis.ticks, minorTicks = axis.minorTicks, alternateBands = axis.alternateBands, stackLabelOptions = options.stackLabels, alternateGridColor = options.alternateGridColor, crossing = options.crossing, tickmarkOffset = axis.tickmarkOffset, axisLine = axis.axisLine, showAxis = axis.showAxis, animation = animObject3(renderer.globalAnimation);
    let from, to;
    axis.labelEdge.length = 0;
    axis.overlap = false;
    [ticks, minorTicks, alternateBands].forEach(function(coll) {
      objectEach10(coll, function(tick) {
        tick.isActive = false;
      });
    });
    if (isNumber11(crossing)) {
      const otherAxis = this.isXAxis ? chart.yAxis[0] : chart.xAxis[0], directionFactor = [1, -1, -1, 1][this.side];
      if (otherAxis) {
        let px = otherAxis.toPixels(crossing, true);
        if (axis.horiz) {
          px = otherAxis.len - px;
        }
        axis.offset = directionFactor * px;
      }
    }
    if (axis.hasData() || isLinked) {
      const slideInTicks = axis.chart.hasRendered && axis.old && isNumber11(axis.old.min);
      if (axis.minorTickInterval && !axis.categories) {
        axis.getMinorTickPositions().forEach(function(pos) {
          axis.renderMinorTick(pos, slideInTicks);
        });
      }
      if (tickPositions.length) {
        tickPositions.forEach(function(pos, i) {
          axis.renderTick(pos, i, slideInTicks);
        });
        if (tickmarkOffset && (axis.min === 0 || axis.single)) {
          if (!ticks[-1]) {
            ticks[-1] = new Tick_default(axis, -1, null, true);
          }
          ticks[-1].render(-1);
        }
      }
      if (alternateGridColor) {
        tickPositions.forEach(function(pos, i) {
          to = typeof tickPositions[i + 1] !== "undefined" ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;
          if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {
            if (!alternateBands[pos]) {
              alternateBands[pos] = new Globals_default.PlotLineOrBand(axis, {});
            }
            from = pos + tickmarkOffset;
            alternateBands[pos].options = {
              from: log ? log.lin2log(from) : from,
              to: log ? log.lin2log(to) : to,
              color: alternateGridColor,
              className: "highcharts-alternate-grid"
            };
            alternateBands[pos].render();
            alternateBands[pos].isActive = true;
          }
        });
      }
      if (!axis._addedPlotLB) {
        axis._addedPlotLB = true;
        (options.plotLines || []).concat(options.plotBands || []).forEach(function(plotLineOptions) {
          axis.addPlotBandOrLine(plotLineOptions);
        });
      }
    }
    [ticks, minorTicks, alternateBands].forEach(function(coll) {
      const forDestruction = [], delay = animation.duration, destroyInactiveItems = function() {
        let i = forDestruction.length;
        while (i--) {
          if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
            coll[forDestruction[i]].destroy();
            delete coll[forDestruction[i]];
          }
        }
      };
      objectEach10(coll, function(tick, pos) {
        if (!tick.isActive) {
          tick.render(pos, false, 0);
          tick.isActive = false;
          forDestruction.push(pos);
        }
      });
      syncTimeout3(destroyInactiveItems, coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay);
    });
    if (axisLine) {
      axisLine[axisLine.isPlaced ? "animate" : "attr"]({
        d: this.getLinePath(axisLine.strokeWidth())
      });
      axisLine.isPlaced = true;
      axisLine[showAxis ? "show" : "hide"](showAxis);
    }
    if (axisTitle && showAxis) {
      axisTitle[axisTitle.isNew ? "attr" : "animate"](axis.getTitlePosition(axisTitle));
      axisTitle.isNew = false;
    }
    if (stackLabelOptions && stackLabelOptions.enabled && axis.stacking) {
      axis.stacking.renderStackTotals();
    }
    axis.old = {
      len: axis.len,
      max: axis.max,
      min: axis.min,
      transA: axis.transA,
      userMax: axis.userMax,
      userMin: axis.userMin
    };
    axis.isDirty = false;
    fireEvent6(this, "afterRender");
  }
  redraw() {
    if (this.visible) {
      this.render();
      this.plotLinesAndBands.forEach(function(plotLine) {
        plotLine.render();
      });
    }
    this.series.forEach(function(series) {
      series.isDirty = true;
    });
  }
  getKeepProps() {
    return this.keepProps || Axis.keepProps;
  }
  destroy(keepEvents) {
    const axis = this, plotLinesAndBands = axis.plotLinesAndBands, eventOptions = this.eventOptions;
    fireEvent6(this, "destroy", { keepEvents });
    if (!keepEvents) {
      removeEvent4(axis);
    }
    [axis.ticks, axis.minorTicks, axis.alternateBands].forEach(function(coll) {
      destroyObjectProperties4(coll);
    });
    if (plotLinesAndBands) {
      let i = plotLinesAndBands.length;
      while (i--) {
        plotLinesAndBands[i].destroy();
      }
    }
    [
      "axisLine",
      "axisTitle",
      "axisGroup",
      "gridGroup",
      "labelGroup",
      "cross",
      "scrollbar"
    ].forEach(function(prop) {
      if (axis[prop]) {
        axis[prop] = axis[prop].destroy();
      }
    });
    for (const plotGroup in axis.plotLinesAndBandsGroups) {
      axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();
    }
    objectEach10(axis, function(val, key) {
      if (axis.getKeepProps().indexOf(key) === -1) {
        delete axis[key];
      }
    });
    this.eventOptions = eventOptions;
  }
  drawCrosshair(e, point) {
    const options = this.crosshair, snap = pick12(options && options.snap, true), chart = this.chart;
    let path, pos, categorized, graphic = this.cross, crossOptions;
    fireEvent6(this, "drawCrosshair", { e, point });
    if (!e) {
      e = this.cross && this.cross.e;
    }
    if (!options || (defined10(point) || !snap) === false) {
      this.hideCrosshair();
    } else {
      if (!snap) {
        pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
      } else if (defined10(point)) {
        pos = pick12(this.coll !== "colorAxis" ? point.crosshairPos : null, this.isXAxis ? point.plotX : this.len - point.plotY);
      }
      if (defined10(pos)) {
        crossOptions = {
          value: point && (this.isXAxis ? point.x : pick12(point.stackY, point.y)),
          translatedValue: pos
        };
        if (chart.polar) {
          extend10(crossOptions, {
            isCrosshair: true,
            chartX: e && e.chartX,
            chartY: e && e.chartY,
            point
          });
        }
        path = this.getPlotLinePath(crossOptions) || null;
      }
      if (!defined10(path)) {
        this.hideCrosshair();
        return;
      }
      categorized = this.categories && !this.isRadial;
      if (!graphic) {
        this.cross = graphic = chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (categorized ? "category " : "thin ") + (options.className || "")).attr({
          zIndex: pick12(options.zIndex, 2)
        }).add();
        if (!chart.styledMode) {
          graphic.attr({
            stroke: options.color || (categorized ? Color_default.parse("#ccd3ff").setOpacity(0.25).get() : "#cccccc"),
            "stroke-width": pick12(options.width, 1)
          }).css({
            "pointer-events": "none"
          });
          if (options.dashStyle) {
            graphic.attr({
              dashstyle: options.dashStyle
            });
          }
        }
      }
      graphic.show().attr({
        d: path
      });
      if (categorized && !options.width) {
        graphic.attr({
          "stroke-width": this.transA
        });
      }
      this.cross.e = e;
    }
    fireEvent6(this, "afterDrawCrosshair", { e, point });
  }
  hideCrosshair() {
    if (this.cross) {
      this.cross.hide();
    }
    fireEvent6(this, "afterHideCrosshair");
  }
  update(options, redraw) {
    const chart = this.chart;
    options = merge10(this.userOptions, options);
    this.destroy(true);
    this.init(chart, options);
    chart.isDirtyBox = true;
    if (pick12(redraw, true)) {
      chart.redraw();
    }
  }
  remove(redraw) {
    const chart = this.chart, coll = this.coll, axisSeries = this.series;
    let i = axisSeries.length;
    while (i--) {
      if (axisSeries[i]) {
        axisSeries[i].remove(false);
      }
    }
    erase3(chart.axes, this);
    erase3(chart[coll] || [], this);
    chart.orderItems(coll);
    this.destroy();
    chart.isDirtyBox = true;
    if (pick12(redraw, true)) {
      chart.redraw();
    }
  }
  setTitle(titleOptions, redraw) {
    this.update({ title: titleOptions }, redraw);
  }
  setCategories(categories, redraw) {
    this.update({ categories }, redraw);
  }
}
Axis.keepProps = [
  "coll",
  "extKey",
  "hcEvents",
  "len",
  "names",
  "series",
  "userMax",
  "userMin"
];
var Axis_default = Axis;

// node_modules/highcharts/es-modules/Core/Axis/DateTimeAxis.js
var { addEvent: addEvent5, getMagnitude: getMagnitude2, normalizeTickInterval: normalizeTickInterval3, timeUnits: timeUnits3 } = Utilities_default;
var DateTimeAxis;
(function(DateTimeAxis2) {
  function compose(AxisClass) {
    if (!AxisClass.keepProps.includes("dateTime")) {
      AxisClass.keepProps.push("dateTime");
      const axisProto = AxisClass.prototype;
      axisProto.getTimeTicks = getTimeTicks;
      addEvent5(AxisClass, "afterSetOptions", onAfterSetOptions);
    }
    return AxisClass;
  }
  DateTimeAxis2.compose = compose;
  function getTimeTicks() {
    return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
  }
  function onAfterSetOptions() {
    if (this.options.type !== "datetime") {
      this.dateTime = undefined;
      return;
    }
    if (!this.dateTime) {
      this.dateTime = new Additions(this);
    }
  }

  class Additions {
    constructor(axis) {
      this.axis = axis;
    }
    normalizeTimeTickInterval(tickInterval, unitsOption) {
      const units = unitsOption || [[
        "millisecond",
        [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]
      ], [
        "second",
        [1, 2, 5, 10, 15, 30]
      ], [
        "minute",
        [1, 2, 5, 10, 15, 30]
      ], [
        "hour",
        [1, 2, 3, 4, 6, 8, 12]
      ], [
        "day",
        [1, 2]
      ], [
        "week",
        [1, 2]
      ], [
        "month",
        [1, 2, 3, 4, 6]
      ], [
        "year",
        null
      ]];
      let unit = units[units.length - 1], interval = timeUnits3[unit[0]], multiples = unit[1], i;
      for (i = 0;i < units.length; i++) {
        unit = units[i];
        interval = timeUnits3[unit[0]];
        multiples = unit[1];
        if (units[i + 1]) {
          const lessThan = (interval * multiples[multiples.length - 1] + timeUnits3[units[i + 1][0]]) / 2;
          if (tickInterval <= lessThan) {
            break;
          }
        }
      }
      if (interval === timeUnits3.year && tickInterval < 5 * interval) {
        multiples = [1, 2, 5];
      }
      const count = normalizeTickInterval3(tickInterval / interval, multiples, unit[0] === "year" ? Math.max(getMagnitude2(tickInterval / interval), 1) : 1);
      return {
        unitRange: interval,
        count,
        unitName: unit[0]
      };
    }
    getXDateFormat(x, dateTimeLabelFormats) {
      const { axis } = this, time = axis.chart.time;
      return axis.closestPointRange ? time.getDateFormat(axis.closestPointRange, x, axis.options.startOfWeek, dateTimeLabelFormats) || time.resolveDTLFormat(dateTimeLabelFormats.year).main : time.resolveDTLFormat(dateTimeLabelFormats.day).main;
    }
  }
  DateTimeAxis2.Additions = Additions;
})(DateTimeAxis || (DateTimeAxis = {}));
var DateTimeAxis_default = DateTimeAxis;

// node_modules/highcharts/es-modules/Core/Axis/LogarithmicAxis.js
var { addEvent: addEvent6, normalizeTickInterval: normalizeTickInterval4, pick: pick13 } = Utilities_default;
var LogarithmicAxis;
(function(LogarithmicAxis2) {
  function compose(AxisClass) {
    if (!AxisClass.keepProps.includes("logarithmic")) {
      AxisClass.keepProps.push("logarithmic");
      addEvent6(AxisClass, "init", onInit);
      addEvent6(AxisClass, "afterInit", onAfterInit);
    }
    return AxisClass;
  }
  LogarithmicAxis2.compose = compose;
  function onInit(e) {
    const axis = this;
    const options = e.userOptions;
    let logarithmic = axis.logarithmic;
    if (options.type !== "logarithmic") {
      axis.logarithmic = undefined;
    } else {
      if (!logarithmic) {
        logarithmic = axis.logarithmic = new Additions(axis);
      }
    }
  }
  function onAfterInit() {
    const axis = this;
    const log = axis.logarithmic;
    if (log) {
      axis.lin2val = function(num) {
        return log.lin2log(num);
      };
      axis.val2lin = function(num) {
        return log.log2lin(num);
      };
    }
  }

  class Additions {
    constructor(axis) {
      this.axis = axis;
    }
    getLogTickPositions(interval, min, max, minor) {
      const log = this;
      const axis = log.axis;
      const axisLength = axis.len;
      const options = axis.options;
      let positions = [];
      if (!minor) {
        log.minorAutoInterval = undefined;
      }
      if (interval >= 0.5) {
        interval = Math.round(interval);
        positions = axis.getLinearTickPositions(interval, min, max);
      } else if (interval >= 0.08) {
        const roundedMin = Math.floor(min);
        let intermediate, i, j, len, pos, lastPos, break2;
        if (interval > 0.3) {
          intermediate = [1, 2, 4];
        } else if (interval > 0.15) {
          intermediate = [1, 2, 4, 6, 8];
        } else {
          intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        }
        for (i = roundedMin;i < max + 1 && !break2; i++) {
          len = intermediate.length;
          for (j = 0;j < len && !break2; j++) {
            pos = log.log2lin(log.lin2log(i) * intermediate[j]);
            if (pos > min && (!minor || lastPos <= max) && typeof lastPos !== "undefined") {
              positions.push(lastPos);
            }
            if (lastPos > max) {
              break2 = true;
            }
            lastPos = pos;
          }
        }
      } else {
        const realMin = log.lin2log(min), realMax = log.lin2log(max), tickIntervalOption = minor ? axis.getMinorTickInterval() : options.tickInterval, filteredTickIntervalOption = tickIntervalOption === "auto" ? null : tickIntervalOption, tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1), totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
        interval = pick13(filteredTickIntervalOption, log.minorAutoInterval, (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1));
        interval = normalizeTickInterval4(interval);
        positions = axis.getLinearTickPositions(interval, realMin, realMax).map(log.log2lin);
        if (!minor) {
          log.minorAutoInterval = interval / 5;
        }
      }
      if (!minor) {
        axis.tickInterval = interval;
      }
      return positions;
    }
    lin2log(num) {
      return Math.pow(10, num);
    }
    log2lin(num) {
      return Math.log(num) / Math.LN10;
    }
  }
  LogarithmicAxis2.Additions = Additions;
})(LogarithmicAxis || (LogarithmicAxis = {}));
var LogarithmicAxis_default = LogarithmicAxis;

// node_modules/highcharts/es-modules/Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js
var { erase: erase4, extend: extend11, isNumber: isNumber12 } = Utilities_default;
var PlotLineOrBandAxis;
(function(PlotLineOrBandAxis2) {
  let PlotLineOrBandClass;
  function addPlotBand(options) {
    return this.addPlotBandOrLine(options, "plotBands");
  }
  function addPlotBandOrLine(options, coll) {
    const userOptions = this.userOptions;
    let obj = new PlotLineOrBandClass(this, options);
    if (this.visible) {
      obj = obj.render();
    }
    if (obj) {
      if (!this._addedPlotLB) {
        this._addedPlotLB = true;
        (userOptions.plotLines || []).concat(userOptions.plotBands || []).forEach((plotLineOptions) => {
          this.addPlotBandOrLine(plotLineOptions);
        });
      }
      if (coll) {
        const updatedOptions = userOptions[coll] || [];
        updatedOptions.push(options);
        userOptions[coll] = updatedOptions;
      }
      this.plotLinesAndBands.push(obj);
    }
    return obj;
  }
  function addPlotLine(options) {
    return this.addPlotBandOrLine(options, "plotLines");
  }
  function compose(PlotLineOrBandType, AxisClass) {
    const axisProto = AxisClass.prototype;
    if (!axisProto.addPlotBand) {
      PlotLineOrBandClass = PlotLineOrBandType;
      extend11(axisProto, {
        addPlotBand,
        addPlotLine,
        addPlotBandOrLine,
        getPlotBandPath,
        removePlotBand,
        removePlotLine,
        removePlotBandOrLine
      });
    }
    return AxisClass;
  }
  PlotLineOrBandAxis2.compose = compose;
  function getPlotBandPath(from, to, options) {
    options = options || this.options;
    const toPath = this.getPlotLinePath({
      value: to,
      force: true,
      acrossPanes: options.acrossPanes
    }), result = [], horiz = this.horiz, outside = !isNumber12(this.min) || !isNumber12(this.max) || from < this.min && to < this.min || from > this.max && to > this.max, path = this.getPlotLinePath({
      value: from,
      force: true,
      acrossPanes: options.acrossPanes
    });
    let i, plus = 1, isFlat;
    if (path && toPath) {
      if (outside) {
        isFlat = path.toString() === toPath.toString();
        plus = 0;
      }
      for (i = 0;i < path.length; i += 2) {
        const pathStart = path[i], pathEnd = path[i + 1], toPathStart = toPath[i], toPathEnd = toPath[i + 1];
        if ((pathStart[0] === "M" || pathStart[0] === "L") && (pathEnd[0] === "M" || pathEnd[0] === "L") && (toPathStart[0] === "M" || toPathStart[0] === "L") && (toPathEnd[0] === "M" || toPathEnd[0] === "L")) {
          if (horiz && toPathStart[1] === pathStart[1]) {
            toPathStart[1] += plus;
            toPathEnd[1] += plus;
          } else if (!horiz && toPathStart[2] === pathStart[2]) {
            toPathStart[2] += plus;
            toPathEnd[2] += plus;
          }
          result.push(["M", pathStart[1], pathStart[2]], ["L", pathEnd[1], pathEnd[2]], ["L", toPathEnd[1], toPathEnd[2]], ["L", toPathStart[1], toPathStart[2]], ["Z"]);
        }
        result.isFlat = isFlat;
      }
    }
    return result;
  }
  function removePlotBand(id) {
    this.removePlotBandOrLine(id);
  }
  function removePlotBandOrLine(id) {
    const plotLinesAndBands = this.plotLinesAndBands, options = this.options, userOptions = this.userOptions;
    if (plotLinesAndBands) {
      let i = plotLinesAndBands.length;
      while (i--) {
        if (plotLinesAndBands[i].id === id) {
          plotLinesAndBands[i].destroy();
        }
      }
      [
        options.plotLines || [],
        userOptions.plotLines || [],
        options.plotBands || [],
        userOptions.plotBands || []
      ].forEach(function(arr) {
        i = arr.length;
        while (i--) {
          if ((arr[i] || {}).id === id) {
            erase4(arr, arr[i]);
          }
        }
      });
    }
  }
  function removePlotLine(id) {
    this.removePlotBandOrLine(id);
  }
})(PlotLineOrBandAxis || (PlotLineOrBandAxis = {}));
var PlotLineOrBandAxis_default = PlotLineOrBandAxis;

// node_modules/highcharts/es-modules/Core/Axis/PlotLineOrBand/PlotLineOrBand.js
var { arrayMax: arrayMax3, arrayMin: arrayMin3, defined: defined11, destroyObjectProperties: destroyObjectProperties5, erase: erase5, fireEvent: fireEvent7, merge: merge11, objectEach: objectEach11, pick: pick14 } = Utilities_default;

class PlotLineOrBand {
  static compose(AxisClass) {
    return PlotLineOrBandAxis_default.compose(PlotLineOrBand, AxisClass);
  }
  constructor(axis, options) {
    this.axis = axis;
    this.options = options;
    this.id = options.id;
  }
  render() {
    fireEvent7(this, "render");
    const { axis, options } = this, { horiz, logarithmic } = axis, { color: color2, events, zIndex = 0 } = options, groupAttribs = {}, renderer = axis.chart.renderer, to = options.to, from = options.from, value = options.value, borderWidth = options.borderWidth;
    let optionsLabel = options.label, { label, svgElem } = this, path = [], group;
    const isBand = defined11(from) && defined11(to), isLine = defined11(value), isNew = !svgElem, attribs = {
      class: "highcharts-plot-" + (isBand ? "band " : "line ") + (options.className || "")
    };
    let groupName = isBand ? "bands" : "lines";
    if (!axis.chart.styledMode) {
      if (isLine) {
        attribs.stroke = color2 || "#999999";
        attribs["stroke-width"] = pick14(options.width, 1);
        if (options.dashStyle) {
          attribs.dashstyle = options.dashStyle;
        }
      } else if (isBand) {
        attribs.fill = color2 || "#e6e9ff";
        if (borderWidth) {
          attribs.stroke = options.borderColor;
          attribs["stroke-width"] = borderWidth;
        }
      }
    }
    groupAttribs.zIndex = zIndex;
    groupName += "-" + zIndex;
    group = axis.plotLinesAndBandsGroups[groupName];
    if (!group) {
      axis.plotLinesAndBandsGroups[groupName] = group = renderer.g("plot-" + groupName).attr(groupAttribs).add();
    }
    if (!svgElem) {
      this.svgElem = svgElem = renderer.path().attr(attribs).add(group);
    }
    if (defined11(value)) {
      path = axis.getPlotLinePath({
        value: logarithmic?.log2lin(value) ?? value,
        lineWidth: svgElem.strokeWidth(),
        acrossPanes: options.acrossPanes
      });
    } else if (defined11(from) && defined11(to)) {
      path = axis.getPlotBandPath(logarithmic?.log2lin(from) ?? from, logarithmic?.log2lin(to) ?? to, options);
    } else {
      return;
    }
    if (!this.eventsAdded && events) {
      objectEach11(events, (event, eventType) => {
        svgElem?.on(eventType, (e) => {
          events[eventType].apply(this, [e]);
        });
      });
      this.eventsAdded = true;
    }
    if ((isNew || !svgElem.d) && path?.length) {
      svgElem.attr({ d: path });
    } else if (svgElem) {
      if (path) {
        svgElem.show();
        svgElem.animate({ d: path });
      } else if (svgElem.d) {
        svgElem.hide();
        if (label) {
          this.label = label = label.destroy();
        }
      }
    }
    if (optionsLabel && (defined11(optionsLabel.text) || defined11(optionsLabel.formatter)) && path?.length && axis.width > 0 && axis.height > 0 && !path.isFlat) {
      optionsLabel = merge11({
        align: horiz && isBand ? "center" : undefined,
        x: horiz ? !isBand && 4 : 10,
        verticalAlign: !horiz && isBand ? "middle" : undefined,
        y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
        rotation: horiz && !isBand ? 90 : 0
      }, optionsLabel);
      this.renderLabel(optionsLabel, path, isBand, zIndex);
    } else if (label) {
      label.hide();
    }
    return this;
  }
  renderLabel(optionsLabel, path, isBand, zIndex) {
    const plotLine = this, axis = plotLine.axis, renderer = axis.chart.renderer;
    let label = plotLine.label;
    if (!label) {
      plotLine.label = label = renderer.text(this.getLabelText(optionsLabel), 0, 0, optionsLabel.useHTML).attr({
        align: optionsLabel.textAlign || optionsLabel.align,
        rotation: optionsLabel.rotation,
        class: "highcharts-plot-" + (isBand ? "band" : "line") + "-label " + (optionsLabel.className || ""),
        zIndex
      });
      if (!axis.chart.styledMode) {
        label.css(merge11({
          fontSize: "0.8em",
          textOverflow: "ellipsis"
        }, optionsLabel.style));
      }
      label.add();
    }
    const xBounds = path.xBounds || [path[0][1], path[1][1], isBand ? path[2][1] : path[0][1]], yBounds = path.yBounds || [path[0][2], path[1][2], isBand ? path[2][2] : path[0][2]], x = arrayMin3(xBounds), y = arrayMin3(yBounds);
    label.align(optionsLabel, false, {
      x,
      y,
      width: arrayMax3(xBounds) - x,
      height: arrayMax3(yBounds) - y
    });
    if (!label.alignValue || label.alignValue === "left") {
      const width = optionsLabel.clip ? axis.width : axis.chart.chartWidth;
      label.css({
        width: (label.rotation === 90 ? axis.height - (label.alignAttr.y - axis.top) : width - (label.alignAttr.x - axis.left)) + "px"
      });
    }
    label.show(true);
  }
  getLabelText(optionsLabel) {
    return defined11(optionsLabel.formatter) ? optionsLabel.formatter.call(this) : optionsLabel.text;
  }
  destroy() {
    erase5(this.axis.plotLinesAndBands, this);
    delete this.axis;
    destroyObjectProperties5(this);
  }
}
var PlotLineOrBand_default = PlotLineOrBand;

// node_modules/highcharts/es-modules/Core/Tooltip.js
var { animObject: animObject4 } = AnimationUtilities_default;
var { format: format2 } = Templating_default;
var { composed: composed2, doc: doc5, isSafari } = Globals_default;
var { distribute } = RendererUtilities_default;
var { addEvent: addEvent7, clamp: clamp5, css: css6, discardElement: discardElement2, extend: extend12, fireEvent: fireEvent8, isArray: isArray7, isNumber: isNumber13, isString: isString7, merge: merge12, pick: pick15, pushUnique: pushUnique5, splat: splat5, syncTimeout: syncTimeout4 } = Utilities_default;

class Tooltip {
  constructor(chart, options, pointer) {
    this.allowShared = true;
    this.crosshairs = [];
    this.distance = 0;
    this.isHidden = true;
    this.isSticky = false;
    this.options = {};
    this.outside = false;
    this.chart = chart;
    this.init(chart, options);
    this.pointer = pointer;
  }
  bodyFormatter(items) {
    return items.map(function(item) {
      const tooltipOptions = item.series.tooltipOptions;
      return (tooltipOptions[(item.point.formatPrefix || "point") + "Formatter"] || item.point.tooltipFormatter).call(item.point, tooltipOptions[(item.point.formatPrefix || "point") + "Format"] || "");
    });
  }
  cleanSplit(force) {
    this.chart.series.forEach(function(series) {
      const tt = series && series.tt;
      if (tt) {
        if (!tt.isActive || force) {
          series.tt = tt.destroy();
        } else {
          tt.isActive = false;
        }
      }
    });
  }
  defaultFormatter(tooltip) {
    const items = this.points || splat5(this);
    let s;
    s = [tooltip.tooltipFooterHeaderFormatter(items[0])];
    s = s.concat(tooltip.bodyFormatter(items));
    s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));
    return s;
  }
  destroy() {
    if (this.label) {
      this.label = this.label.destroy();
    }
    if (this.split) {
      this.cleanSplit(true);
      if (this.tt) {
        this.tt = this.tt.destroy();
      }
    }
    if (this.renderer) {
      this.renderer = this.renderer.destroy();
      discardElement2(this.container);
    }
    Utilities_default.clearTimeout(this.hideTimer);
  }
  getAnchor(points, mouseEvent) {
    const { chart, pointer } = this, inverted = chart.inverted, plotTop = chart.plotTop, plotLeft = chart.plotLeft;
    let ret;
    points = splat5(points);
    if (points[0].series && points[0].series.yAxis && !points[0].series.yAxis.options.reversedStacks) {
      points = points.slice().reverse();
    }
    if (this.followPointer && mouseEvent) {
      if (typeof mouseEvent.chartX === "undefined") {
        mouseEvent = pointer.normalize(mouseEvent);
      }
      ret = [
        mouseEvent.chartX - plotLeft,
        mouseEvent.chartY - plotTop
      ];
    } else if (points[0].tooltipPos) {
      ret = points[0].tooltipPos;
    } else {
      let chartX = 0, chartY = 0;
      points.forEach(function(point) {
        const pos = point.pos(true);
        if (pos) {
          chartX += pos[0];
          chartY += pos[1];
        }
      });
      chartX /= points.length;
      chartY /= points.length;
      if (this.shared && points.length > 1 && mouseEvent) {
        if (inverted) {
          chartX = mouseEvent.chartX;
        } else {
          chartY = mouseEvent.chartY;
        }
      }
      ret = [chartX - plotLeft, chartY - plotTop];
    }
    return ret.map(Math.round);
  }
  getClassName(point, isSplit, isHeader) {
    const options = this.options, series = point.series, seriesOptions = series.options;
    return [
      options.className,
      "highcharts-label",
      isHeader && "highcharts-tooltip-header",
      isSplit ? "highcharts-tooltip-box" : "highcharts-tooltip",
      !isHeader && "highcharts-color-" + pick15(point.colorIndex, series.colorIndex),
      seriesOptions && seriesOptions.className
    ].filter(isString7).join(" ");
  }
  getLabel() {
    const tooltip = this, styledMode = this.chart.styledMode, options = this.options, doSplit = this.split && this.allowShared;
    let container = this.container, renderer = this.chart.renderer;
    if (this.label) {
      const wasSplit = !this.label.hasClass("highcharts-label");
      if (!doSplit && wasSplit || doSplit && !wasSplit) {
        this.destroy();
      }
    }
    if (!this.label) {
      if (this.outside) {
        const chartStyle = this.chart.options.chart.style, Renderer = RendererRegistry_default.getRendererType();
        this.container = container = Globals_default.doc.createElement("div");
        container.className = "highcharts-tooltip-container";
        css6(container, {
          position: "absolute",
          top: "1px",
          pointerEvents: "none",
          zIndex: Math.max(this.options.style.zIndex || 0, (chartStyle && chartStyle.zIndex || 0) + 3)
        });
        this.renderer = renderer = new Renderer(container, 0, 0, chartStyle, undefined, undefined, renderer.styledMode);
      }
      if (doSplit) {
        this.label = renderer.g("tooltip");
      } else {
        this.label = renderer.label("", 0, 0, options.shape, undefined, undefined, options.useHTML, undefined, "tooltip").attr({
          padding: options.padding,
          r: options.borderRadius
        });
        if (!styledMode) {
          this.label.attr({
            fill: options.backgroundColor,
            "stroke-width": options.borderWidth || 0
          }).css(options.style).css({
            pointerEvents: options.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none")
          });
        }
      }
      if (tooltip.outside) {
        const label = this.label;
        [label.xSetter, label.ySetter].forEach((setter, i) => {
          label[i ? "ySetter" : "xSetter"] = (value) => {
            setter.call(label, tooltip.distance);
            label[i ? "y" : "x"] = value;
            if (container) {
              container.style[i ? "top" : "left"] = `${value}px`;
            }
          };
        });
      }
      this.label.attr({ zIndex: 8 }).shadow(options.shadow).add();
    }
    if (container && !container.parentElement) {
      Globals_default.doc.body.appendChild(container);
    }
    return this.label;
  }
  getPlayingField() {
    const { body, documentElement } = doc5, { chart, distance, outside } = this;
    return {
      width: outside ? Math.max(body.scrollWidth, documentElement.scrollWidth, body.offsetWidth, documentElement.offsetWidth, documentElement.clientWidth) - 2 * distance : chart.chartWidth,
      height: outside ? Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, documentElement.clientHeight) : chart.chartHeight
    };
  }
  getPosition(boxWidth, boxHeight, point) {
    const { distance, chart, outside, pointer } = this, { inverted, plotLeft, plotTop, polar } = chart, { plotX = 0, plotY = 0 } = point, ret = {}, h = inverted && point.h || 0, { height: outerHeight, width: outerWidth } = this.getPlayingField(), chartPosition = pointer.getChartPosition(), scaleX = (val) => val * chartPosition.scaleX, scaleY = (val) => val * chartPosition.scaleY, buildDimensionArray = (dim) => {
      const isX = dim === "x";
      return [
        dim,
        isX ? outerWidth : outerHeight,
        isX ? boxWidth : boxHeight
      ].concat(outside ? [
        isX ? scaleX(boxWidth) : scaleY(boxHeight),
        isX ? chartPosition.left - distance + scaleX(plotX + plotLeft) : chartPosition.top - distance + scaleY(plotY + plotTop),
        0,
        isX ? outerWidth : outerHeight
      ] : [
        isX ? boxWidth : boxHeight,
        isX ? plotX + plotLeft : plotY + plotTop,
        isX ? plotLeft : plotTop,
        isX ? plotLeft + chart.plotWidth : plotTop + chart.plotHeight
      ]);
    };
    let first = buildDimensionArray("y"), second = buildDimensionArray("x"), swapped;
    let flipped = !!point.negative;
    if (!polar && chart.hoverSeries?.yAxis?.reversed) {
      flipped = !flipped;
    }
    const preferFarSide = !this.followPointer && pick15(point.ttBelow, polar ? false : !inverted === flipped), firstDimension = function(dim, outerSize, innerSize, scaledInnerSize, point2, min, max) {
      const scaledDist = outside ? dim === "y" ? scaleY(distance) : scaleX(distance) : distance, scaleDiff = (innerSize - scaledInnerSize) / 2, roomLeft = scaledInnerSize < point2 - distance, roomRight = point2 + distance + scaledInnerSize < outerSize, alignedLeft = point2 - scaledDist - innerSize + scaleDiff, alignedRight = point2 + scaledDist - scaleDiff;
      if (preferFarSide && roomRight) {
        ret[dim] = alignedRight;
      } else if (!preferFarSide && roomLeft) {
        ret[dim] = alignedLeft;
      } else if (roomLeft) {
        ret[dim] = Math.min(max - scaledInnerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);
      } else if (roomRight) {
        ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);
      } else {
        return false;
      }
    }, secondDimension = function(dim, outerSize, innerSize, scaledInnerSize, point2) {
      if (point2 < distance || point2 > outerSize - distance) {
        return false;
      }
      if (point2 < innerSize / 2) {
        ret[dim] = 1;
      } else if (point2 > outerSize - scaledInnerSize / 2) {
        ret[dim] = outerSize - scaledInnerSize - 2;
      } else {
        ret[dim] = point2 - innerSize / 2;
      }
    }, swap = function(count) {
      [first, second] = [second, first];
      swapped = count;
    }, run = () => {
      if (firstDimension.apply(0, first) !== false) {
        if (secondDimension.apply(0, second) === false && !swapped) {
          swap(true);
          run();
        }
      } else if (!swapped) {
        swap(true);
        run();
      } else {
        ret.x = ret.y = 0;
      }
    };
    if (inverted && !polar || this.len > 1) {
      swap();
    }
    run();
    return ret;
  }
  hide(delay) {
    const tooltip = this;
    Utilities_default.clearTimeout(this.hideTimer);
    delay = pick15(delay, this.options.hideDelay);
    if (!this.isHidden) {
      this.hideTimer = syncTimeout4(function() {
        const label = tooltip.getLabel();
        tooltip.getLabel().animate({
          opacity: 0
        }, {
          duration: delay ? 150 : delay,
          complete: () => {
            label.hide();
            if (tooltip.container) {
              tooltip.container.remove();
            }
          }
        });
        tooltip.isHidden = true;
      }, delay);
    }
  }
  init(chart, options) {
    this.chart = chart;
    this.options = options;
    this.crosshairs = [];
    this.isHidden = true;
    this.split = options.split && !chart.inverted && !chart.polar;
    this.shared = options.shared || this.split;
    this.outside = pick15(options.outside, Boolean(chart.scrollablePixelsX || chart.scrollablePixelsY));
  }
  shouldStickOnContact(pointerEvent) {
    return !!(!this.followPointer && this.options.stickOnContact && (!pointerEvent || this.pointer.inClass(pointerEvent.target, "highcharts-tooltip")));
  }
  move(x, y, anchorX, anchorY) {
    const tooltip = this, animation = animObject4(!tooltip.isHidden && tooltip.options.animation), skipAnchor = tooltip.followPointer || (tooltip.len || 0) > 1, attr7 = { x, y };
    if (!skipAnchor) {
      attr7.anchorX = anchorX;
      attr7.anchorY = anchorY;
    }
    animation.step = () => tooltip.drawTracker();
    tooltip.getLabel().animate(attr7, animation);
  }
  refresh(pointOrPoints, mouseEvent) {
    const tooltip = this, { chart, options, pointer, shared } = this, points = splat5(pointOrPoints), point = points[0], pointConfig = [], formatString = options.format, formatter = options.formatter || tooltip.defaultFormatter, styledMode = chart.styledMode;
    let formatterContext = {};
    if (!options.enabled || !point.series) {
      return;
    }
    Utilities_default.clearTimeout(this.hideTimer);
    tooltip.allowShared = !(!isArray7(pointOrPoints) && pointOrPoints.series && pointOrPoints.series.noSharedTooltip);
    tooltip.followPointer = !tooltip.split && point.series.tooltipOptions.followPointer;
    const anchor = tooltip.getAnchor(pointOrPoints, mouseEvent), x = anchor[0], y = anchor[1];
    if (shared && tooltip.allowShared) {
      pointer.applyInactiveState(points);
      points.forEach(function(item) {
        item.setState("hover");
        pointConfig.push(item.getLabelConfig());
      });
      formatterContext = point.getLabelConfig();
      formatterContext.points = pointConfig;
    } else {
      formatterContext = point.getLabelConfig();
    }
    this.len = pointConfig.length;
    const text = isString7(formatString) ? format2(formatString, formatterContext, chart) : formatter.call(formatterContext, tooltip);
    const currentSeries = point.series;
    this.distance = pick15(currentSeries.tooltipOptions.distance, 16);
    if (text === false) {
      this.hide();
    } else {
      if (tooltip.split && tooltip.allowShared) {
        this.renderSplit(text, points);
      } else {
        let checkX = x;
        let checkY = y;
        if (mouseEvent && pointer.isDirectTouch) {
          checkX = mouseEvent.chartX - chart.plotLeft;
          checkY = mouseEvent.chartY - chart.plotTop;
        }
        if (chart.polar || currentSeries.options.clip === false || points.some((p) => pointer.isDirectTouch || p.series.shouldShowTooltip(checkX, checkY))) {
          const label = tooltip.getLabel();
          if (!options.style.width || styledMode) {
            label.css({
              width: (this.outside ? this.getPlayingField() : chart.spacingBox).width + "px"
            });
          }
          label.attr({
            class: tooltip.getClassName(point),
            text: text && text.join ? text.join("") : text
          });
          if (!styledMode) {
            label.attr({
              stroke: options.borderColor || point.color || currentSeries.color || "#666666"
            });
          }
          tooltip.updatePosition({
            plotX: x,
            plotY: y,
            negative: point.negative,
            ttBelow: point.ttBelow,
            h: anchor[2] || 0
          });
        } else {
          tooltip.hide();
          return;
        }
      }
      if (tooltip.isHidden && tooltip.label) {
        tooltip.label.attr({
          opacity: 1
        }).show();
      }
      tooltip.isHidden = false;
    }
    fireEvent8(this, "refresh");
  }
  renderSplit(labels, points) {
    const tooltip = this;
    const { chart, chart: { chartWidth, chartHeight, plotHeight, plotLeft, plotTop, scrollablePixelsY = 0, scrollablePixelsX, styledMode }, distance, options, options: { positioner }, pointer } = tooltip;
    const { scrollLeft = 0, scrollTop = 0 } = chart.scrollablePlotArea?.scrollingContainer || {};
    const bounds = tooltip.outside && typeof scrollablePixelsX !== "number" ? doc5.documentElement.getBoundingClientRect() : {
      left: scrollLeft,
      right: scrollLeft + chartWidth,
      top: scrollTop,
      bottom: scrollTop + chartHeight
    };
    const tooltipLabel = tooltip.getLabel();
    const ren = this.renderer || chart.renderer;
    const headerTop = Boolean(chart.xAxis[0] && chart.xAxis[0].opposite);
    const { left: chartLeft, top: chartTop } = pointer.getChartPosition();
    let distributionBoxTop = plotTop + scrollTop;
    let headerHeight = 0;
    let adjustedPlotHeight = plotHeight - scrollablePixelsY;
    function getAnchor(point) {
      const { isHeader, plotX = 0, plotY = 0, series } = point;
      let anchorX;
      let anchorY;
      if (isHeader) {
        anchorX = Math.max(plotLeft + plotX, plotLeft);
        anchorY = plotTop + plotHeight / 2;
      } else {
        const { xAxis: xAxis2, yAxis: yAxis2 } = series;
        anchorX = xAxis2.pos + clamp5(plotX, -distance, xAxis2.len + distance);
        if (series.shouldShowTooltip(0, yAxis2.pos - plotTop + plotY, {
          ignoreX: true
        })) {
          anchorY = yAxis2.pos + plotY;
        }
      }
      anchorX = clamp5(anchorX, bounds.left - distance, bounds.right + distance);
      return { anchorX, anchorY };
    }
    function defaultPositioner(anchorX, anchorY, isHeader, boxWidth, alignedLeft = true) {
      let y;
      let x;
      if (isHeader) {
        y = headerTop ? 0 : adjustedPlotHeight;
        x = clamp5(anchorX - boxWidth / 2, bounds.left, bounds.right - boxWidth - (tooltip.outside ? chartLeft : 0));
      } else {
        y = anchorY - distributionBoxTop;
        x = alignedLeft ? anchorX - boxWidth - distance : anchorX + distance;
        x = clamp5(x, alignedLeft ? x : bounds.left, bounds.right);
      }
      return { x, y };
    }
    function updatePartialTooltip(partialTooltip, point, str) {
      let tt = partialTooltip;
      const { isHeader, series } = point;
      if (!tt) {
        const attribs = {
          padding: options.padding,
          r: options.borderRadius
        };
        if (!styledMode) {
          attribs.fill = options.backgroundColor;
          attribs["stroke-width"] = options.borderWidth ?? 1;
        }
        tt = ren.label("", 0, 0, options[isHeader ? "headerShape" : "shape"], undefined, undefined, options.useHTML).addClass(tooltip.getClassName(point, true, isHeader)).attr(attribs).add(tooltipLabel);
      }
      tt.isActive = true;
      tt.attr({
        text: str
      });
      if (!styledMode) {
        tt.css(options.style).attr({
          stroke: options.borderColor || point.color || series.color || "#333333"
        });
      }
      return tt;
    }
    if (isString7(labels)) {
      labels = [false, labels];
    }
    let boxes = labels.slice(0, points.length + 1).reduce(function(boxes2, str, i) {
      if (str !== false && str !== "") {
        const point = points[i - 1] || {
          isHeader: true,
          plotX: points[0].plotX,
          plotY: plotHeight,
          series: {}
        };
        const isHeader = point.isHeader;
        const owner = isHeader ? tooltip : point.series;
        const tt = owner.tt = updatePartialTooltip(owner.tt, point, str.toString());
        const bBox = tt.getBBox();
        const boxWidth = bBox.width + tt.strokeWidth();
        if (isHeader) {
          headerHeight = bBox.height;
          adjustedPlotHeight += headerHeight;
          if (headerTop) {
            distributionBoxTop -= headerHeight;
          }
        }
        const { anchorX, anchorY } = getAnchor(point);
        if (typeof anchorY === "number") {
          const size = bBox.height + 1;
          const boxPosition = positioner ? positioner.call(tooltip, boxWidth, size, point) : defaultPositioner(anchorX, anchorY, isHeader, boxWidth);
          boxes2.push({
            align: positioner ? 0 : undefined,
            anchorX,
            anchorY,
            boxWidth,
            point,
            rank: pick15(boxPosition.rank, isHeader ? 1 : 0),
            size,
            target: boxPosition.y,
            tt,
            x: boxPosition.x
          });
        } else {
          tt.isActive = false;
        }
      }
      return boxes2;
    }, []);
    if (!positioner && boxes.some((box) => {
      const { outside: outside2 } = tooltip;
      const boxStart = (outside2 ? chartLeft : 0) + box.anchorX;
      if (boxStart < bounds.left && boxStart + box.boxWidth < bounds.right) {
        return true;
      }
      return boxStart < chartLeft - bounds.left + box.boxWidth && bounds.right - boxStart > boxStart;
    })) {
      boxes = boxes.map((box) => {
        const { x, y } = defaultPositioner(box.anchorX, box.anchorY, box.point.isHeader, box.boxWidth, false);
        return extend12(box, {
          target: y,
          x
        });
      });
    }
    tooltip.cleanSplit();
    distribute(boxes, adjustedPlotHeight);
    const boxExtremes = {
      left: chartLeft,
      right: chartLeft
    };
    boxes.forEach(function(box) {
      const { x, boxWidth, isHeader } = box;
      if (!isHeader) {
        if (tooltip.outside && chartLeft + x < boxExtremes.left) {
          boxExtremes.left = chartLeft + x;
        }
        if (!isHeader && tooltip.outside && boxExtremes.left + boxWidth > boxExtremes.right) {
          boxExtremes.right = chartLeft + x;
        }
      }
    });
    boxes.forEach(function(box) {
      const { x, anchorX, anchorY, pos, point: { isHeader } } = box;
      const attributes = {
        visibility: typeof pos === "undefined" ? "hidden" : "inherit",
        x,
        y: (pos || 0) + distributionBoxTop,
        anchorX,
        anchorY
      };
      if (tooltip.outside && x < anchorX) {
        const offset2 = chartLeft - boxExtremes.left;
        if (offset2 > 0) {
          if (!isHeader) {
            attributes.x = x + offset2;
            attributes.anchorX = anchorX + offset2;
          }
          if (isHeader) {
            attributes.x = (boxExtremes.right - boxExtremes.left) / 2;
            attributes.anchorX = anchorX + offset2;
          }
        }
      }
      box.tt.attr(attributes);
    });
    const { container, outside, renderer } = tooltip;
    if (outside && container && renderer) {
      const { width, height, x, y } = tooltipLabel.getBBox();
      renderer.setSize(width + x, height + y, false);
      container.style.left = boxExtremes.left + "px";
      container.style.top = chartTop + "px";
    }
    if (isSafari) {
      tooltipLabel.attr({
        opacity: tooltipLabel.opacity === 1 ? 0.999 : 1
      });
    }
  }
  drawTracker() {
    const tooltip = this;
    if (!this.shouldStickOnContact()) {
      if (tooltip.tracker) {
        tooltip.tracker = tooltip.tracker.destroy();
      }
      return;
    }
    const chart = tooltip.chart;
    const label = tooltip.label;
    const points = tooltip.shared ? chart.hoverPoints : chart.hoverPoint;
    if (!label || !points) {
      return;
    }
    const box = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    const anchorPos = this.getAnchor(points);
    const labelBBox = label.getBBox();
    anchorPos[0] += chart.plotLeft - (label.translateX || 0);
    anchorPos[1] += chart.plotTop - (label.translateY || 0);
    box.x = Math.min(0, anchorPos[0]);
    box.y = Math.min(0, anchorPos[1]);
    box.width = anchorPos[0] < 0 ? Math.max(Math.abs(anchorPos[0]), labelBBox.width - anchorPos[0]) : Math.max(Math.abs(anchorPos[0]), labelBBox.width);
    box.height = anchorPos[1] < 0 ? Math.max(Math.abs(anchorPos[1]), labelBBox.height - Math.abs(anchorPos[1])) : Math.max(Math.abs(anchorPos[1]), labelBBox.height);
    if (tooltip.tracker) {
      tooltip.tracker.attr(box);
    } else {
      tooltip.tracker = label.renderer.rect(box).addClass("highcharts-tracker").add(label);
      if (!chart.styledMode) {
        tooltip.tracker.attr({
          fill: "rgba(0,0,0,0)"
        });
      }
    }
  }
  styledModeFormat(formatString) {
    return formatString.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
  }
  tooltipFooterHeaderFormatter(labelConfig, isFooter) {
    const series = labelConfig.series, tooltipOptions = series.tooltipOptions, xAxis2 = series.xAxis, dateTime = xAxis2 && xAxis2.dateTime, e = {
      isFooter,
      labelConfig
    };
    let xDateFormat = tooltipOptions.xDateFormat, formatString = tooltipOptions[isFooter ? "footerFormat" : "headerFormat"];
    fireEvent8(this, "headerFormatter", e, function(e2) {
      if (dateTime && !xDateFormat && isNumber13(labelConfig.key)) {
        xDateFormat = dateTime.getXDateFormat(labelConfig.key, tooltipOptions.dateTimeLabelFormats);
      }
      if (dateTime && xDateFormat) {
        (labelConfig.point && labelConfig.point.tooltipDateKeys || ["key"]).forEach(function(key) {
          formatString = formatString.replace("{point." + key + "}", "{point." + key + ":" + xDateFormat + "}");
        });
      }
      if (series.chart.styledMode) {
        formatString = this.styledModeFormat(formatString);
      }
      e2.text = format2(formatString, {
        point: labelConfig,
        series
      }, this.chart);
    });
    return e.text;
  }
  update(options) {
    this.destroy();
    this.init(this.chart, merge12(true, this.options, options));
  }
  updatePosition(point) {
    const { chart, container, distance, options, pointer, renderer } = this, { height = 0, width = 0 } = this.getLabel(), { left, top, scaleX, scaleY } = pointer.getChartPosition(), pos = (options.positioner || this.getPosition).call(this, width, height, point);
    let anchorX = (point.plotX || 0) + chart.plotLeft, anchorY = (point.plotY || 0) + chart.plotTop, pad3;
    if (renderer && container) {
      if (options.positioner) {
        pos.x += left - distance;
        pos.y += top - distance;
      }
      pad3 = (options.borderWidth || 0) + 2 * distance + 2;
      renderer.setSize(width + pad3, height + pad3, false);
      if (scaleX !== 1 || scaleY !== 1) {
        css6(container, {
          transform: `scale(${scaleX}, ${scaleY})`
        });
        anchorX *= scaleX;
        anchorY *= scaleY;
      }
      anchorX += left - pos.x;
      anchorY += top - pos.y;
    }
    this.move(Math.round(pos.x), Math.round(pos.y || 0), anchorX, anchorY);
  }
}
(function(Tooltip2) {
  function compose(PointerClass) {
    if (pushUnique5(composed2, "Core.Tooltip")) {
      addEvent7(PointerClass, "afterInit", function() {
        const chart = this.chart;
        if (chart.options.tooltip) {
          chart.tooltip = new Tooltip2(chart, chart.options.tooltip, this);
        }
      });
    }
  }
  Tooltip2.compose = compose;
})(Tooltip || (Tooltip = {}));
var Tooltip_default = Tooltip;

// node_modules/highcharts/es-modules/Core/Series/Point.js
var { animObject: animObject5 } = AnimationUtilities_default;
var { defaultOptions: defaultOptions5 } = Defaults_default;
var { format: format3 } = Templating_default;
var { addEvent: addEvent8, crisp: crisp4, erase: erase6, extend: extend13, fireEvent: fireEvent9, getNestedProperty: getNestedProperty3, isArray: isArray8, isFunction: isFunction5, isNumber: isNumber14, isObject: isObject7, merge: merge13, pick: pick16, syncTimeout: syncTimeout5, removeEvent: removeEvent5, uniqueKey: uniqueKey4 } = Utilities_default;

class Point {
  animateBeforeDestroy() {
    const point = this, animateParams = { x: point.startXPos, opacity: 0 }, graphicalProps = point.getGraphicalProps();
    graphicalProps.singular.forEach(function(prop) {
      const isDataLabel = prop === "dataLabel";
      point[prop] = point[prop].animate(isDataLabel ? {
        x: point[prop].startXPos,
        y: point[prop].startYPos,
        opacity: 0
      } : animateParams);
    });
    graphicalProps.plural.forEach(function(plural) {
      point[plural].forEach(function(item) {
        if (item.element) {
          item.animate(extend13({ x: point.startXPos }, item.startYPos ? {
            x: item.startXPos,
            y: item.startYPos
          } : {}));
        }
      });
    });
  }
  applyOptions(options, x) {
    const point = this, series = point.series, pointValKey = series.options.pointValKey || series.pointValKey;
    options = Point.prototype.optionsToObject.call(this, options);
    extend13(point, options);
    point.options = point.options ? extend13(point.options, options) : options;
    if (options.group) {
      delete point.group;
    }
    if (options.dataLabels) {
      delete point.dataLabels;
    }
    if (pointValKey) {
      point.y = Point.prototype.getNestedProperty.call(point, pointValKey);
    }
    if (point.selected) {
      point.state = "select";
    }
    if ("name" in point && typeof x === "undefined" && series.xAxis && series.xAxis.hasNames) {
      point.x = series.xAxis.nameToX(point);
    }
    if (typeof point.x === "undefined" && series) {
      point.x = x ?? series.autoIncrement();
    } else if (isNumber14(options.x) && series.options.relativeXValue) {
      point.x = series.autoIncrement(options.x);
    }
    point.isNull = this.isValid && !this.isValid();
    point.formatPrefix = point.isNull ? "null" : "point";
    return point;
  }
  destroy() {
    if (!this.destroyed) {
      const point = this, series = point.series, chart = series.chart, dataSorting = series.options.dataSorting, hoverPoints = chart.hoverPoints, globalAnimation = point.series.chart.renderer.globalAnimation, animation = animObject5(globalAnimation);
      const destroyPoint = () => {
        if (point.graphic || point.graphics || point.dataLabel || point.dataLabels) {
          removeEvent5(point);
          point.destroyElements();
        }
        for (const prop in point) {
          delete point[prop];
        }
      };
      if (point.legendItem) {
        chart.legend.destroyItem(point);
      }
      if (hoverPoints) {
        point.setState();
        erase6(hoverPoints, point);
        if (!hoverPoints.length) {
          chart.hoverPoints = null;
        }
      }
      if (point === chart.hoverPoint) {
        point.onMouseOut();
      }
      if (!dataSorting || !dataSorting.enabled) {
        destroyPoint();
      } else {
        this.animateBeforeDestroy();
        syncTimeout5(destroyPoint, animation.duration);
      }
      chart.pointCount--;
    }
    this.destroyed = true;
  }
  destroyElements(kinds) {
    const point = this, props = point.getGraphicalProps(kinds);
    props.singular.forEach(function(prop) {
      point[prop] = point[prop].destroy();
    });
    props.plural.forEach(function(plural) {
      point[plural].forEach(function(item) {
        if (item && item.element) {
          item.destroy();
        }
      });
      delete point[plural];
    });
  }
  firePointEvent(eventType, eventArgs, defaultFunction) {
    const point = this, series = this.series, seriesOptions = series.options;
    point.manageEvent(eventType);
    if (eventType === "click" && seriesOptions.allowPointSelect) {
      defaultFunction = function(event) {
        if (!point.destroyed && point.select) {
          point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
        }
      };
    }
    fireEvent9(point, eventType, eventArgs, defaultFunction);
  }
  getClassName() {
    const point = this;
    return "highcharts-point" + (point.selected ? " highcharts-point-select" : "") + (point.negative ? " highcharts-negative" : "") + (point.isNull ? " highcharts-null-point" : "") + (typeof point.colorIndex !== "undefined" ? " highcharts-color-" + point.colorIndex : "") + (point.options.className ? " " + point.options.className : "") + (point.zone && point.zone.className ? " " + point.zone.className.replace("highcharts-negative", "") : "");
  }
  getGraphicalProps(kinds) {
    const point = this, props = [], graphicalProps = { singular: [], plural: [] };
    let prop, i;
    kinds = kinds || { graphic: 1, dataLabel: 1 };
    if (kinds.graphic) {
      props.push("graphic", "connector");
    }
    if (kinds.dataLabel) {
      props.push("dataLabel", "dataLabelPath", "dataLabelUpper");
    }
    i = props.length;
    while (i--) {
      prop = props[i];
      if (point[prop]) {
        graphicalProps.singular.push(prop);
      }
    }
    [
      "graphic",
      "dataLabel"
    ].forEach(function(prop2) {
      const plural = prop2 + "s";
      if (kinds[prop2] && point[plural]) {
        graphicalProps.plural.push(plural);
      }
    });
    return graphicalProps;
  }
  getLabelConfig() {
    return {
      x: this.category,
      y: this.y,
      color: this.color,
      colorIndex: this.colorIndex,
      key: this.name || this.category,
      series: this.series,
      point: this,
      percentage: this.percentage,
      total: this.total || this.stackTotal
    };
  }
  getNestedProperty(key) {
    if (!key) {
      return;
    }
    if (key.indexOf("custom.") === 0) {
      return getNestedProperty3(key, this.options);
    }
    return this[key];
  }
  getZone() {
    const series = this.series, zones = series.zones, zoneAxis = series.zoneAxis || "y";
    let zone, i = 0;
    zone = zones[i];
    while (this[zoneAxis] >= zone.value) {
      zone = zones[++i];
    }
    if (!this.nonZonedColor) {
      this.nonZonedColor = this.color;
    }
    if (zone && zone.color && !this.options.color) {
      this.color = zone.color;
    } else {
      this.color = this.nonZonedColor;
    }
    return zone;
  }
  hasNewShapeType() {
    const point = this;
    const oldShapeType = point.graphic && (point.graphic.symbolName || point.graphic.element.nodeName);
    return oldShapeType !== this.shapeType;
  }
  constructor(series, options, x) {
    this.formatPrefix = "point";
    this.visible = true;
    this.series = series;
    this.applyOptions(options, x);
    this.id ?? (this.id = uniqueKey4());
    this.resolveColor();
    series.chart.pointCount++;
    fireEvent9(this, "afterInit");
  }
  isValid() {
    return (isNumber14(this.x) || this.x instanceof Date) && isNumber14(this.y);
  }
  optionsToObject(options) {
    const series = this.series, keys2 = series.options.keys, pointArrayMap = keys2 || series.pointArrayMap || ["y"], valueCount = pointArrayMap.length;
    let ret = {}, firstItemType, i = 0, j = 0;
    if (isNumber14(options) || options === null) {
      ret[pointArrayMap[0]] = options;
    } else if (isArray8(options)) {
      if (!keys2 && options.length > valueCount) {
        firstItemType = typeof options[0];
        if (firstItemType === "string") {
          ret.name = options[0];
        } else if (firstItemType === "number") {
          ret.x = options[0];
        }
        i++;
      }
      while (j < valueCount) {
        if (!keys2 || typeof options[i] !== "undefined") {
          if (pointArrayMap[j].indexOf(".") > 0) {
            Point.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);
          } else {
            ret[pointArrayMap[j]] = options[i];
          }
        }
        i++;
        j++;
      }
    } else if (typeof options === "object") {
      ret = options;
      if (options.dataLabels) {
        series.hasDataLabels = () => true;
      }
      if (options.marker) {
        series._hasPointMarkers = true;
      }
    }
    return ret;
  }
  pos(chartCoordinates, plotY = this.plotY) {
    if (!this.destroyed) {
      const { plotX, series } = this, { chart, xAxis: xAxis2, yAxis: yAxis2 } = series;
      let posX = 0, posY = 0;
      if (isNumber14(plotX) && isNumber14(plotY)) {
        if (chartCoordinates) {
          posX = xAxis2 ? xAxis2.pos : chart.plotLeft;
          posY = yAxis2 ? yAxis2.pos : chart.plotTop;
        }
        return chart.inverted && xAxis2 && yAxis2 ? [yAxis2.len - plotY + posY, xAxis2.len - plotX + posX] : [plotX + posX, plotY + posY];
      }
    }
  }
  resolveColor() {
    const series = this.series, optionsChart = series.chart.options.chart, styledMode = series.chart.styledMode;
    let color2, colors, colorCount = optionsChart.colorCount, colorIndex;
    delete this.nonZonedColor;
    if (series.options.colorByPoint) {
      if (!styledMode) {
        colors = series.options.colors || series.chart.options.colors;
        color2 = colors[series.colorCounter];
        colorCount = colors.length;
      }
      colorIndex = series.colorCounter;
      series.colorCounter++;
      if (series.colorCounter === colorCount) {
        series.colorCounter = 0;
      }
    } else {
      if (!styledMode) {
        color2 = series.color;
      }
      colorIndex = series.colorIndex;
    }
    this.colorIndex = pick16(this.options.colorIndex, colorIndex);
    this.color = pick16(this.options.color, color2);
  }
  setNestedProperty(object, value, key) {
    const nestedKeys = key.split(".");
    nestedKeys.reduce(function(result, key2, i, arr) {
      const isLastKey = arr.length - 1 === i;
      result[key2] = isLastKey ? value : isObject7(result[key2], true) ? result[key2] : {};
      return result[key2];
    }, object);
    return object;
  }
  shouldDraw() {
    return !this.isNull;
  }
  tooltipFormatter(pointFormat) {
    const series = this.series, seriesTooltipOptions = series.tooltipOptions, valueDecimals = pick16(seriesTooltipOptions.valueDecimals, ""), valuePrefix = seriesTooltipOptions.valuePrefix || "", valueSuffix = seriesTooltipOptions.valueSuffix || "";
    if (series.chart.styledMode) {
      pointFormat = series.chart.tooltip.styledModeFormat(pointFormat);
    }
    (series.pointArrayMap || ["y"]).forEach(function(key) {
      key = "{point." + key;
      if (valuePrefix || valueSuffix) {
        pointFormat = pointFormat.replace(RegExp(key + "}", "g"), valuePrefix + key + "}" + valueSuffix);
      }
      pointFormat = pointFormat.replace(RegExp(key + "}", "g"), key + ":,." + valueDecimals + "f}");
    });
    return format3(pointFormat, {
      point: this,
      series: this.series
    }, series.chart);
  }
  update(options, redraw, animation, runEvent) {
    const point = this, series = point.series, graphic = point.graphic, chart = series.chart, seriesOptions = series.options;
    let i;
    redraw = pick16(redraw, true);
    function update() {
      point.applyOptions(options);
      const hasMockGraphic = graphic && point.hasMockGraphic;
      const shouldDestroyGraphic = point.y === null ? !hasMockGraphic : hasMockGraphic;
      if (graphic && shouldDestroyGraphic) {
        point.graphic = graphic.destroy();
        delete point.hasMockGraphic;
      }
      if (isObject7(options, true)) {
        if (graphic && graphic.element) {
          if (options && options.marker && typeof options.marker.symbol !== "undefined") {
            point.graphic = graphic.destroy();
          }
        }
        if (options?.dataLabels && point.dataLabel) {
          point.dataLabel = point.dataLabel.destroy();
        }
      }
      i = point.index;
      series.updateParallelArrays(point, i);
      seriesOptions.data[i] = isObject7(seriesOptions.data[i], true) || isObject7(options, true) ? point.options : pick16(options, seriesOptions.data[i]);
      series.isDirty = series.isDirtyData = true;
      if (!series.fixedBox && series.hasCartesianSeries) {
        chart.isDirtyBox = true;
      }
      if (seriesOptions.legendType === "point") {
        chart.isDirtyLegend = true;
      }
      if (redraw) {
        chart.redraw(animation);
      }
    }
    if (runEvent === false) {
      update();
    } else {
      point.firePointEvent("update", { options }, update);
    }
  }
  remove(redraw, animation) {
    this.series.removePoint(this.series.data.indexOf(this), redraw, animation);
  }
  select(selected, accumulate) {
    const point = this, series = point.series, chart = series.chart;
    selected = pick16(selected, !point.selected);
    this.selectedStaging = selected;
    point.firePointEvent(selected ? "select" : "unselect", { accumulate }, function() {
      point.selected = point.options.selected = selected;
      series.options.data[series.data.indexOf(point)] = point.options;
      point.setState(selected && "select");
      if (!accumulate) {
        chart.getSelectedPoints().forEach(function(loopPoint) {
          const loopSeries = loopPoint.series;
          if (loopPoint.selected && loopPoint !== point) {
            loopPoint.selected = loopPoint.options.selected = false;
            loopSeries.options.data[loopSeries.data.indexOf(loopPoint)] = loopPoint.options;
            loopPoint.setState(chart.hoverPoints && loopSeries.options.inactiveOtherPoints ? "inactive" : "");
            loopPoint.firePointEvent("unselect");
          }
        });
      }
    });
    delete this.selectedStaging;
  }
  onMouseOver(e) {
    const point = this, series = point.series, { inverted, pointer } = series.chart;
    if (pointer) {
      e = e ? pointer.normalize(e) : pointer.getChartCoordinatesFromPoint(point, inverted);
      pointer.runPointActions(e, point);
    }
  }
  onMouseOut() {
    const point = this, chart = point.series.chart;
    point.firePointEvent("mouseOut");
    if (!point.series.options.inactiveOtherPoints) {
      (chart.hoverPoints || []).forEach(function(p) {
        p.setState();
      });
    }
    chart.hoverPoints = chart.hoverPoint = null;
  }
  manageEvent(eventType) {
    const point = this, options = merge13(point.series.options.point, point.options), userEvent = options.events?.[eventType];
    if (isFunction5(userEvent) && (!point.hcEvents?.[eventType] || point.hcEvents?.[eventType]?.map((el) => el.fn).indexOf(userEvent) === -1)) {
      point.importedUserEvent?.();
      point.importedUserEvent = addEvent8(point, eventType, userEvent);
    } else if (point.importedUserEvent && !userEvent && point.hcEvents?.[eventType]) {
      removeEvent5(point, eventType);
      delete point.hcEvents[eventType];
      if (!Object.keys(point.hcEvents)) {
        delete point.importedUserEvent;
      }
    }
  }
  setState(state, move) {
    const point = this, series = point.series, previousState = point.state, stateOptions = series.options.states[state || "normal"] || {}, markerOptions = defaultOptions5.plotOptions[series.type].marker && series.options.marker, normalDisabled = markerOptions && markerOptions.enabled === false, markerStateOptions = markerOptions && markerOptions.states && markerOptions.states[state || "normal"] || {}, stateDisabled = markerStateOptions.enabled === false, pointMarker = point.marker || {}, chart = series.chart, hasMarkers = markerOptions && series.markerAttribs;
    let halo = series.halo, markerAttribs, pointAttribs, pointAttribsAnimation, stateMarkerGraphic = series.stateMarkerGraphic, newSymbol;
    state = state || "";
    if (state === point.state && !move || point.selected && state !== "select" || stateOptions.enabled === false || state && (stateDisabled || normalDisabled && markerStateOptions.enabled === false) || state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) {
      return;
    }
    point.state = state;
    if (hasMarkers) {
      markerAttribs = series.markerAttribs(point, state);
    }
    if (point.graphic && !point.hasMockGraphic) {
      if (previousState) {
        point.graphic.removeClass("highcharts-point-" + previousState);
      }
      if (state) {
        point.graphic.addClass("highcharts-point-" + state);
      }
      if (!chart.styledMode) {
        pointAttribs = series.pointAttribs(point, state);
        pointAttribsAnimation = pick16(chart.options.chart.animation, stateOptions.animation);
        const opacity = pointAttribs.opacity;
        if (series.options.inactiveOtherPoints && isNumber14(opacity)) {
          (point.dataLabels || []).forEach(function(label) {
            if (label && !label.hasClass("highcharts-data-label-hidden")) {
              label.animate({ opacity }, pointAttribsAnimation);
              if (label.connector) {
                label.connector.animate({ opacity }, pointAttribsAnimation);
              }
            }
          });
        }
        point.graphic.animate(pointAttribs, pointAttribsAnimation);
      }
      if (markerAttribs) {
        point.graphic.animate(markerAttribs, pick16(chart.options.chart.animation, markerStateOptions.animation, markerOptions.animation));
      }
      if (stateMarkerGraphic) {
        stateMarkerGraphic.hide();
      }
    } else {
      if (state && markerStateOptions) {
        newSymbol = pointMarker.symbol || series.symbol;
        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
          stateMarkerGraphic = stateMarkerGraphic.destroy();
        }
        if (markerAttribs) {
          if (!stateMarkerGraphic) {
            if (newSymbol) {
              series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height).add(series.markerGroup);
              stateMarkerGraphic.currentSymbol = newSymbol;
            }
          } else {
            stateMarkerGraphic[move ? "animate" : "attr"]({
              x: markerAttribs.x,
              y: markerAttribs.y
            });
          }
        }
        if (!chart.styledMode && stateMarkerGraphic && point.state !== "inactive") {
          stateMarkerGraphic.attr(series.pointAttribs(point, state));
        }
      }
      if (stateMarkerGraphic) {
        stateMarkerGraphic[state && point.isInside ? "show" : "hide"]();
        stateMarkerGraphic.element.point = point;
        stateMarkerGraphic.addClass(point.getClassName(), true);
      }
    }
    const haloOptions = stateOptions.halo;
    const markerGraphic = point.graphic || stateMarkerGraphic;
    const markerVisibility = markerGraphic && markerGraphic.visibility || "inherit";
    if (haloOptions && haloOptions.size && markerGraphic && markerVisibility !== "hidden" && !point.isCluster) {
      if (!halo) {
        series.halo = halo = chart.renderer.path().add(markerGraphic.parentGroup);
      }
      halo.show()[move ? "animate" : "attr"]({
        d: point.haloPath(haloOptions.size)
      });
      halo.attr({
        class: "highcharts-halo highcharts-color-" + pick16(point.colorIndex, series.colorIndex) + (point.className ? " " + point.className : ""),
        visibility: markerVisibility,
        zIndex: -1
      });
      halo.point = point;
      if (!chart.styledMode) {
        halo.attr(extend13({
          fill: point.color || series.color,
          "fill-opacity": haloOptions.opacity
        }, AST_default.filterUserAttributes(haloOptions.attributes || {})));
      }
    } else if (halo?.point?.haloPath && !halo.point.destroyed) {
      halo.animate({ d: halo.point.haloPath(0) }, null, halo.hide);
    }
    fireEvent9(point, "afterSetState", { state });
  }
  haloPath(size) {
    const pos = this.pos();
    return pos ? this.series.chart.renderer.symbols.circle(crisp4(pos[0], 1) - size, pos[1] - size, size * 2, size * 2) : [];
  }
}
var Point_default = Point;

// node_modules/highcharts/es-modules/Core/Pointer.js
var { parse: color2 } = Color_default;
var { charts: charts3, composed: composed3, isTouchDevice: isTouchDevice2 } = Globals_default;
var { addEvent: addEvent9, attr: attr7, css: css7, extend: extend14, find: find2, fireEvent: fireEvent10, isNumber: isNumber15, isObject: isObject8, objectEach: objectEach12, offset: offset2, pick: pick17, pushUnique: pushUnique6, splat: splat6 } = Utilities_default;

class Pointer {
  applyInactiveState(points) {
    let activeSeries = [], series;
    (points || []).forEach(function(item) {
      series = item.series;
      activeSeries.push(series);
      if (series.linkedParent) {
        activeSeries.push(series.linkedParent);
      }
      if (series.linkedSeries) {
        activeSeries = activeSeries.concat(series.linkedSeries);
      }
      if (series.navigatorSeries) {
        activeSeries.push(series.navigatorSeries);
      }
    });
    this.chart.series.forEach(function(inactiveSeries) {
      if (activeSeries.indexOf(inactiveSeries) === -1) {
        inactiveSeries.setState("inactive", true);
      } else if (inactiveSeries.options.inactiveOtherPoints) {
        inactiveSeries.setAllPointsToState("inactive");
      }
    });
  }
  destroy() {
    const pointer = this;
    this.eventsToUnbind.forEach((unbind) => unbind());
    this.eventsToUnbind = [];
    if (!Globals_default.chartCount) {
      if (Pointer.unbindDocumentMouseUp) {
        Pointer.unbindDocumentMouseUp = Pointer.unbindDocumentMouseUp();
      }
      if (Pointer.unbindDocumentTouchEnd) {
        Pointer.unbindDocumentTouchEnd = Pointer.unbindDocumentTouchEnd();
      }
    }
    clearInterval(pointer.tooltipTimeout);
    objectEach12(pointer, function(_val, prop) {
      pointer[prop] = undefined;
    });
  }
  getSelectionMarkerAttrs(chartX, chartY) {
    const e = {
      args: { chartX, chartY },
      attrs: {},
      shapeType: "rect"
    };
    fireEvent10(this, "getSelectionMarkerAttrs", e, (e2) => {
      const { chart, zoomHor, zoomVert } = this, { mouseDownX = 0, mouseDownY = 0 } = chart, attrs = e2.attrs;
      let size;
      attrs.x = chart.plotLeft;
      attrs.y = chart.plotTop;
      attrs.width = zoomHor ? 1 : chart.plotWidth;
      attrs.height = zoomVert ? 1 : chart.plotHeight;
      if (zoomHor) {
        size = chartX - mouseDownX;
        attrs.width = Math.max(1, Math.abs(size));
        attrs.x = (size > 0 ? 0 : size) + mouseDownX;
      }
      if (zoomVert) {
        size = chartY - mouseDownY;
        attrs.height = Math.max(1, Math.abs(size));
        attrs.y = (size > 0 ? 0 : size) + mouseDownY;
      }
    });
    return e;
  }
  drag(e) {
    const { chart } = this, { mouseDownX = 0, mouseDownY = 0 } = chart, { panning, panKey, selectionMarkerFill } = chart.options.chart, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, panningEnabled = isObject8(panning) ? panning.enabled : panning, panKeyPressed = panKey && e[`${panKey}Key`];
    let { chartX, chartY } = e, clickedInside, selectionMarker = this.selectionMarker;
    if (selectionMarker && selectionMarker.touch) {
      return;
    }
    if (chartX < plotLeft) {
      chartX = plotLeft;
    } else if (chartX > plotLeft + plotWidth) {
      chartX = plotLeft + plotWidth;
    }
    if (chartY < plotTop) {
      chartY = plotTop;
    } else if (chartY > plotTop + plotHeight) {
      chartY = plotTop + plotHeight;
    }
    this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));
    if (this.hasDragged > 10) {
      clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop, {
        visiblePlotOnly: true
      });
      const { shapeType, attrs } = this.getSelectionMarkerAttrs(chartX, chartY);
      if ((chart.hasCartesianSeries || chart.mapView) && this.hasZoom && clickedInside && !panKeyPressed) {
        if (!selectionMarker) {
          this.selectionMarker = selectionMarker = chart.renderer[shapeType]();
          selectionMarker.attr({
            class: "highcharts-selection-marker",
            zIndex: 7
          }).add();
          if (!chart.styledMode) {
            selectionMarker.attr({
              fill: selectionMarkerFill || color2("#334eff").setOpacity(0.25).get()
            });
          }
        }
      }
      if (selectionMarker) {
        selectionMarker.attr(attrs);
      }
      if (clickedInside && !selectionMarker && panningEnabled) {
        chart.pan(e, panning);
      }
    }
  }
  dragStart(e) {
    const chart = this.chart;
    chart.mouseIsDown = e.type;
    chart.cancelClick = false;
    chart.mouseDownX = e.chartX;
    chart.mouseDownY = e.chartY;
  }
  getSelectionBox(marker) {
    const e = {
      args: { marker },
      result: marker.getBBox()
    };
    fireEvent10(this, "getSelectionBox", e);
    return e.result;
  }
  drop(e) {
    const { chart, selectionMarker } = this;
    let redraw;
    for (const axis of chart.axes) {
      if (axis.isPanning) {
        axis.isPanning = false;
        if (axis.options.startOnTick || axis.options.endOnTick || axis.series.some((s) => s.boosted)) {
          axis.forceRedraw = true;
          axis.setExtremes(axis.userMin, axis.userMax, false);
          redraw = true;
        }
      }
    }
    if (redraw) {
      chart.redraw();
    }
    if (selectionMarker && e) {
      if (this.hasDragged) {
        const from = this.getSelectionBox(selectionMarker);
        chart.transform({
          axes: chart.axes.filter((a) => a.zoomEnabled && (a.coll === "xAxis" && this.zoomX || a.coll === "yAxis" && this.zoomY)),
          selection: {
            originalEvent: e,
            xAxis: [],
            yAxis: [],
            ...from
          },
          from
        });
      }
      if (isNumber15(chart.index)) {
        this.selectionMarker = selectionMarker.destroy();
      }
    }
    if (chart && isNumber15(chart.index)) {
      css7(chart.container, { cursor: chart._cursor });
      chart.cancelClick = this.hasDragged > 10;
      chart.mouseIsDown = false;
      this.hasDragged = 0;
      this.pinchDown = [];
    }
  }
  findNearestKDPoint(series, shared, e) {
    let closest;
    function sort(p1, p2) {
      const isCloserX = p1.distX - p2.distX, isCloser = p1.dist - p2.dist, isAbove = p2.series.group?.zIndex - p1.series.group?.zIndex;
      let result;
      if (isCloserX !== 0 && shared) {
        result = isCloserX;
      } else if (isCloser !== 0) {
        result = isCloser;
      } else if (isAbove !== 0) {
        result = isAbove;
      } else {
        result = p1.series.index > p2.series.index ? -1 : 1;
      }
      return result;
    }
    series.forEach(function(s) {
      const noSharedTooltip = s.noSharedTooltip && shared, compareX = !noSharedTooltip && s.options.findNearestPointBy.indexOf("y") < 0, point = s.searchPoint(e, compareX);
      if (isObject8(point, true) && point.series && (!isObject8(closest, true) || sort(closest, point) > 0)) {
        closest = point;
      }
    });
    return closest;
  }
  getChartCoordinatesFromPoint(point, inverted) {
    const { xAxis: xAxis2, yAxis: yAxis2 } = point.series, shapeArgs = point.shapeArgs;
    if (xAxis2 && yAxis2) {
      let x = point.clientX ?? point.plotX ?? 0, y = point.plotY || 0;
      if (point.isNode && shapeArgs && isNumber15(shapeArgs.x) && isNumber15(shapeArgs.y)) {
        x = shapeArgs.x;
        y = shapeArgs.y;
      }
      return inverted ? {
        chartX: yAxis2.len + yAxis2.pos - y,
        chartY: xAxis2.len + xAxis2.pos - x
      } : {
        chartX: x + xAxis2.pos,
        chartY: y + yAxis2.pos
      };
    }
    if (shapeArgs && shapeArgs.x && shapeArgs.y) {
      return {
        chartX: shapeArgs.x,
        chartY: shapeArgs.y
      };
    }
  }
  getChartPosition() {
    if (this.chartPosition) {
      return this.chartPosition;
    }
    const { container } = this.chart;
    const pos = offset2(container);
    this.chartPosition = {
      left: pos.left,
      top: pos.top,
      scaleX: 1,
      scaleY: 1
    };
    const { offsetHeight, offsetWidth } = container;
    if (offsetWidth > 2 && offsetHeight > 2) {
      this.chartPosition.scaleX = pos.width / offsetWidth;
      this.chartPosition.scaleY = pos.height / offsetHeight;
    }
    return this.chartPosition;
  }
  getCoordinates(e) {
    const coordinates = {
      xAxis: [],
      yAxis: []
    };
    for (const axis of this.chart.axes) {
      coordinates[axis.isXAxis ? "xAxis" : "yAxis"].push({
        axis,
        value: axis.toValue(e[axis.horiz ? "chartX" : "chartY"])
      });
    }
    return coordinates;
  }
  getHoverData(existingHoverPoint, existingHoverSeries, series, isDirectTouch, shared, e) {
    const hoverPoints = [], useExisting = !!(isDirectTouch && existingHoverPoint), filter = function(s) {
      return s.visible && !(!shared && s.directTouch) && pick17(s.options.enableMouseTracking, true);
    };
    let hoverSeries = existingHoverSeries, searchSeries, eventArgs = {
      chartX: e ? e.chartX : undefined,
      chartY: e ? e.chartY : undefined,
      shared
    };
    fireEvent10(this, "beforeGetHoverData", eventArgs);
    const notSticky = hoverSeries && !hoverSeries.stickyTracking;
    searchSeries = notSticky ? [hoverSeries] : series.filter((s) => s.stickyTracking && (eventArgs.filter || filter)(s));
    const hoverPoint = useExisting || !e ? existingHoverPoint : this.findNearestKDPoint(searchSeries, shared, e);
    hoverSeries = hoverPoint && hoverPoint.series;
    if (hoverPoint) {
      if (shared && !hoverSeries.noSharedTooltip) {
        searchSeries = series.filter(function(s) {
          return eventArgs.filter ? eventArgs.filter(s) : filter(s) && !s.noSharedTooltip;
        });
        searchSeries.forEach(function(s) {
          let point = find2(s.points, function(p) {
            return p.x === hoverPoint.x && !p.isNull;
          });
          if (isObject8(point)) {
            if (s.boosted && s.boost) {
              point = s.boost.getPoint(point);
            }
            hoverPoints.push(point);
          }
        });
      } else {
        hoverPoints.push(hoverPoint);
      }
    }
    eventArgs = { hoverPoint };
    fireEvent10(this, "afterGetHoverData", eventArgs);
    return {
      hoverPoint: eventArgs.hoverPoint,
      hoverSeries,
      hoverPoints
    };
  }
  getPointFromEvent(e) {
    let target = e.target, point;
    while (target && !point) {
      point = target.point;
      target = target.parentNode;
    }
    return point;
  }
  onTrackerMouseOut(e) {
    const chart = this.chart;
    const relatedTarget = e.relatedTarget;
    const series = chart.hoverSeries;
    this.isDirectTouch = false;
    if (series && relatedTarget && !series.stickyTracking && !this.inClass(relatedTarget, "highcharts-tooltip") && (!this.inClass(relatedTarget, "highcharts-series-" + series.index) || !this.inClass(relatedTarget, "highcharts-tracker"))) {
      series.onMouseOut();
    }
  }
  inClass(element, className) {
    let elem = element, elemClassName;
    while (elem) {
      elemClassName = attr7(elem, "class");
      if (elemClassName) {
        if (elemClassName.indexOf(className) !== -1) {
          return true;
        }
        if (elemClassName.indexOf("highcharts-container") !== -1) {
          return false;
        }
      }
      elem = elem.parentElement;
    }
  }
  constructor(chart, options) {
    this.hasDragged = 0;
    this.pointerCaptureEventsToUnbind = [];
    this.eventsToUnbind = [];
    this.options = options;
    this.chart = chart;
    this.runChartClick = Boolean(options.chart.events?.click);
    this.pinchDown = [];
    this.setDOMEvents();
    fireEvent10(this, "afterInit");
  }
  normalize(e, chartPosition) {
    const touches = e.touches;
    const ePos = touches ? touches.length ? touches.item(0) : pick17(touches.changedTouches, e.changedTouches)[0] : e;
    if (!chartPosition) {
      chartPosition = this.getChartPosition();
    }
    let chartX = ePos.pageX - chartPosition.left, chartY = ePos.pageY - chartPosition.top;
    chartX /= chartPosition.scaleX;
    chartY /= chartPosition.scaleY;
    return extend14(e, {
      chartX: Math.round(chartX),
      chartY: Math.round(chartY)
    });
  }
  onContainerClick(e) {
    const chart = this.chart;
    const hoverPoint = chart.hoverPoint;
    const pEvt = this.normalize(e);
    const plotLeft = chart.plotLeft;
    const plotTop = chart.plotTop;
    if (!chart.cancelClick) {
      if (hoverPoint && this.inClass(pEvt.target, "highcharts-tracker")) {
        fireEvent10(hoverPoint.series, "click", extend14(pEvt, {
          point: hoverPoint
        }));
        if (chart.hoverPoint) {
          hoverPoint.firePointEvent("click", pEvt);
        }
      } else {
        extend14(pEvt, this.getCoordinates(pEvt));
        if (chart.isInsidePlot(pEvt.chartX - plotLeft, pEvt.chartY - plotTop, {
          visiblePlotOnly: true
        })) {
          fireEvent10(chart, "click", pEvt);
        }
      }
    }
  }
  onContainerMouseDown(e) {
    const isPrimaryButton = ((e.buttons || e.button) & 1) === 1;
    e = this.normalize(e);
    if (Globals_default.isFirefox && e.button !== 0) {
      this.onContainerMouseMove(e);
    }
    if (typeof e.button === "undefined" || isPrimaryButton) {
      this.zoomOption(e);
      if (isPrimaryButton) {
        e.preventDefault?.();
      }
      this.dragStart(e);
    }
  }
  onContainerMouseLeave(e) {
    const { pointer } = charts3[pick17(Pointer.hoverChartIndex, -1)] || {};
    e = this.normalize(e);
    this.onContainerMouseMove(e);
    if (pointer && !this.inClass(e.relatedTarget, "highcharts-tooltip")) {
      pointer.reset();
      pointer.chartPosition = undefined;
    }
  }
  onContainerMouseEnter() {
    delete this.chartPosition;
  }
  onContainerMouseMove(e) {
    const chart = this.chart, tooltip = chart.tooltip, pEvt = this.normalize(e);
    this.setHoverChartIndex(e);
    if (chart.mouseIsDown === "mousedown" || this.touchSelect(pEvt)) {
      this.drag(pEvt);
    }
    if (!chart.openMenu && (this.inClass(pEvt.target, "highcharts-tracker") || chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
      visiblePlotOnly: true
    })) && !(tooltip && tooltip.shouldStickOnContact(pEvt))) {
      if (this.inClass(pEvt.target, "highcharts-no-tooltip")) {
        this.reset(false, 0);
      } else {
        this.runPointActions(pEvt);
      }
    }
  }
  onDocumentTouchEnd(e) {
    this.onDocumentMouseUp(e);
  }
  onContainerTouchMove(e) {
    if (this.touchSelect(e)) {
      this.onContainerMouseMove(e);
    } else {
      this.touch(e);
    }
  }
  onContainerTouchStart(e) {
    if (this.touchSelect(e)) {
      this.onContainerMouseDown(e);
    } else {
      this.zoomOption(e);
      this.touch(e, true);
    }
  }
  onDocumentMouseMove(e) {
    const chart = this.chart;
    const tooltip = chart.tooltip;
    const chartPosition = this.chartPosition;
    const pEvt = this.normalize(e, chartPosition);
    if (chartPosition && !chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
      visiblePlotOnly: true
    }) && !(tooltip && tooltip.shouldStickOnContact(pEvt)) && (pEvt.target === chart.container.ownerDocument || !this.inClass(pEvt.target, "highcharts-tracker"))) {
      this.reset();
    }
  }
  onDocumentMouseUp(e) {
    charts3[pick17(Pointer.hoverChartIndex, -1)]?.pointer?.drop(e);
  }
  pinch(e) {
    const pointer = this, { chart, hasZoom, lastTouches } = pointer, touches = [].map.call(e.touches || [], (touch) => pointer.normalize(touch)), touchesLength = touches.length, fireClickEvent = touchesLength === 1 && (pointer.inClass(e.target, "highcharts-tracker") && chart.runTrackerClick || pointer.runChartClick), tooltip = chart.tooltip, followTouchMove = touchesLength === 1 && pick17(tooltip?.options.followTouchMove, true);
    if (touchesLength > 1) {
      pointer.initiated = true;
    } else if (followTouchMove) {
      pointer.initiated = false;
    }
    if (hasZoom && pointer.initiated && !fireClickEvent && e.cancelable !== false) {
      e.preventDefault();
    }
    if (e.type === "touchstart") {
      pointer.pinchDown = touches;
      pointer.res = true;
      chart.mouseDownX = e.chartX;
    } else if (followTouchMove) {
      this.runPointActions(pointer.normalize(e));
    } else if (lastTouches) {
      fireEvent10(chart, "touchpan", {
        originalEvent: e,
        touches
      }, () => {
        const boxFromTouches = (touches2) => {
          const finger0 = touches2[0], finger1 = touches2[1] || finger0;
          return {
            x: finger0.chartX,
            y: finger0.chartY,
            width: finger1.chartX - finger0.chartX,
            height: finger1.chartY - finger0.chartY
          };
        };
        chart.transform({
          axes: chart.axes.filter((axis) => axis.zoomEnabled && (this.zoomHor && axis.horiz || this.zoomVert && !axis.horiz)),
          to: boxFromTouches(touches),
          from: boxFromTouches(lastTouches),
          trigger: e.type
        });
      });
      if (pointer.res) {
        pointer.res = false;
        this.reset(false, 0);
      }
    }
    pointer.lastTouches = touches;
  }
  reset(allowMove, delay) {
    const pointer = this, chart = pointer.chart, hoverSeries = chart.hoverSeries, hoverPoint = chart.hoverPoint, hoverPoints = chart.hoverPoints, tooltip = chart.tooltip, tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;
    if (allowMove && tooltipPoints) {
      splat6(tooltipPoints).forEach(function(point) {
        if (point.series.isCartesian && typeof point.plotX === "undefined") {
          allowMove = false;
        }
      });
    }
    if (allowMove) {
      if (tooltip && tooltipPoints && splat6(tooltipPoints).length) {
        tooltip.refresh(tooltipPoints);
        if (tooltip.shared && hoverPoints) {
          hoverPoints.forEach(function(point) {
            point.setState(point.state, true);
            if (point.series.isCartesian) {
              if (point.series.xAxis.crosshair) {
                point.series.xAxis.drawCrosshair(null, point);
              }
              if (point.series.yAxis.crosshair) {
                point.series.yAxis.drawCrosshair(null, point);
              }
            }
          });
        } else if (hoverPoint) {
          hoverPoint.setState(hoverPoint.state, true);
          chart.axes.forEach(function(axis) {
            if (axis.crosshair && hoverPoint.series[axis.coll] === axis) {
              axis.drawCrosshair(null, hoverPoint);
            }
          });
        }
      }
    } else {
      if (hoverPoint) {
        hoverPoint.onMouseOut();
      }
      if (hoverPoints) {
        hoverPoints.forEach(function(point) {
          point.setState();
        });
      }
      if (hoverSeries) {
        hoverSeries.onMouseOut();
      }
      if (tooltip) {
        tooltip.hide(delay);
      }
      if (pointer.unDocMouseMove) {
        pointer.unDocMouseMove = pointer.unDocMouseMove();
      }
      chart.axes.forEach(function(axis) {
        axis.hideCrosshair();
      });
      chart.hoverPoints = chart.hoverPoint = undefined;
    }
  }
  runPointActions(e, p, force) {
    const pointer = this, chart = pointer.chart, series = chart.series, tooltip = chart.tooltip && chart.tooltip.options.enabled ? chart.tooltip : undefined, shared = tooltip ? tooltip.shared : false;
    let hoverPoint = p || chart.hoverPoint, hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries;
    const isDirectTouch = (!e || e.type !== "touchmove") && (!!p || hoverSeries && hoverSeries.directTouch && pointer.isDirectTouch), hoverData = this.getHoverData(hoverPoint, hoverSeries, series, isDirectTouch, shared, e);
    hoverPoint = hoverData.hoverPoint;
    hoverSeries = hoverData.hoverSeries;
    const points = hoverData.hoverPoints, followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer && !hoverSeries.tooltipOptions.split, useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip;
    if (hoverPoint && (force || hoverPoint !== chart.hoverPoint || tooltip && tooltip.isHidden)) {
      (chart.hoverPoints || []).forEach(function(p2) {
        if (points.indexOf(p2) === -1) {
          p2.setState();
        }
      });
      if (chart.hoverSeries !== hoverSeries) {
        hoverSeries.onMouseOver();
      }
      pointer.applyInactiveState(points);
      (points || []).forEach(function(p2) {
        p2.setState("hover");
      });
      if (chart.hoverPoint) {
        chart.hoverPoint.firePointEvent("mouseOut");
      }
      if (!hoverPoint.series) {
        return;
      }
      chart.hoverPoints = points;
      chart.hoverPoint = hoverPoint;
      hoverPoint.firePointEvent("mouseOver", undefined, () => {
        if (tooltip && hoverPoint) {
          tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);
        }
      });
    } else if (followPointer && tooltip && !tooltip.isHidden) {
      const anchor = tooltip.getAnchor([{}], e);
      if (chart.isInsidePlot(anchor[0], anchor[1], {
        visiblePlotOnly: true
      })) {
        tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
      }
    }
    if (!pointer.unDocMouseMove) {
      pointer.unDocMouseMove = addEvent9(chart.container.ownerDocument, "mousemove", (e2) => charts3[Pointer.hoverChartIndex ?? -1]?.pointer?.onDocumentMouseMove(e2));
      pointer.eventsToUnbind.push(pointer.unDocMouseMove);
    }
    chart.axes.forEach(function drawAxisCrosshair(axis) {
      const snap = pick17((axis.crosshair || {}).snap, true);
      let point;
      if (snap) {
        point = chart.hoverPoint;
        if (!point || point.series[axis.coll] !== axis) {
          point = find2(points, (p2) => p2.series && p2.series[axis.coll] === axis);
        }
      }
      if (point || !snap) {
        axis.drawCrosshair(e, point);
      } else {
        axis.hideCrosshair();
      }
    });
  }
  setDOMEvents() {
    const container = this.chart.container, ownerDoc = container.ownerDocument;
    container.onmousedown = this.onContainerMouseDown.bind(this);
    container.onmousemove = this.onContainerMouseMove.bind(this);
    container.onclick = this.onContainerClick.bind(this);
    this.eventsToUnbind.push(addEvent9(container, "mouseenter", this.onContainerMouseEnter.bind(this)), addEvent9(container, "mouseleave", this.onContainerMouseLeave.bind(this)));
    if (!Pointer.unbindDocumentMouseUp) {
      Pointer.unbindDocumentMouseUp = addEvent9(ownerDoc, "mouseup", this.onDocumentMouseUp.bind(this));
    }
    let parent = this.chart.renderTo.parentElement;
    while (parent && parent.tagName !== "BODY") {
      this.eventsToUnbind.push(addEvent9(parent, "scroll", () => {
        delete this.chartPosition;
      }));
      parent = parent.parentElement;
    }
    this.eventsToUnbind.push(addEvent9(container, "touchstart", this.onContainerTouchStart.bind(this), { passive: false }), addEvent9(container, "touchmove", this.onContainerTouchMove.bind(this), { passive: false }));
    if (!Pointer.unbindDocumentTouchEnd) {
      Pointer.unbindDocumentTouchEnd = addEvent9(ownerDoc, "touchend", this.onDocumentTouchEnd.bind(this), { passive: false });
    }
    this.setPointerCapture();
    addEvent9(this.chart, "redraw", this.setPointerCapture.bind(this));
  }
  setPointerCapture() {
    if (!isTouchDevice2) {
      return;
    }
    const pointer = this, events = pointer.pointerCaptureEventsToUnbind, chart = pointer.chart, container = chart.container, followTouchMove = pick17(chart.options.tooltip?.followTouchMove, true), shouldHave = followTouchMove && chart.series.some((series) => series.options.findNearestPointBy.indexOf("y") > -1);
    if (!pointer.hasPointerCapture && shouldHave) {
      events.push(addEvent9(container, "pointerdown", (e) => {
        if (e.target?.hasPointerCapture(e.pointerId)) {
          e.target?.releasePointerCapture(e.pointerId);
        }
      }), addEvent9(container, "pointermove", (e) => {
        chart.pointer?.getPointFromEvent(e)?.onMouseOver(e);
      }));
      if (!chart.styledMode) {
        css7(container, { "touch-action": "none" });
      }
      container.className += " highcharts-no-touch-action";
      pointer.hasPointerCapture = true;
    } else if (pointer.hasPointerCapture && !shouldHave) {
      events.forEach((e) => e());
      events.length = 0;
      if (!chart.styledMode) {
        css7(container, {
          "touch-action": pick17(chart.options.chart.style?.["touch-action"], "manipulation")
        });
      }
      container.className = container.className.replace(" highcharts-no-touch-action", "");
      pointer.hasPointerCapture = false;
    }
  }
  setHoverChartIndex(e) {
    const chart = this.chart;
    const hoverChart = Globals_default.charts[pick17(Pointer.hoverChartIndex, -1)];
    if (hoverChart && hoverChart !== chart) {
      const relatedTargetObj = { relatedTarget: chart.container };
      if (e && !e?.relatedTarget) {
        e = { ...relatedTargetObj, ...e };
      }
      hoverChart.pointer?.onContainerMouseLeave(e || relatedTargetObj);
    }
    if (!hoverChart || !hoverChart.mouseIsDown) {
      Pointer.hoverChartIndex = chart.index;
    }
  }
  touch(e, start) {
    const { chart, pinchDown = [] } = this;
    let hasMoved, isInside;
    this.setHoverChartIndex();
    e = this.normalize(e);
    if (e.touches.length === 1) {
      isInside = chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop, {
        visiblePlotOnly: true
      });
      if (isInside && !chart.openMenu) {
        if (start) {
          this.runPointActions(e);
        }
        if (e.type === "touchmove") {
          hasMoved = pinchDown[0] ? Math.pow(pinchDown[0].chartX - e.chartX, 2) + Math.pow(pinchDown[0].chartY - e.chartY, 2) >= 16 : false;
        }
        if (pick17(hasMoved, true)) {
          this.pinch(e);
        }
      } else if (start) {
        this.reset();
      }
    } else if (e.touches.length === 2) {
      this.pinch(e);
    }
  }
  touchSelect(e) {
    return Boolean(this.chart.zooming.singleTouch && e.touches && e.touches.length === 1);
  }
  zoomOption(e) {
    const chart = this.chart, inverted = chart.inverted;
    let zoomType = chart.zooming.type || "", zoomX, zoomY;
    if (/touch/.test(e.type)) {
      zoomType = pick17(chart.zooming.pinchType, zoomType);
    }
    this.zoomX = zoomX = /x/.test(zoomType);
    this.zoomY = zoomY = /y/.test(zoomType);
    this.zoomHor = zoomX && !inverted || zoomY && inverted;
    this.zoomVert = zoomY && !inverted || zoomX && inverted;
    this.hasZoom = zoomX || zoomY;
  }
}
(function(Pointer2) {
  function compose(ChartClass) {
    if (pushUnique6(composed3, "Core.Pointer")) {
      addEvent9(ChartClass, "beforeRender", function() {
        this.pointer = new Pointer2(this, this.options);
      });
    }
  }
  Pointer2.compose = compose;
})(Pointer || (Pointer = {}));
var Pointer_default = Pointer;

// node_modules/highcharts/es-modules/Core/Legend/LegendSymbol.js
var { extend: extend15, merge: merge14, pick: pick18 } = Utilities_default;
var LegendSymbol;
(function(LegendSymbol2) {
  function areaMarker(legend, item) {
    lineMarker.call(this, legend, item, true);
  }
  LegendSymbol2.areaMarker = areaMarker;
  function lineMarker(legend, item, hasArea) {
    const legendItem = this.legendItem = this.legendItem || {}, { chart, options } = this, { baseline = 0, symbolWidth, symbolHeight } = legend, symbol = this.symbol || "circle", generalRadius = symbolHeight / 2, renderer = chart.renderer, legendItemGroup = legendItem.group, verticalCenter = baseline - Math.round(symbolHeight * (hasArea ? 0.4 : 0.3)), attr8 = {};
    let legendSymbol, markerOptions = options.marker, lineSizer = 0;
    if (!chart.styledMode) {
      attr8["stroke-width"] = Math.min(options.lineWidth || 0, 24);
      if (options.dashStyle) {
        attr8.dashstyle = options.dashStyle;
      } else if (options.linecap !== "square") {
        attr8["stroke-linecap"] = "round";
      }
    }
    legendItem.line = renderer.path().addClass("highcharts-graph").attr(attr8).add(legendItemGroup);
    if (hasArea) {
      legendItem.area = renderer.path().addClass("highcharts-area").add(legendItemGroup);
    }
    if (attr8["stroke-linecap"]) {
      lineSizer = Math.min(legendItem.line.strokeWidth(), symbolWidth) / 2;
    }
    if (symbolWidth) {
      const d = [
        ["M", lineSizer, verticalCenter],
        ["L", symbolWidth - lineSizer, verticalCenter]
      ];
      legendItem.line.attr({ d });
      legendItem.area?.attr({
        d: [
          ...d,
          ["L", symbolWidth - lineSizer, baseline],
          ["L", lineSizer, baseline]
        ]
      });
    }
    if (markerOptions && markerOptions.enabled !== false && symbolWidth) {
      let radius = Math.min(pick18(markerOptions.radius, generalRadius), generalRadius);
      if (symbol.indexOf("url") === 0) {
        markerOptions = merge14(markerOptions, {
          width: symbolHeight,
          height: symbolHeight
        });
        radius = 0;
      }
      legendItem.symbol = legendSymbol = renderer.symbol(symbol, symbolWidth / 2 - radius, verticalCenter - radius, 2 * radius, 2 * radius, extend15({ context: "legend" }, markerOptions)).addClass("highcharts-point").add(legendItemGroup);
      legendSymbol.isMarker = true;
    }
  }
  LegendSymbol2.lineMarker = lineMarker;
  function rectangle(legend, item) {
    const legendItem = item.legendItem || {}, options = legend.options, symbolHeight = legend.symbolHeight, square = options.squareSymbol, symbolWidth = square ? symbolHeight : legend.symbolWidth;
    legendItem.symbol = this.chart.renderer.rect(square ? (legend.symbolWidth - symbolHeight) / 2 : 0, legend.baseline - symbolHeight + 1, symbolWidth, symbolHeight, pick18(legend.options.symbolRadius, symbolHeight / 2)).addClass("highcharts-point").attr({
      zIndex: 3
    }).add(legendItem.group);
  }
  LegendSymbol2.rectangle = rectangle;
})(LegendSymbol || (LegendSymbol = {}));
var LegendSymbol_default = LegendSymbol;

// node_modules/highcharts/es-modules/Core/Series/SeriesDefaults.js
var seriesDefaults = {
  lineWidth: 2,
  allowPointSelect: false,
  crisp: true,
  showCheckbox: false,
  animation: {
    duration: 1000
  },
  enableMouseTracking: true,
  events: {},
  marker: {
    enabledThreshold: 2,
    lineColor: "#ffffff",
    lineWidth: 0,
    radius: 4,
    states: {
      normal: {
        animation: true
      },
      hover: {
        animation: {
          duration: 150
        },
        enabled: true,
        radiusPlus: 2,
        lineWidthPlus: 1
      },
      select: {
        fillColor: "#cccccc",
        lineColor: "#000000",
        lineWidth: 2
      }
    }
  },
  point: {
    events: {}
  },
  dataLabels: {
    animation: {},
    align: "center",
    borderWidth: 0,
    defer: true,
    formatter: function() {
      const { numberFormatter } = this.series.chart;
      return typeof this.y !== "number" ? "" : numberFormatter(this.y, -1);
    },
    padding: 5,
    style: {
      fontSize: "0.7em",
      fontWeight: "bold",
      color: "contrast",
      textOutline: "1px contrast"
    },
    verticalAlign: "bottom",
    x: 0,
    y: 0
  },
  cropThreshold: 300,
  opacity: 1,
  pointRange: 0,
  softThreshold: true,
  states: {
    normal: {
      animation: true
    },
    hover: {
      animation: {
        duration: 150
      },
      lineWidthPlus: 1,
      marker: {},
      halo: {
        size: 10,
        opacity: 0.25
      }
    },
    select: {
      animation: {
        duration: 0
      }
    },
    inactive: {
      animation: {
        duration: 150
      },
      opacity: 0.2
    }
  },
  stickyTracking: true,
  turboThreshold: 1000,
  findNearestPointBy: "x"
};
var SeriesDefaults_default = seriesDefaults;

// node_modules/highcharts/es-modules/Core/Series/SeriesRegistry.js
var { defaultOptions: defaultOptions6 } = Defaults_default;
var { extend: extend16, extendClass: extendClass2, merge: merge15 } = Utilities_default;
var SeriesRegistry;
(function(SeriesRegistry2) {
  SeriesRegistry2.seriesTypes = Globals_default.seriesTypes;
  function registerSeriesType(seriesType2, SeriesClass) {
    const defaultPlotOptions = defaultOptions6.plotOptions || {}, seriesOptions = SeriesClass.defaultOptions, seriesProto = SeriesClass.prototype;
    seriesProto.type = seriesType2;
    if (!seriesProto.pointClass) {
      seriesProto.pointClass = Point_default;
    }
    if (SeriesRegistry2.seriesTypes[seriesType2]) {
      return false;
    }
    if (seriesOptions) {
      defaultPlotOptions[seriesType2] = seriesOptions;
    }
    SeriesRegistry2.seriesTypes[seriesType2] = SeriesClass;
    return true;
  }
  SeriesRegistry2.registerSeriesType = registerSeriesType;
  function seriesType(type, parent, options, seriesProto, pointProto) {
    const defaultPlotOptions = defaultOptions6.plotOptions || {};
    parent = parent || "";
    defaultPlotOptions[type] = merge15(defaultPlotOptions[parent], options);
    delete SeriesRegistry2.seriesTypes[type];
    registerSeriesType(type, extendClass2(SeriesRegistry2.seriesTypes[parent] || function() {
    }, seriesProto));
    SeriesRegistry2.seriesTypes[type].prototype.type = type;
    if (pointProto) {

      class PointClass extends Point_default {
      }
      extend16(PointClass.prototype, pointProto);
      SeriesRegistry2.seriesTypes[type].prototype.pointClass = PointClass;
    }
    return SeriesRegistry2.seriesTypes[type];
  }
  SeriesRegistry2.seriesType = seriesType;
})(SeriesRegistry || (SeriesRegistry = {}));
var SeriesRegistry_default = SeriesRegistry;

// node_modules/highcharts/es-modules/Core/Series/Series.js
var { animObject: animObject6, setAnimation: setAnimation2 } = AnimationUtilities_default;
var { defaultOptions: defaultOptions7 } = Defaults_default;
var { registerEventOptions: registerEventOptions2 } = Foundation_default;
var { svg: svg2, win: win8 } = Globals_default;
var { seriesTypes } = SeriesRegistry_default;
var { arrayMax: arrayMax4, arrayMin: arrayMin4, clamp: clamp6, correctFloat: correctFloat4, crisp: crisp5, defined: defined12, destroyObjectProperties: destroyObjectProperties6, diffObjects: diffObjects2, erase: erase7, error: error5, extend: extend17, find: find3, fireEvent: fireEvent11, getClosestDistance: getClosestDistance3, getNestedProperty: getNestedProperty4, insertItem: insertItem3, isArray: isArray9, isNumber: isNumber16, isString: isString8, merge: merge16, objectEach: objectEach13, pick: pick19, removeEvent: removeEvent6, splat: splat7, syncTimeout: syncTimeout6 } = Utilities_default;

class Series {
  constructor() {
    this.zoneAxis = "y";
  }
  init(chart, userOptions) {
    fireEvent11(this, "init", { options: userOptions });
    const series = this, chartSeries = chart.series;
    this.eventsToUnbind = [];
    series.chart = chart;
    series.options = series.setOptions(userOptions);
    const options = series.options, visible = options.visible !== false;
    series.linkedSeries = [];
    series.bindAxes();
    extend17(series, {
      name: options.name,
      state: "",
      visible,
      selected: options.selected === true
    });
    registerEventOptions2(this, options);
    const events = options.events;
    if (events && events.click || options.point && options.point.events && options.point.events.click || options.allowPointSelect) {
      chart.runTrackerClick = true;
    }
    series.getColor();
    series.getSymbol();
    series.parallelArrays.forEach(function(key) {
      if (!series[key + "Data"]) {
        series[key + "Data"] = [];
      }
    });
    if (series.isCartesian) {
      chart.hasCartesianSeries = true;
    }
    let lastSeries;
    if (chartSeries.length) {
      lastSeries = chartSeries[chartSeries.length - 1];
    }
    series._i = pick19(lastSeries && lastSeries._i, -1) + 1;
    series.opacity = series.options.opacity;
    chart.orderItems("series", insertItem3(this, chartSeries));
    if (options.dataSorting && options.dataSorting.enabled) {
      series.setDataSortingOptions();
    } else if (!series.points && !series.data) {
      series.setData(options.data, false);
    }
    fireEvent11(this, "afterInit");
  }
  is(type) {
    return seriesTypes[type] && this instanceof seriesTypes[type];
  }
  bindAxes() {
    const series = this, seriesOptions = series.options, chart = series.chart;
    let axisOptions;
    fireEvent11(this, "bindAxes", null, function() {
      (series.axisTypes || []).forEach(function(coll) {
        (chart[coll] || []).forEach(function(axis) {
          axisOptions = axis.options;
          if (pick19(seriesOptions[coll], 0) === axis.index || typeof seriesOptions[coll] !== "undefined" && seriesOptions[coll] === axisOptions.id) {
            insertItem3(series, axis.series);
            series[coll] = axis;
            axis.isDirty = true;
          }
        });
        if (!series[coll] && series.optionalAxis !== coll) {
          error5(18, true, chart);
        }
      });
    });
    fireEvent11(this, "afterBindAxes");
  }
  updateParallelArrays(point, i, iArgs) {
    const series = point.series, fn = isNumber16(i) ? function(key) {
      const val = key === "y" && series.toYData ? series.toYData(point) : point[key];
      series[key + "Data"][i] = val;
    } : function(key) {
      Array.prototype[i].apply(series[key + "Data"], iArgs);
    };
    series.parallelArrays.forEach(fn);
  }
  hasData() {
    return this.visible && typeof this.dataMax !== "undefined" && typeof this.dataMin !== "undefined" || this.visible && this.yData && this.yData.length > 0;
  }
  hasMarkerChanged(options, oldOptions) {
    const marker = options.marker, oldMarker = oldOptions.marker || {};
    return marker && (oldMarker.enabled && !marker.enabled || oldMarker.symbol !== marker.symbol || oldMarker.height !== marker.height || oldMarker.width !== marker.width);
  }
  autoIncrement(x) {
    const options = this.options, pointIntervalUnit = options.pointIntervalUnit, relativeXValue = options.relativeXValue, time = this.chart.time;
    let xIncrement = this.xIncrement, date, pointInterval;
    xIncrement = pick19(xIncrement, options.pointStart, 0);
    this.pointInterval = pointInterval = pick19(this.pointInterval, options.pointInterval, 1);
    if (relativeXValue && isNumber16(x)) {
      pointInterval *= x;
    }
    if (pointIntervalUnit) {
      date = new time.Date(xIncrement);
      if (pointIntervalUnit === "day") {
        time.set("Date", date, time.get("Date", date) + pointInterval);
      } else if (pointIntervalUnit === "month") {
        time.set("Month", date, time.get("Month", date) + pointInterval);
      } else if (pointIntervalUnit === "year") {
        time.set("FullYear", date, time.get("FullYear", date) + pointInterval);
      }
      pointInterval = date.getTime() - xIncrement;
    }
    if (relativeXValue && isNumber16(x)) {
      return xIncrement + pointInterval;
    }
    this.xIncrement = xIncrement + pointInterval;
    return xIncrement;
  }
  setDataSortingOptions() {
    const options = this.options;
    extend17(this, {
      requireSorting: false,
      sorted: false,
      enabledDataSorting: true,
      allowDG: false
    });
    if (!defined12(options.pointRange)) {
      options.pointRange = 1;
    }
  }
  setOptions(itemOptions) {
    const chart = this.chart, chartOptions = chart.options, plotOptions = chartOptions.plotOptions, userOptions = chart.userOptions || {}, seriesUserOptions = merge16(itemOptions), styledMode = chart.styledMode, e = {
      plotOptions,
      userOptions: seriesUserOptions
    };
    let zone;
    fireEvent11(this, "setOptions", e);
    const typeOptions = e.plotOptions[this.type], userPlotOptions = userOptions.plotOptions || {}, userPlotOptionsSeries = userPlotOptions.series || {}, defaultPlotOptionsType = defaultOptions7.plotOptions[this.type] || {}, userPlotOptionsType = userPlotOptions[this.type] || {};
    this.userOptions = e.userOptions;
    const options = merge16(typeOptions, plotOptions.series, userPlotOptionsType, seriesUserOptions);
    this.tooltipOptions = merge16(defaultOptions7.tooltip, defaultOptions7.plotOptions.series?.tooltip, defaultPlotOptionsType?.tooltip, chart.userOptions.tooltip, userPlotOptions.series?.tooltip, userPlotOptionsType.tooltip, seriesUserOptions.tooltip);
    this.stickyTracking = pick19(seriesUserOptions.stickyTracking, userPlotOptionsType.stickyTracking, userPlotOptionsSeries.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : options.stickyTracking);
    if (typeOptions.marker === null) {
      delete options.marker;
    }
    this.zoneAxis = options.zoneAxis || "y";
    const zones = this.zones = (options.zones || []).map((z) => ({ ...z }));
    if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
      zone = {
        value: options[this.zoneAxis + "Threshold"] || options.threshold || 0,
        className: "highcharts-negative"
      };
      if (!styledMode) {
        zone.color = options.negativeColor;
        zone.fillColor = options.negativeFillColor;
      }
      zones.push(zone);
    }
    if (zones.length && defined12(zones[zones.length - 1].value)) {
      zones.push(styledMode ? {} : {
        color: this.color,
        fillColor: this.fillColor
      });
    }
    fireEvent11(this, "afterSetOptions", { options });
    return options;
  }
  getName() {
    return pick19(this.options.name, "Series " + (this.index + 1));
  }
  getCyclic(prop, value, defaults) {
    const chart = this.chart, indexName = `${prop}Index`, counterName = `${prop}Counter`, len = defaults?.length || chart.options.chart.colorCount;
    let i, setting;
    if (!value) {
      setting = pick19(prop === "color" ? this.options.colorIndex : undefined, this[indexName]);
      if (defined12(setting)) {
        i = setting;
      } else {
        if (!chart.series.length) {
          chart[counterName] = 0;
        }
        i = chart[counterName] % len;
        chart[counterName] += 1;
      }
      if (defaults) {
        value = defaults[i];
      }
    }
    if (typeof i !== "undefined") {
      this[indexName] = i;
    }
    this[prop] = value;
  }
  getColor() {
    if (this.chart.styledMode) {
      this.getCyclic("color");
    } else if (this.options.colorByPoint) {
      this.color = "#cccccc";
    } else {
      this.getCyclic("color", this.options.color || defaultOptions7.plotOptions[this.type].color, this.chart.options.colors);
    }
  }
  getPointsCollection() {
    return (this.hasGroupedData ? this.points : this.data) || [];
  }
  getSymbol() {
    const seriesMarkerOption = this.options.marker;
    this.getCyclic("symbol", seriesMarkerOption.symbol, this.chart.options.symbols);
  }
  findPointIndex(optionsObject, fromIndex) {
    const { id, x } = optionsObject, oldData = this.points, dataSorting = this.options.dataSorting;
    let matchingPoint, matchedById, pointIndex;
    if (id) {
      const item = this.chart.get(id);
      if (item instanceof Point_default) {
        matchingPoint = item;
      }
    } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
      let matcher = (oldPoint) => !oldPoint.touched && oldPoint.index === optionsObject.index;
      if (dataSorting && dataSorting.matchByName) {
        matcher = (oldPoint) => !oldPoint.touched && oldPoint.name === optionsObject.name;
      } else if (this.options.relativeXValue) {
        matcher = (oldPoint) => !oldPoint.touched && oldPoint.options.x === optionsObject.x;
      }
      matchingPoint = find3(oldData, matcher);
      if (!matchingPoint) {
        return;
      }
    }
    if (matchingPoint) {
      pointIndex = matchingPoint && matchingPoint.index;
      if (typeof pointIndex !== "undefined") {
        matchedById = true;
      }
    }
    if (typeof pointIndex === "undefined" && isNumber16(x)) {
      pointIndex = this.xData.indexOf(x, fromIndex);
    }
    if (pointIndex !== -1 && typeof pointIndex !== "undefined" && this.cropped) {
      pointIndex = pointIndex >= this.cropStart ? pointIndex - this.cropStart : pointIndex;
    }
    if (!matchedById && isNumber16(pointIndex) && oldData[pointIndex] && oldData[pointIndex].touched) {
      pointIndex = undefined;
    }
    return pointIndex;
  }
  updateData(data, animation) {
    const options = this.options, dataSorting = options.dataSorting, oldData = this.points, pointsToAdd = [], requireSorting = this.requireSorting, equalLength = data.length === oldData.length;
    let hasUpdatedByKey, i, point, lastIndex, succeeded = true;
    this.xIncrement = null;
    data.forEach(function(pointOptions, i2) {
      const optionsObject = defined12(pointOptions) && this.pointClass.prototype.optionsToObject.call({ series: this }, pointOptions) || {};
      let pointIndex;
      const { x, id } = optionsObject;
      if (id || isNumber16(x)) {
        pointIndex = this.findPointIndex(optionsObject, lastIndex);
        if (pointIndex === -1 || typeof pointIndex === "undefined") {
          pointsToAdd.push(pointOptions);
        } else if (oldData[pointIndex] && pointOptions !== options.data[pointIndex]) {
          oldData[pointIndex].update(pointOptions, false, null, false);
          oldData[pointIndex].touched = true;
          if (requireSorting) {
            lastIndex = pointIndex + 1;
          }
        } else if (oldData[pointIndex]) {
          oldData[pointIndex].touched = true;
        }
        if (!equalLength || i2 !== pointIndex || dataSorting && dataSorting.enabled || this.hasDerivedData) {
          hasUpdatedByKey = true;
        }
      } else {
        pointsToAdd.push(pointOptions);
      }
    }, this);
    if (hasUpdatedByKey) {
      i = oldData.length;
      while (i--) {
        point = oldData[i];
        if (point && !point.touched && point.remove) {
          point.remove(false, animation);
        }
      }
    } else if (equalLength && (!dataSorting || !dataSorting.enabled)) {
      data.forEach(function(point2, i2) {
        if (point2 !== oldData[i2].y && !oldData[i2].destroyed) {
          oldData[i2].update(point2, false, null, false);
        }
      });
      pointsToAdd.length = 0;
    } else {
      succeeded = false;
    }
    oldData.forEach(function(point2) {
      if (point2) {
        point2.touched = false;
      }
    });
    if (!succeeded) {
      return false;
    }
    pointsToAdd.forEach(function(point2) {
      this.addPoint(point2, false, null, null, false);
    }, this);
    if (this.xIncrement === null && this.xData && this.xData.length) {
      this.xIncrement = arrayMax4(this.xData);
      this.autoIncrement();
    }
    return true;
  }
  setData(data, redraw = true, animation, updatePoints) {
    const series = this, oldData = series.points, oldDataLength = oldData && oldData.length || 0, options = series.options, chart = series.chart, dataSorting = options.dataSorting, xAxis2 = series.xAxis, turboThreshold = options.turboThreshold, xData = this.xData, yData = this.yData, pointArrayMap = series.pointArrayMap, valueCount = pointArrayMap && pointArrayMap.length, keys2 = options.keys;
    let i, pt, updatedData, indexOfX = 0, indexOfY = 1, copiedData;
    if (!chart.options.chart.allowMutatingData) {
      if (options.data) {
        delete series.options.data;
      }
      if (series.userOptions.data) {
        delete series.userOptions.data;
      }
      copiedData = merge16(true, data);
    }
    data = copiedData || data || [];
    const dataLength = data.length;
    if (dataSorting && dataSorting.enabled) {
      data = this.sortData(data);
    }
    if (chart.options.chart.allowMutatingData && updatePoints !== false && dataLength && oldDataLength && !series.cropped && !series.hasGroupedData && series.visible && !series.boosted) {
      updatedData = this.updateData(data, animation);
    }
    if (!updatedData) {
      series.xIncrement = null;
      series.colorCounter = 0;
      this.parallelArrays.forEach(function(key) {
        series[key + "Data"].length = 0;
      });
      let runTurbo = turboThreshold && dataLength > turboThreshold;
      if (runTurbo) {
        const firstPoint = series.getFirstValidPoint(data), lastPoint = series.getFirstValidPoint(data, dataLength - 1, -1), isShortArray = (a) => Boolean(isArray9(a) && (keys2 || isNumber16(a[0])));
        if (isNumber16(firstPoint) && isNumber16(lastPoint)) {
          for (i = 0;i < dataLength; i++) {
            xData[i] = this.autoIncrement();
            yData[i] = data[i];
          }
        } else if (isShortArray(firstPoint) && isShortArray(lastPoint)) {
          if (valueCount) {
            if (firstPoint.length === valueCount) {
              for (i = 0;i < dataLength; i++) {
                xData[i] = this.autoIncrement();
                yData[i] = data[i];
              }
            } else {
              for (i = 0;i < dataLength; i++) {
                pt = data[i];
                xData[i] = pt[0];
                yData[i] = pt.slice(1, valueCount + 1);
              }
            }
          } else {
            if (keys2) {
              indexOfX = keys2.indexOf("x");
              indexOfY = keys2.indexOf("y");
              indexOfX = indexOfX >= 0 ? indexOfX : 0;
              indexOfY = indexOfY >= 0 ? indexOfY : 1;
            }
            if (firstPoint.length === 1) {
              indexOfY = 0;
            }
            if (indexOfX === indexOfY) {
              for (i = 0;i < dataLength; i++) {
                xData[i] = this.autoIncrement();
                yData[i] = data[i][indexOfY];
              }
            } else {
              for (i = 0;i < dataLength; i++) {
                pt = data[i];
                xData[i] = pt[indexOfX];
                yData[i] = pt[indexOfY];
              }
            }
          }
        } else {
          runTurbo = false;
        }
      }
      if (!runTurbo) {
        for (i = 0;i < dataLength; i++) {
          pt = { series };
          series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
          series.updateParallelArrays(pt, i);
        }
      }
      if (yData && isString8(yData[0])) {
        error5(14, true, chart);
      }
      series.data = [];
      series.options.data = series.userOptions.data = data;
      i = oldDataLength;
      while (i--) {
        oldData[i]?.destroy();
      }
      if (xAxis2) {
        xAxis2.minRange = xAxis2.userMinRange;
      }
      series.isDirty = chart.isDirtyBox = true;
      series.isDirtyData = !!oldData;
      animation = false;
    }
    if (options.legendType === "point") {
      this.processData();
      this.generatePoints();
    }
    if (redraw) {
      chart.redraw(animation);
    }
  }
  sortData(data) {
    const series = this, options = series.options, dataSorting = options.dataSorting, sortKey = dataSorting.sortKey || "y", getPointOptionsObject = function(series2, pointOptions) {
      return defined12(pointOptions) && series2.pointClass.prototype.optionsToObject.call({
        series: series2
      }, pointOptions) || {};
    };
    data.forEach(function(pointOptions, i) {
      data[i] = getPointOptionsObject(series, pointOptions);
      data[i].index = i;
    }, this);
    const sortedData = data.concat().sort((a, b) => {
      const aValue = getNestedProperty4(sortKey, a);
      const bValue = getNestedProperty4(sortKey, b);
      return bValue < aValue ? -1 : bValue > aValue ? 1 : 0;
    });
    sortedData.forEach(function(point, i) {
      point.x = i;
    }, this);
    if (series.linkedSeries) {
      series.linkedSeries.forEach(function(linkedSeries) {
        const options2 = linkedSeries.options, seriesData = options2.data;
        if ((!options2.dataSorting || !options2.dataSorting.enabled) && seriesData) {
          seriesData.forEach(function(pointOptions, i) {
            seriesData[i] = getPointOptionsObject(linkedSeries, pointOptions);
            if (data[i]) {
              seriesData[i].x = data[i].x;
              seriesData[i].index = i;
            }
          });
          linkedSeries.setData(seriesData, false);
        }
      });
    }
    return data;
  }
  getProcessedData(forceExtremesFromAll) {
    const series = this, xAxis2 = series.xAxis, options = series.options, cropThreshold = options.cropThreshold, logarithmic = xAxis2?.logarithmic, isCartesian = series.isCartesian;
    let croppedData, cropped, cropStart = 0, xExtremes, min, max, processedXData = series.xData, processedYData = series.yData, updatingNames = false;
    const dataLength = processedXData.length;
    if (xAxis2) {
      xExtremes = xAxis2.getExtremes();
      min = xExtremes.min;
      max = xExtremes.max;
      updatingNames = !!(xAxis2.categories && !xAxis2.names.length);
    }
    if (isCartesian && series.sorted && !forceExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
      if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
        processedXData = [];
        processedYData = [];
      } else if (series.yData && (processedXData[0] < min || processedXData[dataLength - 1] > max)) {
        croppedData = this.cropData(series.xData, series.yData, min, max);
        processedXData = croppedData.xData;
        processedYData = croppedData.yData;
        cropStart = croppedData.start;
        cropped = true;
      }
    }
    const closestPointRange = getClosestDistance3([
      logarithmic ? processedXData.map(logarithmic.log2lin) : processedXData
    ], () => series.requireSorting && !updatingNames && error5(15, false, series.chart));
    return {
      xData: processedXData,
      yData: processedYData,
      cropped,
      cropStart,
      closestPointRange
    };
  }
  processData(force) {
    const series = this, xAxis2 = series.xAxis;
    if (series.isCartesian && !series.isDirty && !xAxis2.isDirty && !series.yAxis.isDirty && !force) {
      return false;
    }
    const processedData = series.getProcessedData();
    series.cropped = processedData.cropped;
    series.cropStart = processedData.cropStart;
    series.processedXData = processedData.xData;
    series.processedYData = processedData.yData;
    series.closestPointRange = series.basePointRange = processedData.closestPointRange;
    fireEvent11(series, "afterProcessData");
  }
  cropData(xData, yData, min, max) {
    const dataLength = xData.length;
    let i, j, start = 0, end = dataLength;
    for (i = 0;i < dataLength; i++) {
      if (xData[i] >= min) {
        start = Math.max(0, i - 1);
        break;
      }
    }
    for (j = i;j < dataLength; j++) {
      if (xData[j] > max) {
        end = j + 1;
        break;
      }
    }
    return {
      xData: xData.slice(start, end),
      yData: yData.slice(start, end),
      start,
      end
    };
  }
  generatePoints() {
    const series = this, options = series.options, dataOptions = series.processedData || options.data, processedXData = series.processedXData, processedYData = series.processedYData, PointClass = series.pointClass, processedDataLength = processedXData.length, cropStart = series.cropStart || 0, hasGroupedData = series.hasGroupedData, keys2 = options.keys, points = [], groupCropStartIndex = options.dataGrouping && options.dataGrouping.groupAll ? cropStart : 0;
    let dataLength, cursor, point, i, data = series.data;
    if (!data && !hasGroupedData) {
      const arr = [];
      arr.length = dataOptions.length;
      data = series.data = arr;
    }
    if (keys2 && hasGroupedData) {
      series.options.keys = false;
    }
    for (i = 0;i < processedDataLength; i++) {
      cursor = cropStart + i;
      if (!hasGroupedData) {
        point = data[cursor];
        if (!point && typeof dataOptions[cursor] !== "undefined") {
          data[cursor] = point = new PointClass(series, dataOptions[cursor], processedXData[i]);
        }
      } else {
        point = new PointClass(series, [processedXData[i]].concat(splat7(processedYData[i])));
        point.dataGroup = series.groupMap[groupCropStartIndex + i];
        if (point.dataGroup.options) {
          point.options = point.dataGroup.options;
          extend17(point, point.dataGroup.options);
          delete point.dataLabels;
        }
      }
      if (point) {
        point.index = hasGroupedData ? groupCropStartIndex + i : cursor;
        points[i] = point;
      }
    }
    series.options.keys = keys2;
    if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
      for (i = 0;i < dataLength; i++) {
        if (i === cropStart && !hasGroupedData) {
          i += processedDataLength;
        }
        if (data[i]) {
          data[i].destroyElements();
          data[i].plotX = undefined;
        }
      }
    }
    series.data = data;
    series.points = points;
    fireEvent11(this, "afterGeneratePoints");
  }
  getXExtremes(xData) {
    return {
      min: arrayMin4(xData),
      max: arrayMax4(xData)
    };
  }
  getExtremes(yData, forceExtremesFromAll) {
    const xAxis2 = this.xAxis, yAxis2 = this.yAxis, activeYData = [], shoulder = this.requireSorting && !this.is("column") ? 1 : 0, positiveValuesOnly = yAxis2 ? yAxis2.positiveValuesOnly : false, getExtremesFromAll = forceExtremesFromAll || this.getExtremesFromAll || this.options.getExtremesFromAll;
    let { processedXData, processedYData } = this, xExtremes, validValue, withinRange, x, y, i, j, xMin = 0, xMax = 0, activeCounter = 0;
    if (this.cropped && getExtremesFromAll) {
      const processedData = this.getProcessedData(true);
      processedXData = processedData.xData;
      processedYData = processedData.yData;
    }
    yData = yData || this.stackedYData || processedYData || [];
    const yDataLength = yData.length, xData = processedXData || this.xData;
    if (xAxis2) {
      xExtremes = xAxis2.getExtremes();
      xMin = xExtremes.min;
      xMax = xExtremes.max;
    }
    for (i = 0;i < yDataLength; i++) {
      x = xData[i];
      y = yData[i];
      validValue = (isNumber16(y) || isArray9(y)) && ((isNumber16(y) ? y > 0 : y.length) || !positiveValuesOnly);
      withinRange = forceExtremesFromAll || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !xAxis2 || (xData[i + shoulder] || x) >= xMin && (xData[i - shoulder] || x) <= xMax;
      if (validValue && withinRange) {
        j = y.length;
        if (j) {
          while (j--) {
            if (isNumber16(y[j])) {
              activeYData[activeCounter++] = y[j];
            }
          }
        } else {
          activeYData[activeCounter++] = y;
        }
      }
    }
    const dataExtremes = {
      activeYData,
      dataMin: arrayMin4(activeYData),
      dataMax: arrayMax4(activeYData)
    };
    fireEvent11(this, "afterGetExtremes", { dataExtremes });
    return dataExtremes;
  }
  applyExtremes() {
    const dataExtremes = this.getExtremes();
    this.dataMin = dataExtremes.dataMin;
    this.dataMax = dataExtremes.dataMax;
    return dataExtremes;
  }
  getFirstValidPoint(data, start = 0, increment = 1) {
    const dataLength = data.length;
    let i = start;
    while (i >= 0 && i < dataLength) {
      if (defined12(data[i])) {
        return data[i];
      }
      i += increment;
    }
  }
  translate() {
    if (!this.processedXData) {
      this.processData();
    }
    this.generatePoints();
    const series = this, options = series.options, stacking = options.stacking, xAxis2 = series.xAxis, categories = xAxis2.categories, enabledDataSorting = series.enabledDataSorting, yAxis2 = series.yAxis, points = series.points, dataLength = points.length, pointPlacement = series.pointPlacementToXValue(), dynamicallyPlaced = Boolean(pointPlacement), threshold = options.threshold, stackThreshold = options.startFromThreshold ? threshold : 0;
    let i, plotX, lastPlotX, stackIndicator, closestPointRangePx = Number.MAX_VALUE;
    function limitedRange(val) {
      return clamp6(val, -1e5, 1e5);
    }
    for (i = 0;i < dataLength; i++) {
      const point = points[i], xValue = point.x;
      let stackItem, stackValues, yValue = point.y, lowValue = point.low;
      const stacks = stacking && yAxis2.stacking?.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? "-" : "") + series.stackKey];
      plotX = xAxis2.translate(xValue, false, false, false, true, pointPlacement);
      point.plotX = isNumber16(plotX) ? correctFloat4(limitedRange(plotX)) : undefined;
      if (stacking && series.visible && stacks && stacks[xValue]) {
        stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
        if (!point.isNull && stackIndicator.key) {
          stackItem = stacks[xValue];
          stackValues = stackItem.points[stackIndicator.key];
        }
        if (stackItem && isArray9(stackValues)) {
          lowValue = stackValues[0];
          yValue = stackValues[1];
          if (lowValue === stackThreshold && stackIndicator.key === stacks[xValue].base) {
            lowValue = pick19(isNumber16(threshold) ? threshold : yAxis2.min);
          }
          if (yAxis2.positiveValuesOnly && defined12(lowValue) && lowValue <= 0) {
            lowValue = undefined;
          }
          point.total = point.stackTotal = pick19(stackItem.total);
          point.percentage = defined12(point.y) && stackItem.total ? point.y / stackItem.total * 100 : undefined;
          point.stackY = yValue;
          if (!series.irregularWidths) {
            stackItem.setOffset(series.pointXOffset || 0, series.barW || 0, undefined, undefined, undefined, series.xAxis);
          }
        }
      }
      point.yBottom = defined12(lowValue) ? limitedRange(yAxis2.translate(lowValue, false, true, false, true)) : undefined;
      if (series.dataModify) {
        yValue = series.dataModify.modifyValue(yValue, i);
      }
      let plotY;
      if (isNumber16(yValue) && point.plotX !== undefined) {
        plotY = yAxis2.translate(yValue, false, true, false, true);
        plotY = isNumber16(plotY) ? limitedRange(plotY) : undefined;
      }
      point.plotY = plotY;
      point.isInside = this.isPointInside(point);
      point.clientX = dynamicallyPlaced ? correctFloat4(xAxis2.translate(xValue, false, false, false, true, pointPlacement)) : plotX;
      point.negative = (point.y || 0) < (threshold || 0);
      point.category = pick19(categories && categories[point.x], point.x);
      if (!point.isNull && point.visible !== false) {
        if (typeof lastPlotX !== "undefined") {
          closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));
        }
        lastPlotX = plotX;
      }
      point.zone = this.zones.length ? point.getZone() : undefined;
      if (!point.graphic && series.group && enabledDataSorting) {
        point.isNew = true;
      }
    }
    series.closestPointRangePx = closestPointRangePx;
    fireEvent11(this, "afterTranslate");
  }
  getValidPoints(points, insideOnly, allowNull) {
    const chart = this.chart;
    return (points || this.points || []).filter(function(point) {
      const { plotX, plotY } = point, asNull = !allowNull && (point.isNull || !isNumber16(plotY));
      if (asNull || insideOnly && !chart.isInsidePlot(plotX, plotY, { inverted: chart.inverted })) {
        return false;
      }
      return point.visible !== false;
    });
  }
  getClipBox() {
    const { chart, xAxis: xAxis2, yAxis: yAxis2 } = this;
    let { x, y, width, height } = merge16(chart.clipBox);
    if (xAxis2 && xAxis2.len !== chart.plotSizeX) {
      width = xAxis2.len;
    }
    if (yAxis2 && yAxis2.len !== chart.plotSizeY) {
      height = yAxis2.len;
    }
    if (chart.inverted && !this.invertible) {
      [width, height] = [height, width];
    }
    return { x, y, width, height };
  }
  getSharedClipKey() {
    this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
    return this.sharedClipKey;
  }
  setClip() {
    const { chart, group, markerGroup } = this, sharedClips = chart.sharedClips, renderer = chart.renderer, clipBox = this.getClipBox(), sharedClipKey = this.getSharedClipKey();
    let clipRect = sharedClips[sharedClipKey];
    if (!clipRect) {
      sharedClips[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
    } else {
      clipRect.animate(clipBox);
    }
    if (group) {
      group.clip(this.options.clip === false ? undefined : clipRect);
    }
    if (markerGroup) {
      markerGroup.clip();
    }
  }
  animate(init) {
    const { chart, group, markerGroup } = this, inverted = chart.inverted, animation = animObject6(this.options.animation), animationClipKey = [
      this.getSharedClipKey(),
      animation.duration,
      animation.easing,
      animation.defer
    ].join(",");
    let animationClipRect = chart.sharedClips[animationClipKey], markerAnimationClipRect = chart.sharedClips[animationClipKey + "m"];
    if (init && group) {
      const clipBox = this.getClipBox();
      if (!animationClipRect) {
        clipBox.width = 0;
        if (inverted) {
          clipBox.x = chart.plotHeight;
        }
        animationClipRect = chart.renderer.clipRect(clipBox);
        chart.sharedClips[animationClipKey] = animationClipRect;
        const markerClipBox = {
          x: inverted ? -99 : -99,
          y: inverted ? -99 : -99,
          width: inverted ? chart.plotWidth + 199 : 99,
          height: inverted ? 99 : chart.plotHeight + 199
        };
        markerAnimationClipRect = chart.renderer.clipRect(markerClipBox);
        chart.sharedClips[animationClipKey + "m"] = markerAnimationClipRect;
      } else {
        animationClipRect.attr("height", clipBox.height);
      }
      group.clip(animationClipRect);
      markerGroup?.clip(markerAnimationClipRect);
    } else if (animationClipRect && !animationClipRect.hasClass("highcharts-animating")) {
      const finalBox = this.getClipBox(), step = animation.step;
      if (markerGroup?.element.childNodes.length || chart.series.length > 1) {
        animation.step = function(val, fx) {
          if (step) {
            step.apply(fx, arguments);
          }
          if (fx.prop === "width" && markerAnimationClipRect?.element) {
            markerAnimationClipRect.attr(inverted ? "height" : "width", val + 99);
          }
        };
      }
      animationClipRect.addClass("highcharts-animating").animate(finalBox, animation);
    }
  }
  afterAnimate() {
    this.setClip();
    objectEach13(this.chart.sharedClips, (clip, key, sharedClips) => {
      if (clip && !this.chart.container.querySelector(`[clip-path="url(#${clip.id})"]`)) {
        clip.destroy();
        delete sharedClips[key];
      }
    });
    this.finishedAnimating = true;
    fireEvent11(this, "afterAnimate");
  }
  drawPoints(points = this.points) {
    const series = this, chart = series.chart, styledMode = chart.styledMode, { colorAxis, options } = series, seriesMarkerOptions = options.marker, markerGroup = series[series.specialGroup || "markerGroup"], xAxis2 = series.xAxis, globallyEnabled = pick19(seriesMarkerOptions.enabled, !xAxis2 || xAxis2.isRadial ? true : null, series.closestPointRangePx >= seriesMarkerOptions.enabledThreshold * seriesMarkerOptions.radius);
    let i, point, graphic, verb, pointMarkerOptions, hasPointMarker, markerAttribs;
    if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {
      for (i = 0;i < points.length; i++) {
        point = points[i];
        graphic = point.graphic;
        verb = graphic ? "animate" : "attr";
        pointMarkerOptions = point.marker || {};
        hasPointMarker = !!point.marker;
        const shouldDrawMarker = (globallyEnabled && typeof pointMarkerOptions.enabled === "undefined" || pointMarkerOptions.enabled) && !point.isNull && point.visible !== false;
        if (shouldDrawMarker) {
          const symbol = pick19(pointMarkerOptions.symbol, series.symbol, "rect");
          markerAttribs = series.markerAttribs(point, point.selected && "select");
          if (series.enabledDataSorting) {
            point.startXPos = xAxis2.reversed ? -(markerAttribs.width || 0) : xAxis2.width;
          }
          const isInside = point.isInside !== false;
          if (!graphic && isInside && ((markerAttribs.width || 0) > 0 || point.hasImage)) {
            point.graphic = graphic = chart.renderer.symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ? pointMarkerOptions : seriesMarkerOptions).add(markerGroup);
            if (series.enabledDataSorting && chart.hasRendered) {
              graphic.attr({
                x: point.startXPos
              });
              verb = "animate";
            }
          }
          if (graphic && verb === "animate") {
            graphic[isInside ? "show" : "hide"](isInside).animate(markerAttribs);
          }
          if (graphic) {
            const pointAttr = series.pointAttribs(point, styledMode || !point.selected ? undefined : "select");
            if (!styledMode) {
              graphic[verb](pointAttr);
            } else if (colorAxis) {
              graphic["css"]({
                fill: pointAttr.fill
              });
            }
          }
          if (graphic) {
            graphic.addClass(point.getClassName(), true);
          }
        } else if (graphic) {
          point.graphic = graphic.destroy();
        }
      }
    }
  }
  markerAttribs(point, state) {
    const seriesOptions = this.options, seriesMarkerOptions = seriesOptions.marker, pointMarkerOptions = point.marker || {}, symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol, attribs = {};
    let seriesStateOptions, pointStateOptions, radius = pick19(pointMarkerOptions.radius, seriesMarkerOptions && seriesMarkerOptions.radius);
    if (state) {
      seriesStateOptions = seriesMarkerOptions.states[state];
      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state];
      radius = pick19(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius && radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0));
    }
    point.hasImage = symbol && symbol.indexOf("url") === 0;
    if (point.hasImage) {
      radius = 0;
    }
    const pos = point.pos();
    if (isNumber16(radius) && pos) {
      if (seriesOptions.crisp) {
        pos[0] = crisp5(pos[0], point.hasImage ? 0 : symbol === "rect" ? seriesMarkerOptions?.lineWidth || 0 : 1);
      }
      attribs.x = pos[0] - radius;
      attribs.y = pos[1] - radius;
    }
    if (radius) {
      attribs.width = attribs.height = 2 * radius;
    }
    return attribs;
  }
  pointAttribs(point, state) {
    const seriesMarkerOptions = this.options.marker, pointOptions = point && point.options, pointMarkerOptions = pointOptions && pointOptions.marker || {}, pointColorOption = pointOptions && pointOptions.color, pointColor = point && point.color, zoneColor = point && point.zone && point.zone.color;
    let seriesStateOptions, pointStateOptions, color3 = this.color, fill, stroke, strokeWidth = pick19(pointMarkerOptions.lineWidth, seriesMarkerOptions.lineWidth), opacity = 1;
    color3 = pointColorOption || zoneColor || pointColor || color3;
    fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color3;
    stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color3;
    state = state || "normal";
    if (state) {
      seriesStateOptions = seriesMarkerOptions.states[state] || {};
      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
      strokeWidth = pick19(pointStateOptions.lineWidth, seriesStateOptions.lineWidth, strokeWidth + pick19(pointStateOptions.lineWidthPlus, seriesStateOptions.lineWidthPlus, 0));
      fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;
      stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;
      opacity = pick19(pointStateOptions.opacity, seriesStateOptions.opacity, opacity);
    }
    return {
      stroke,
      "stroke-width": strokeWidth,
      fill,
      opacity
    };
  }
  destroy(keepEventsForUpdate) {
    const series = this, chart = series.chart, issue134 = /AppleWebKit\/533/.test(win8.navigator.userAgent), data = series.data || [];
    let destroy, i, point, axis;
    fireEvent11(series, "destroy", { keepEventsForUpdate });
    this.removeEvents(keepEventsForUpdate);
    (series.axisTypes || []).forEach(function(AXIS) {
      axis = series[AXIS];
      if (axis && axis.series) {
        erase7(axis.series, series);
        axis.isDirty = axis.forceRedraw = true;
      }
    });
    if (series.legendItem) {
      series.chart.legend.destroyItem(series);
    }
    i = data.length;
    while (i--) {
      point = data[i];
      if (point && point.destroy) {
        point.destroy();
      }
    }
    for (const zone of series.zones) {
      destroyObjectProperties6(zone, undefined, true);
    }
    Utilities_default.clearTimeout(series.animationTimeout);
    objectEach13(series, function(val, prop) {
      if (val instanceof SVGElement_default && !val.survive) {
        destroy = issue134 && prop === "group" ? "hide" : "destroy";
        val[destroy]();
      }
    });
    if (chart.hoverSeries === series) {
      chart.hoverSeries = undefined;
    }
    erase7(chart.series, series);
    chart.orderItems("series");
    objectEach13(series, function(val, prop) {
      if (!keepEventsForUpdate || prop !== "hcEvents") {
        delete series[prop];
      }
    });
  }
  applyZones() {
    const series = this, { area, chart, graph, zones, points, xAxis: xAxis2, yAxis: yAxis2, zoneAxis } = series, { inverted, renderer } = chart, axis = this[`${zoneAxis}Axis`], { isXAxis, len = 0 } = axis || {}, halfWidth = (graph?.strokeWidth() || 0) / 2 + 1, avoidClose = (zone, plotX = 0, plotY = 0) => {
      if (inverted) {
        plotY = len - plotY;
      }
      const { translated = 0, lineClip } = zone, distance = plotY - translated;
      lineClip?.push([
        "L",
        plotX,
        Math.abs(distance) < halfWidth ? plotY - halfWidth * (distance <= 0 ? -1 : 1) : translated
      ]);
    };
    if (zones.length && (graph || area) && axis && isNumber16(axis.min)) {
      const axisMax = axis.getExtremes().max, invertPath = (path) => {
        path.forEach((segment, i) => {
          if (segment[0] === "M" || segment[0] === "L") {
            path[i] = [
              segment[0],
              isXAxis ? len - segment[1] : segment[1],
              isXAxis ? segment[2] : len - segment[2]
            ];
          }
        });
      };
      zones.forEach((zone) => {
        zone.lineClip = [];
        zone.translated = clamp6(axis.toPixels(pick19(zone.value, axisMax), true) || 0, 0, len);
      });
      if (graph && !this.showLine) {
        graph.hide();
      }
      if (area) {
        area.hide();
      }
      if (zoneAxis === "y" && points.length < xAxis2.len) {
        for (const point of points) {
          const { plotX, plotY, zone } = point, zoneBelow = zone && zones[zones.indexOf(zone) - 1];
          if (zone) {
            avoidClose(zone, plotX, plotY);
          }
          if (zoneBelow) {
            avoidClose(zoneBelow, plotX, plotY);
          }
        }
      }
      let lastLineClip = [], lastTranslated = axis.toPixels(axis.getExtremes().min, true);
      zones.forEach((zone) => {
        const lineClip = zone.lineClip || [], translated = Math.round(zone.translated || 0);
        if (xAxis2.reversed) {
          lineClip.reverse();
        }
        let { clip, simpleClip } = zone, x1 = 0, y1 = 0, x2 = xAxis2.len, y2 = yAxis2.len;
        if (isXAxis) {
          x1 = translated;
          x2 = lastTranslated;
        } else {
          y1 = translated;
          y2 = lastTranslated;
        }
        const simplePath = [
          ["M", x1, y1],
          ["L", x2, y1],
          ["L", x2, y2],
          ["L", x1, y2],
          ["Z"]
        ], adaptivePath = [
          simplePath[0],
          ...lineClip,
          simplePath[1],
          simplePath[2],
          ...lastLineClip,
          simplePath[3],
          simplePath[4]
        ];
        lastLineClip = lineClip.reverse();
        lastTranslated = translated;
        if (inverted) {
          invertPath(adaptivePath);
          if (area) {
            invertPath(simplePath);
          }
        }
        if (clip) {
          clip.animate({ d: adaptivePath });
          simpleClip?.animate({ d: simplePath });
        } else {
          clip = zone.clip = renderer.path(adaptivePath);
          if (area) {
            simpleClip = zone.simpleClip = renderer.path(simplePath);
          }
        }
        if (graph) {
          zone.graph?.clip(clip);
        }
        if (area) {
          zone.area?.clip(simpleClip);
        }
      });
    } else if (series.visible) {
      if (graph) {
        graph.show();
      }
      if (area) {
        area.show();
      }
    }
  }
  plotGroup(prop, name, visibility, zIndex, parent) {
    let group = this[prop];
    const isNew = !group, attrs = {
      visibility,
      zIndex: zIndex || 0.1
    };
    if (defined12(this.opacity) && !this.chart.styledMode && this.state !== "inactive") {
      attrs.opacity = this.opacity;
    }
    if (!group) {
      this[prop] = group = this.chart.renderer.g().add(parent);
    }
    group.addClass("highcharts-" + name + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (defined12(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (group.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
    group.attr(attrs)[isNew ? "attr" : "animate"](this.getPlotBox(name));
    return group;
  }
  getPlotBox(name) {
    let horAxis = this.xAxis, vertAxis = this.yAxis;
    const chart = this.chart, inverted = chart.inverted && !chart.polar && horAxis && this.invertible && name === "series";
    if (chart.inverted) {
      horAxis = vertAxis;
      vertAxis = this.xAxis;
    }
    return {
      translateX: horAxis ? horAxis.left : chart.plotLeft,
      translateY: vertAxis ? vertAxis.top : chart.plotTop,
      rotation: inverted ? 90 : 0,
      rotationOriginX: inverted ? (horAxis.len - vertAxis.len) / 2 : 0,
      rotationOriginY: inverted ? (horAxis.len + vertAxis.len) / 2 : 0,
      scaleX: inverted ? -1 : 1,
      scaleY: 1
    };
  }
  removeEvents(keepEventsForUpdate) {
    const { eventsToUnbind } = this;
    if (!keepEventsForUpdate) {
      removeEvent6(this);
    }
    if (eventsToUnbind.length) {
      eventsToUnbind.forEach((unbind) => {
        unbind();
      });
      eventsToUnbind.length = 0;
    }
  }
  render() {
    const series = this, { chart, options, hasRendered } = series, animOptions = animObject6(options.animation), visibility = series.visible ? "inherit" : "hidden", zIndex = options.zIndex, chartSeriesGroup = chart.seriesGroup;
    let animDuration = series.finishedAnimating ? 0 : animOptions.duration;
    fireEvent11(this, "render");
    series.plotGroup("group", "series", visibility, zIndex, chartSeriesGroup);
    series.markerGroup = series.plotGroup("markerGroup", "markers", visibility, zIndex, chartSeriesGroup);
    if (options.clip !== false) {
      series.setClip();
    }
    if (animDuration) {
      series.animate?.(true);
    }
    if (series.drawGraph) {
      series.drawGraph();
      series.applyZones();
    }
    if (series.visible) {
      series.drawPoints();
    }
    series.drawDataLabels?.();
    series.redrawPoints?.();
    if (options.enableMouseTracking) {
      series.drawTracker?.();
    }
    if (animDuration) {
      series.animate?.();
    }
    if (!hasRendered) {
      if (animDuration && animOptions.defer) {
        animDuration += animOptions.defer;
      }
      series.animationTimeout = syncTimeout6(() => {
        series.afterAnimate();
      }, animDuration || 0);
    }
    series.isDirty = false;
    series.hasRendered = true;
    fireEvent11(series, "afterRender");
  }
  redraw() {
    const wasDirty = this.isDirty || this.isDirtyData;
    this.translate();
    this.render();
    if (wasDirty) {
      delete this.kdTree;
    }
  }
  reserveSpace() {
    return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
  }
  searchPoint(e, compareX) {
    const { xAxis: xAxis2, yAxis: yAxis2 } = this, inverted = this.chart.inverted;
    return this.searchKDTree({
      clientX: inverted ? xAxis2.len - e.chartY + xAxis2.pos : e.chartX - xAxis2.pos,
      plotY: inverted ? yAxis2.len - e.chartX + yAxis2.pos : e.chartY - yAxis2.pos
    }, compareX, e);
  }
  buildKDTree(e) {
    this.buildingKdTree = true;
    const series = this, dimensions = series.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
    function kdtree(points, depth, dimensions2) {
      const length = points?.length;
      let axis, median;
      if (length) {
        axis = series.kdAxisArray[depth % dimensions2];
        points.sort((a, b) => (a[axis] || 0) - (b[axis] || 0));
        median = Math.floor(length / 2);
        return {
          point: points[median],
          left: kdtree(points.slice(0, median), depth + 1, dimensions2),
          right: kdtree(points.slice(median + 1), depth + 1, dimensions2)
        };
      }
    }
    function startRecursive() {
      series.kdTree = kdtree(series.getValidPoints(undefined, !series.directTouch), dimensions, dimensions);
      series.buildingKdTree = false;
    }
    delete series.kdTree;
    syncTimeout6(startRecursive, series.options.kdNow || e?.type === "touchstart" ? 0 : 1);
  }
  searchKDTree(point, compareX, e) {
    const series = this, [kdX, kdY] = this.kdAxisArray, kdComparer = compareX ? "distX" : "dist", kdDimensions = (series.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, useRadius = !!series.isBubble;
    function setDistance(p1, p2) {
      const p1kdX = p1[kdX], p2kdX = p2[kdX], x = defined12(p1kdX) && defined12(p2kdX) ? p1kdX - p2kdX : null, p1kdY = p1[kdY], p2kdY = p2[kdY], y = defined12(p1kdY) && defined12(p2kdY) ? p1kdY - p2kdY : 0, radius = useRadius ? p2.marker?.radius || 0 : 0;
      p2.dist = Math.sqrt((x && x * x || 0) + y * y) - radius;
      p2.distX = defined12(x) ? Math.abs(x) - radius : Number.MAX_VALUE;
    }
    function doSearch(search, tree, depth, dimensions) {
      const point2 = tree.point, axis = series.kdAxisArray[depth % dimensions];
      let nPoint1, nPoint2, ret = point2;
      setDistance(search, point2);
      const tdist = (search[axis] || 0) - (point2[axis] || 0) + (useRadius ? point2.marker?.radius || 0 : 0), sideA = tdist < 0 ? "left" : "right", sideB = tdist < 0 ? "right" : "left";
      if (tree[sideA]) {
        nPoint1 = doSearch(search, tree[sideA], depth + 1, dimensions);
        ret = nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point2;
      }
      if (tree[sideB]) {
        if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
          nPoint2 = doSearch(search, tree[sideB], depth + 1, dimensions);
          ret = nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret;
        }
      }
      return ret;
    }
    if (!this.kdTree && !this.buildingKdTree) {
      this.buildKDTree(e);
    }
    if (this.kdTree) {
      return doSearch(point, this.kdTree, kdDimensions, kdDimensions);
    }
  }
  pointPlacementToXValue() {
    const { options, xAxis: xAxis2 } = this;
    let factor = options.pointPlacement;
    if (factor === "between") {
      factor = xAxis2.reversed ? -0.5 : 0.5;
    }
    return isNumber16(factor) ? factor * (options.pointRange || xAxis2.pointRange) : 0;
  }
  isPointInside(point) {
    const { chart, xAxis: xAxis2, yAxis: yAxis2 } = this, { plotX = -1, plotY = -1 } = point, isInside = plotY >= 0 && plotY <= (yAxis2 ? yAxis2.len : chart.plotHeight) && plotX >= 0 && plotX <= (xAxis2 ? xAxis2.len : chart.plotWidth);
    return isInside;
  }
  drawTracker() {
    const series = this, options = series.options, trackByArea = options.trackByArea, trackerPath = [].concat((trackByArea ? series.areaPath : series.graphPath) || []), chart = series.chart, pointer = chart.pointer, renderer = chart.renderer, snap = chart.options.tooltip?.snap || 0, onMouseOver = () => {
      if (options.enableMouseTracking && chart.hoverSeries !== series) {
        series.onMouseOver();
      }
    }, TRACKER_FILL = "rgba(192,192,192," + (svg2 ? 0.0001 : 0.002) + ")";
    let tracker = series.tracker;
    if (tracker) {
      tracker.attr({ d: trackerPath });
    } else if (series.graph) {
      series.tracker = tracker = renderer.path(trackerPath).attr({
        visibility: series.visible ? "inherit" : "hidden",
        zIndex: 2
      }).addClass(trackByArea ? "highcharts-tracker-area" : "highcharts-tracker-line").add(series.group);
      if (!chart.styledMode) {
        tracker.attr({
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          stroke: TRACKER_FILL,
          fill: trackByArea ? TRACKER_FILL : "none",
          "stroke-width": series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap)
        });
      }
      [
        series.tracker,
        series.markerGroup,
        series.dataLabelsGroup
      ].forEach((tracker2) => {
        if (tracker2) {
          tracker2.addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", (e) => {
            pointer?.onTrackerMouseOut(e);
          });
          if (options.cursor && !chart.styledMode) {
            tracker2.css({ cursor: options.cursor });
          }
          tracker2.on("touchstart", onMouseOver);
        }
      });
    }
    fireEvent11(this, "afterDrawTracker");
  }
  addPoint(options, redraw, shift, animation, withEvent) {
    const series = this, seriesOptions = series.options, data = series.data, chart = series.chart, xAxis2 = series.xAxis, names = xAxis2 && xAxis2.hasNames && xAxis2.names, dataOptions = seriesOptions.data, xData = series.xData;
    let isInTheMiddle, i;
    redraw = pick19(redraw, true);
    const point = { series };
    series.pointClass.prototype.applyOptions.apply(point, [options]);
    const x = point.x;
    i = xData.length;
    if (series.requireSorting && x < xData[i - 1]) {
      isInTheMiddle = true;
      while (i && xData[i - 1] > x) {
        i--;
      }
    }
    series.updateParallelArrays(point, "splice", [i, 0, 0]);
    series.updateParallelArrays(point, i);
    if (names && point.name) {
      names[x] = point.name;
    }
    dataOptions.splice(i, 0, options);
    if (isInTheMiddle || series.processedData) {
      series.data.splice(i, 0, null);
      series.processData();
    }
    if (seriesOptions.legendType === "point") {
      series.generatePoints();
    }
    if (shift) {
      if (data[0] && !!data[0].remove) {
        data[0].remove(false);
      } else {
        data.shift();
        series.updateParallelArrays(point, "shift");
        dataOptions.shift();
      }
    }
    if (withEvent !== false) {
      fireEvent11(series, "addPoint", { point });
    }
    series.isDirty = true;
    series.isDirtyData = true;
    if (redraw) {
      chart.redraw(animation);
    }
  }
  removePoint(i, redraw, animation) {
    const series = this, data = series.data, point = data[i], points = series.points, chart = series.chart, remove = function() {
      if (points && points.length === data.length) {
        points.splice(i, 1);
      }
      data.splice(i, 1);
      series.options.data.splice(i, 1);
      series.updateParallelArrays(point || { series }, "splice", [i, 1]);
      if (point) {
        point.destroy();
      }
      series.isDirty = true;
      series.isDirtyData = true;
      if (redraw) {
        chart.redraw();
      }
    };
    setAnimation2(animation, chart);
    redraw = pick19(redraw, true);
    if (point) {
      point.firePointEvent("remove", null, remove);
    } else {
      remove();
    }
  }
  remove(redraw, animation, withEvent, keepEvents) {
    const series = this, chart = series.chart;
    function remove() {
      series.destroy(keepEvents);
      chart.isDirtyLegend = chart.isDirtyBox = true;
      chart.linkSeries(keepEvents);
      if (pick19(redraw, true)) {
        chart.redraw(animation);
      }
    }
    if (withEvent !== false) {
      fireEvent11(series, "remove", null, remove);
    } else {
      remove();
    }
  }
  update(options, redraw) {
    options = diffObjects2(options, this.userOptions);
    fireEvent11(this, "update", { options });
    const series = this, chart = series.chart, oldOptions = series.userOptions, initialType = series.initialType || series.type, plotOptions = chart.options.plotOptions, initialSeriesProto = seriesTypes[initialType].prototype, groups = [
      "group",
      "markerGroup",
      "dataLabelsGroup",
      "transformGroup"
    ], optionsToCheck = [
      "dataGrouping",
      "pointStart",
      "pointInterval",
      "pointIntervalUnit",
      "keys"
    ], animation = series.finishedAnimating && { animation: false }, kinds = {};
    let seriesOptions, n, preserve = [
      "colorIndex",
      "eventOptions",
      "navigatorSeries",
      "symbolIndex",
      "baseSeries"
    ], newType = options.type || oldOptions.type || chart.options.chart.type;
    const keepPoints = !(this.hasDerivedData || newType && newType !== this.type || typeof options.pointStart !== "undefined" || typeof options.pointInterval !== "undefined" || typeof options.relativeXValue !== "undefined" || options.joinBy || options.mapData || optionsToCheck.some((option) => series.hasOptionChanged(option)));
    newType = newType || initialType;
    if (keepPoints) {
      preserve.push("data", "isDirtyData", "isDirtyCanvas", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX", "transformGroups");
      if (options.visible !== false) {
        preserve.push("area", "graph");
      }
      series.parallelArrays.forEach(function(key) {
        preserve.push(key + "Data");
      });
      if (options.data) {
        if (options.dataSorting) {
          extend17(series.options.dataSorting, options.dataSorting);
        }
        this.setData(options.data, false);
      }
    }
    options = merge16(oldOptions, {
      index: oldOptions.index === undefined ? series.index : oldOptions.index,
      pointStart: plotOptions?.series?.pointStart ?? oldOptions.pointStart ?? series.xData?.[0]
    }, !keepPoints && { data: series.options.data }, options, animation);
    if (keepPoints && options.data) {
      options.data = series.options.data;
    }
    preserve = groups.concat(preserve);
    preserve.forEach(function(prop) {
      preserve[prop] = series[prop];
      delete series[prop];
    });
    let casting = false;
    if (seriesTypes[newType]) {
      casting = newType !== series.type;
      series.remove(false, false, false, true);
      if (casting) {
        chart.propFromSeries();
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(series, seriesTypes[newType].prototype);
        } else {
          const ownEvents = Object.hasOwnProperty.call(series, "hcEvents") && series.hcEvents;
          for (n in initialSeriesProto) {
            series[n] = undefined;
          }
          extend17(series, seriesTypes[newType].prototype);
          if (ownEvents) {
            series.hcEvents = ownEvents;
          } else {
            delete series.hcEvents;
          }
        }
      }
    } else {
      error5(17, true, chart, { missingModuleFor: newType });
    }
    preserve.forEach(function(prop) {
      series[prop] = preserve[prop];
    });
    series.init(chart, options);
    if (keepPoints && this.points) {
      seriesOptions = series.options;
      if (seriesOptions.visible === false) {
        kinds.graphic = 1;
        kinds.dataLabel = 1;
      } else {
        if (this.hasMarkerChanged(seriesOptions, oldOptions)) {
          kinds.graphic = 1;
        }
        if (!series.hasDataLabels?.()) {
          kinds.dataLabel = 1;
        }
      }
      for (const point of this.points) {
        if (point && point.series) {
          point.resolveColor();
          if (Object.keys(kinds).length) {
            point.destroyElements(kinds);
          }
          if (seriesOptions.showInLegend === false && point.legendItem) {
            chart.legend.destroyItem(point);
          }
        }
      }
    }
    series.initialType = initialType;
    chart.linkSeries();
    chart.setSortedData();
    if (casting && series.linkedSeries.length) {
      series.isDirtyData = true;
    }
    fireEvent11(this, "afterUpdate");
    if (pick19(redraw, true)) {
      chart.redraw(keepPoints ? undefined : false);
    }
  }
  setName(name) {
    this.name = this.options.name = this.userOptions.name = name;
    this.chart.isDirtyLegend = true;
  }
  hasOptionChanged(optionName) {
    const chart = this.chart, option = this.options[optionName], plotOptions = chart.options.plotOptions, oldOption = this.userOptions[optionName], plotOptionsOption = pick19(plotOptions?.[this.type]?.[optionName], plotOptions?.series?.[optionName]);
    if (oldOption && !defined12(plotOptionsOption)) {
      return option !== oldOption;
    }
    return option !== pick19(plotOptionsOption, option);
  }
  onMouseOver() {
    const series = this, chart = series.chart, hoverSeries = chart.hoverSeries, pointer = chart.pointer;
    pointer?.setHoverChartIndex();
    if (hoverSeries && hoverSeries !== series) {
      hoverSeries.onMouseOut();
    }
    if (series.options.events.mouseOver) {
      fireEvent11(series, "mouseOver");
    }
    series.setState("hover");
    chart.hoverSeries = series;
  }
  onMouseOut() {
    const series = this, options = series.options, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;
    chart.hoverSeries = null;
    if (hoverPoint) {
      hoverPoint.onMouseOut();
    }
    if (series && options.events.mouseOut) {
      fireEvent11(series, "mouseOut");
    }
    if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
      tooltip.hide();
    }
    chart.series.forEach(function(s) {
      s.setState("", true);
    });
  }
  setState(state, inherit) {
    const series = this, options = series.options, graph = series.graph, inactiveOtherPoints = options.inactiveOtherPoints, stateOptions = options.states, stateAnimation = pick19(stateOptions[state || "normal"] && stateOptions[state || "normal"].animation, series.chart.options.chart.animation);
    let { lineWidth, opacity } = options;
    state = state || "";
    if (series.state !== state) {
      [
        series.group,
        series.markerGroup,
        series.dataLabelsGroup
      ].forEach(function(group) {
        if (group) {
          if (series.state) {
            group.removeClass("highcharts-series-" + series.state);
          }
          if (state) {
            group.addClass("highcharts-series-" + state);
          }
        }
      });
      series.state = state;
      if (!series.chart.styledMode) {
        if (stateOptions[state] && stateOptions[state].enabled === false) {
          return;
        }
        if (state) {
          lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0);
          opacity = pick19(stateOptions[state].opacity, opacity);
        }
        if (graph && !graph.dashstyle && isNumber16(lineWidth)) {
          for (const graphElement of [
            graph,
            ...this.zones.map((zone) => zone.graph)
          ]) {
            graphElement?.animate({
              "stroke-width": lineWidth
            }, stateAnimation);
          }
        }
        if (!inactiveOtherPoints) {
          [
            series.group,
            series.markerGroup,
            series.dataLabelsGroup,
            series.labelBySeries
          ].forEach(function(group) {
            if (group) {
              group.animate({
                opacity
              }, stateAnimation);
            }
          });
        }
      }
    }
    if (inherit && inactiveOtherPoints && series.points) {
      series.setAllPointsToState(state || undefined);
    }
  }
  setAllPointsToState(state) {
    this.points.forEach(function(point) {
      if (point.setState) {
        point.setState(state);
      }
    });
  }
  setVisible(vis, redraw) {
    const series = this, chart = series.chart, ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries, oldVisibility = series.visible;
    series.visible = vis = series.options.visible = series.userOptions.visible = typeof vis === "undefined" ? !oldVisibility : vis;
    const showOrHide = vis ? "show" : "hide";
    [
      "group",
      "dataLabelsGroup",
      "markerGroup",
      "tracker",
      "tt"
    ].forEach((key) => {
      series[key]?.[showOrHide]();
    });
    if (chart.hoverSeries === series || chart.hoverPoint?.series === series) {
      series.onMouseOut();
    }
    if (series.legendItem) {
      chart.legend.colorizeItem(series, vis);
    }
    series.isDirty = true;
    if (series.options.stacking) {
      chart.series.forEach((otherSeries) => {
        if (otherSeries.options.stacking && otherSeries.visible) {
          otherSeries.isDirty = true;
        }
      });
    }
    series.linkedSeries.forEach((otherSeries) => {
      otherSeries.setVisible(vis, false);
    });
    if (ignoreHiddenSeries) {
      chart.isDirtyBox = true;
    }
    fireEvent11(series, showOrHide);
    if (redraw !== false) {
      chart.redraw();
    }
  }
  show() {
    this.setVisible(true);
  }
  hide() {
    this.setVisible(false);
  }
  select(selected) {
    const series = this;
    series.selected = selected = this.options.selected = typeof selected === "undefined" ? !series.selected : selected;
    if (series.checkbox) {
      series.checkbox.checked = selected;
    }
    fireEvent11(series, selected ? "select" : "unselect");
  }
  shouldShowTooltip(plotX, plotY, options = {}) {
    options.series = this;
    options.visiblePlotOnly = true;
    return this.chart.isInsidePlot(plotX, plotY, options);
  }
  drawLegendSymbol(legend, item) {
    LegendSymbol_default[this.options.legendSymbol || "rectangle"]?.call(this, legend, item);
  }
}
Series.defaultOptions = SeriesDefaults_default;
Series.types = SeriesRegistry_default.seriesTypes;
Series.registerType = SeriesRegistry_default.registerSeriesType;
extend17(Series.prototype, {
  axisTypes: ["xAxis", "yAxis"],
  coll: "series",
  colorCounter: 0,
  directTouch: false,
  invertible: true,
  isCartesian: true,
  kdAxisArray: ["clientX", "plotY"],
  parallelArrays: ["x", "y"],
  pointClass: Point_default,
  requireSorting: true,
  sorted: true
});
SeriesRegistry_default.series = Series;
var Series_default = Series;

// node_modules/highcharts/es-modules/Core/Legend/Legend.js
var { animObject: animObject7, setAnimation: setAnimation3 } = AnimationUtilities_default;
var { registerEventOptions: registerEventOptions3 } = Foundation_default;
var { composed: composed4, marginNames } = Globals_default;
var { distribute: distribute2 } = RendererUtilities_default;
var { format: format4 } = Templating_default;
var { addEvent: addEvent10, createElement: createElement6, css: css8, defined: defined13, discardElement: discardElement3, find: find4, fireEvent: fireEvent12, isNumber: isNumber17, merge: merge17, pick: pick20, pushUnique: pushUnique7, relativeLength: relativeLength3, stableSort: stableSort3, syncTimeout: syncTimeout7 } = Utilities_default;

class Legend {
  constructor(chart, options) {
    this.allItems = [];
    this.initialItemY = 0;
    this.itemHeight = 0;
    this.itemMarginBottom = 0;
    this.itemMarginTop = 0;
    this.itemX = 0;
    this.itemY = 0;
    this.lastItemY = 0;
    this.lastLineHeight = 0;
    this.legendHeight = 0;
    this.legendWidth = 0;
    this.maxItemWidth = 0;
    this.maxLegendWidth = 0;
    this.offsetWidth = 0;
    this.padding = 0;
    this.pages = [];
    this.symbolHeight = 0;
    this.symbolWidth = 0;
    this.titleHeight = 0;
    this.totalItemWidth = 0;
    this.widthOption = 0;
    this.chart = chart;
    this.setOptions(options);
    if (options.enabled) {
      this.render();
      registerEventOptions3(this, options);
      addEvent10(this.chart, "endResize", function() {
        this.legend.positionCheckboxes();
      });
    }
    addEvent10(this.chart, "render", () => {
      if (this.options.enabled && this.proximate) {
        this.proximatePositions();
        this.positionItems();
      }
    });
  }
  setOptions(options) {
    const padding = pick20(options.padding, 8);
    this.options = options;
    if (!this.chart.styledMode) {
      this.itemStyle = options.itemStyle;
      this.itemHiddenStyle = merge17(this.itemStyle, options.itemHiddenStyle);
    }
    this.itemMarginTop = options.itemMarginTop;
    this.itemMarginBottom = options.itemMarginBottom;
    this.padding = padding;
    this.initialItemY = padding - 5;
    this.symbolWidth = pick20(options.symbolWidth, 16);
    this.pages = [];
    this.proximate = options.layout === "proximate" && !this.chart.inverted;
    this.baseline = undefined;
  }
  update(options, redraw) {
    const chart = this.chart;
    this.setOptions(merge17(true, this.options, options));
    if ("events" in this.options) {
      registerEventOptions3(this, this.options);
    }
    this.destroy();
    chart.isDirtyLegend = chart.isDirtyBox = true;
    if (pick20(redraw, true)) {
      chart.redraw();
    }
    fireEvent12(this, "afterUpdate", { redraw });
  }
  colorizeItem(item, visible) {
    const { area, group, label, line, symbol } = item.legendItem || {};
    group?.[visible ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
    if (!this.chart.styledMode) {
      const { itemHiddenStyle = {} } = this, hiddenColor = itemHiddenStyle.color, { fillColor, fillOpacity, lineColor, marker } = item.options, colorizeHidden = (attr8) => {
        if (!visible) {
          if (attr8.fill) {
            attr8.fill = hiddenColor;
          }
          if (attr8.stroke) {
            attr8.stroke = hiddenColor;
          }
        }
        return attr8;
      };
      label?.css(merge17(visible ? this.itemStyle : itemHiddenStyle));
      line?.attr(colorizeHidden({ stroke: lineColor || item.color }));
      if (symbol) {
        symbol.attr(colorizeHidden(marker && symbol.isMarker ? item.pointAttribs() : { fill: item.color }));
      }
      area?.attr(colorizeHidden({
        fill: fillColor || item.color,
        "fill-opacity": fillColor ? 1 : fillOpacity ?? 0.75
      }));
    }
    fireEvent12(this, "afterColorizeItem", { item, visible });
  }
  positionItems() {
    this.allItems.forEach(this.positionItem, this);
    if (!this.chart.isResizing) {
      this.positionCheckboxes();
    }
  }
  positionItem(item) {
    const legend = this, { group, x = 0, y = 0 } = item.legendItem || {}, options = legend.options, symbolPadding = options.symbolPadding, ltr = !options.rtl, checkbox = item.checkbox;
    if (group && group.element) {
      const attribs = {
        translateX: ltr ? x : legend.legendWidth - x - 2 * symbolPadding - 4,
        translateY: y
      };
      const complete = () => {
        fireEvent12(this, "afterPositionItem", { item });
      };
      group[defined13(group.translateY) ? "animate" : "attr"](attribs, undefined, complete);
    }
    if (checkbox) {
      checkbox.x = x;
      checkbox.y = y;
    }
  }
  destroyItem(item) {
    const checkbox = item.checkbox, legendItem = item.legendItem || {};
    for (const key of ["group", "label", "line", "symbol"]) {
      if (legendItem[key]) {
        legendItem[key] = legendItem[key].destroy();
      }
    }
    if (checkbox) {
      discardElement3(checkbox);
    }
    item.legendItem = undefined;
  }
  destroy() {
    const legend = this;
    for (const item of this.getAllItems()) {
      this.destroyItem(item);
    }
    for (const key of [
      "clipRect",
      "up",
      "down",
      "pager",
      "nav",
      "box",
      "title",
      "group"
    ]) {
      if (legend[key]) {
        legend[key] = legend[key].destroy();
      }
    }
    this.display = null;
  }
  positionCheckboxes() {
    const alignAttr = this.group && this.group.alignAttr, clipHeight = this.clipHeight || this.legendHeight, titleHeight = this.titleHeight;
    let translateY;
    if (alignAttr) {
      translateY = alignAttr.translateY;
      this.allItems.forEach(function(item) {
        const checkbox = item.checkbox;
        let top;
        if (checkbox) {
          top = translateY + titleHeight + checkbox.y + (this.scrollOffset || 0) + 3;
          css8(checkbox, {
            left: alignAttr.translateX + item.checkboxOffset + checkbox.x - 20 + "px",
            top: top + "px",
            display: this.proximate || top > translateY - 6 && top < translateY + clipHeight - 6 ? "" : "none"
          });
        }
      }, this);
    }
  }
  renderTitle() {
    const options = this.options, padding = this.padding, titleOptions = options.title;
    let bBox, titleHeight = 0;
    if (titleOptions.text) {
      if (!this.title) {
        this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, undefined, undefined, undefined, options.useHTML, undefined, "legend-title").attr({ zIndex: 1 });
        if (!this.chart.styledMode) {
          this.title.css(titleOptions.style);
        }
        this.title.add(this.group);
      }
      if (!titleOptions.width) {
        this.title.css({
          width: this.maxLegendWidth + "px"
        });
      }
      bBox = this.title.getBBox();
      titleHeight = bBox.height;
      this.offsetWidth = bBox.width;
      this.contentGroup.attr({ translateY: titleHeight });
    }
    this.titleHeight = titleHeight;
  }
  setText(item) {
    const options = this.options;
    item.legendItem.label.attr({
      text: options.labelFormat ? format4(options.labelFormat, item, this.chart) : options.labelFormatter.call(item)
    });
  }
  renderItem(item) {
    const legend = this, legendItem = item.legendItem = item.legendItem || {}, chart = legend.chart, renderer = chart.renderer, options = legend.options, horizontal = options.layout === "horizontal", symbolWidth = legend.symbolWidth, symbolPadding = options.symbolPadding || 0, itemStyle = legend.itemStyle, itemHiddenStyle = legend.itemHiddenStyle, itemDistance = horizontal ? pick20(options.itemDistance, 20) : 0, ltr = !options.rtl, isSeries = !item.series, series = !isSeries && item.series.drawLegendSymbol ? item.series : item, seriesOptions = series.options, showCheckbox = !!legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox, useHTML = options.useHTML, itemClassName = item.options.className;
    let label = legendItem.label, itemExtraWidth = symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
    if (!label) {
      legendItem.group = renderer.g("legend-item").addClass("highcharts-" + series.type + "-series highcharts-color-" + item.colorIndex + (itemClassName ? " " + itemClassName : "") + (isSeries ? " highcharts-series-" + item.index : "")).attr({ zIndex: 1 }).add(legend.scrollGroup);
      legendItem.label = label = renderer.text("", ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline || 0, useHTML);
      if (!chart.styledMode) {
        label.css(merge17(item.visible ? itemStyle : itemHiddenStyle));
      }
      label.attr({
        align: ltr ? "left" : "right",
        zIndex: 2
      }).add(legendItem.group);
      if (!legend.baseline) {
        legend.fontMetrics = renderer.fontMetrics(label);
        legend.baseline = legend.fontMetrics.f + 3 + legend.itemMarginTop;
        label.attr("y", legend.baseline);
        legend.symbolHeight = pick20(options.symbolHeight, legend.fontMetrics.f);
        if (options.squareSymbol) {
          legend.symbolWidth = pick20(options.symbolWidth, Math.max(legend.symbolHeight, 16));
          itemExtraWidth = legend.symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
          if (ltr) {
            label.attr("x", legend.symbolWidth + symbolPadding);
          }
        }
      }
      series.drawLegendSymbol(legend, item);
      if (legend.setItemEvents) {
        legend.setItemEvents(item, label, useHTML);
      }
    }
    if (showCheckbox && !item.checkbox && legend.createCheckboxForItem) {
      legend.createCheckboxForItem(item);
    }
    legend.colorizeItem(item, item.visible);
    if (chart.styledMode || !itemStyle.width) {
      label.css({
        width: (options.itemWidth || legend.widthOption || chart.spacingBox.width) - itemExtraWidth + "px"
      });
    }
    legend.setText(item);
    const bBox = label.getBBox();
    const fontMetricsH = legend.fontMetrics && legend.fontMetrics.h || 0;
    item.itemWidth = item.checkboxOffset = options.itemWidth || legendItem.labelWidth || bBox.width + itemExtraWidth;
    legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);
    legend.totalItemWidth += item.itemWidth;
    legend.itemHeight = item.itemHeight = Math.round(legendItem.labelHeight || (bBox.height > fontMetricsH * 1.5 ? bBox.height : fontMetricsH));
  }
  layoutItem(item) {
    const options = this.options, padding = this.padding, horizontal = options.layout === "horizontal", itemHeight = item.itemHeight, itemMarginBottom = this.itemMarginBottom, itemMarginTop = this.itemMarginTop, itemDistance = horizontal ? pick20(options.itemDistance, 20) : 0, maxLegendWidth = this.maxLegendWidth, itemWidth = options.alignColumns && this.totalItemWidth > maxLegendWidth ? this.maxItemWidth : item.itemWidth, legendItem = item.legendItem || {};
    if (horizontal && this.itemX - padding + itemWidth > maxLegendWidth) {
      this.itemX = padding;
      if (this.lastLineHeight) {
        this.itemY += itemMarginTop + this.lastLineHeight + itemMarginBottom;
      }
      this.lastLineHeight = 0;
    }
    this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;
    this.lastLineHeight = Math.max(itemHeight, this.lastLineHeight);
    legendItem.x = this.itemX;
    legendItem.y = this.itemY;
    if (horizontal) {
      this.itemX += itemWidth;
    } else {
      this.itemY += itemMarginTop + itemHeight + itemMarginBottom;
      this.lastLineHeight = itemHeight;
    }
    this.offsetWidth = this.widthOption || Math.max((horizontal ? this.itemX - padding - (item.checkbox ? 0 : itemDistance) : itemWidth) + padding, this.offsetWidth);
  }
  getAllItems() {
    let allItems = [];
    this.chart.series.forEach(function(series) {
      const seriesOptions = series && series.options;
      if (series && pick20(seriesOptions.showInLegend, !defined13(seriesOptions.linkedTo) ? undefined : false, true)) {
        allItems = allItems.concat((series.legendItem || {}).labels || (seriesOptions.legendType === "point" ? series.data : series));
      }
    });
    fireEvent12(this, "afterGetAllItems", { allItems });
    return allItems;
  }
  getAlignment() {
    const options = this.options;
    if (this.proximate) {
      return options.align.charAt(0) + "tv";
    }
    return options.floating ? "" : options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0);
  }
  adjustMargins(margin, spacing) {
    const chart = this.chart, options = this.options, alignment = this.getAlignment();
    if (alignment) {
      [
        /(lth|ct|rth)/,
        /(rtv|rm|rbv)/,
        /(rbh|cb|lbh)/,
        /(lbv|lm|ltv)/
      ].forEach(function(alignments, side) {
        if (alignments.test(alignment) && !defined13(margin[side])) {
          chart[marginNames[side]] = Math.max(chart[marginNames[side]], chart.legend[(side + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][side] * options[side % 2 ? "x" : "y"] + pick20(options.margin, 12) + spacing[side] + (chart.titleOffset[side] || 0));
        }
      });
    }
  }
  proximatePositions() {
    const chart = this.chart, boxes = [], alignLeft = this.options.align === "left";
    this.allItems.forEach(function(item) {
      let lastPoint, height, useFirstPoint = alignLeft, target, top;
      if (item.yAxis) {
        if (item.xAxis.options.reversed) {
          useFirstPoint = !useFirstPoint;
        }
        if (item.points) {
          lastPoint = find4(useFirstPoint ? item.points : item.points.slice(0).reverse(), function(item2) {
            return isNumber17(item2.plotY);
          });
        }
        height = this.itemMarginTop + item.legendItem.label.getBBox().height + this.itemMarginBottom;
        top = item.yAxis.top - chart.plotTop;
        if (item.visible) {
          target = lastPoint ? lastPoint.plotY : item.yAxis.height;
          target += top - 0.3 * height;
        } else {
          target = top + item.yAxis.height;
        }
        boxes.push({
          target,
          size: height,
          item
        });
      }
    }, this);
    let legendItem;
    for (const box of distribute2(boxes, chart.plotHeight)) {
      legendItem = box.item.legendItem || {};
      if (isNumber17(box.pos)) {
        legendItem.y = chart.plotTop - chart.spacing[0] + box.pos;
      }
    }
  }
  render() {
    const legend = this, chart = legend.chart, renderer = chart.renderer, options = legend.options, padding = legend.padding, allItems = legend.getAllItems();
    let display, legendWidth, legendHeight, legendGroup = legend.group, allowedWidth, box = legend.box;
    legend.itemX = padding;
    legend.itemY = legend.initialItemY;
    legend.offsetWidth = 0;
    legend.lastItemY = 0;
    legend.widthOption = relativeLength3(options.width, chart.spacingBox.width - padding);
    allowedWidth = chart.spacingBox.width - 2 * padding - options.x;
    if (["rm", "lm"].indexOf(legend.getAlignment().substring(0, 2)) > -1) {
      allowedWidth /= 2;
    }
    legend.maxLegendWidth = legend.widthOption || allowedWidth;
    if (!legendGroup) {
      legend.group = legendGroup = renderer.g("legend").addClass(options.className || "").attr({ zIndex: 7 }).add();
      legend.contentGroup = renderer.g().attr({ zIndex: 1 }).add(legendGroup);
      legend.scrollGroup = renderer.g().add(legend.contentGroup);
    }
    legend.renderTitle();
    stableSort3(allItems, (a, b) => (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0));
    if (options.reversed) {
      allItems.reverse();
    }
    legend.allItems = allItems;
    legend.display = display = !!allItems.length;
    legend.lastLineHeight = 0;
    legend.maxItemWidth = 0;
    legend.totalItemWidth = 0;
    legend.itemHeight = 0;
    allItems.forEach(legend.renderItem, legend);
    allItems.forEach(legend.layoutItem, legend);
    legendWidth = (legend.widthOption || legend.offsetWidth) + padding;
    legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
    legendHeight = legend.handleOverflow(legendHeight);
    legendHeight += padding;
    if (!box) {
      legend.box = box = renderer.rect().addClass("highcharts-legend-box").attr({
        r: options.borderRadius
      }).add(legendGroup);
    }
    if (!chart.styledMode) {
      box.attr({
        stroke: options.borderColor,
        "stroke-width": options.borderWidth || 0,
        fill: options.backgroundColor || "none"
      }).shadow(options.shadow);
    }
    if (legendWidth > 0 && legendHeight > 0) {
      box[box.placed ? "animate" : "attr"](box.crisp.call({}, {
        x: 0,
        y: 0,
        width: legendWidth,
        height: legendHeight
      }, box.strokeWidth()));
    }
    legendGroup[display ? "show" : "hide"]();
    if (chart.styledMode && legendGroup.getStyle("display") === "none") {
      legendWidth = legendHeight = 0;
    }
    legend.legendWidth = legendWidth;
    legend.legendHeight = legendHeight;
    if (display) {
      legend.align();
    }
    if (!this.proximate) {
      this.positionItems();
    }
    fireEvent12(this, "afterRender");
  }
  align(alignTo = this.chart.spacingBox) {
    const chart = this.chart, options = this.options;
    let y = alignTo.y;
    if (/(lth|ct|rth)/.test(this.getAlignment()) && chart.titleOffset[0] > 0) {
      y += chart.titleOffset[0];
    } else if (/(lbh|cb|rbh)/.test(this.getAlignment()) && chart.titleOffset[2] > 0) {
      y -= chart.titleOffset[2];
    }
    if (y !== alignTo.y) {
      alignTo = merge17(alignTo, { y });
    }
    if (!chart.hasRendered) {
      this.group.placed = false;
    }
    this.group.align(merge17(options, {
      width: this.legendWidth,
      height: this.legendHeight,
      verticalAlign: this.proximate ? "top" : options.verticalAlign
    }), true, alignTo);
  }
  handleOverflow(legendHeight) {
    const legend = this, chart = this.chart, renderer = chart.renderer, options = this.options, optionsY = options.y, alignTop = options.verticalAlign === "top", padding = this.padding, maxHeight = options.maxHeight, navOptions = options.navigation, animation = pick20(navOptions.animation, true), arrowSize = navOptions.arrowSize || 12, pages = this.pages, allItems = this.allItems, clipToHeight = function(height) {
      if (typeof height === "number") {
        clipRect.attr({
          height
        });
      } else if (clipRect) {
        legend.clipRect = clipRect.destroy();
        legend.contentGroup.clip();
      }
      if (legend.contentGroup.div) {
        legend.contentGroup.div.style.clip = height ? "rect(" + padding + "px,9999px," + (padding + height) + "px,0)" : "auto";
      }
    }, addTracker = function(key) {
      legend[key] = renderer.circle(0, 0, arrowSize * 1.3).translate(arrowSize / 2, arrowSize / 2).add(nav);
      if (!chart.styledMode) {
        legend[key].attr("fill", "rgba(0,0,0,0.0001)");
      }
      return legend[key];
    };
    let clipHeight, lastY, legendItem, spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - padding, nav = this.nav, clipRect = this.clipRect;
    if (options.layout === "horizontal" && options.verticalAlign !== "middle" && !options.floating) {
      spaceHeight /= 2;
    }
    if (maxHeight) {
      spaceHeight = Math.min(spaceHeight, maxHeight);
    }
    pages.length = 0;
    if (legendHeight && spaceHeight > 0 && legendHeight > spaceHeight && navOptions.enabled !== false) {
      this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
      this.currentPage = pick20(this.currentPage, 1);
      this.fullHeight = legendHeight;
      allItems.forEach((item, i) => {
        legendItem = item.legendItem || {};
        const y = legendItem.y || 0, h = Math.round(legendItem.label.getBBox().height);
        let len = pages.length;
        if (!len || y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1]) {
          pages.push(lastY || y);
          len++;
        }
        legendItem.pageIx = len - 1;
        if (lastY) {
          (allItems[i - 1].legendItem || {}).pageIx = len - 1;
        }
        if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight && y > pages[len - 1]) {
          pages.push(y);
          legendItem.pageIx = len;
        }
        if (y !== lastY) {
          lastY = y;
        }
      });
      if (!clipRect) {
        clipRect = legend.clipRect = renderer.clipRect(0, padding - 2, 9999, 0);
        legend.contentGroup.clip(clipRect);
      }
      clipToHeight(clipHeight);
      if (!nav) {
        this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
        this.up = renderer.symbol("triangle", 0, 0, arrowSize, arrowSize).add(nav);
        addTracker("upTracker").on("click", function() {
          legend.scroll(-1, animation);
        });
        this.pager = renderer.text("", 15, 10).addClass("highcharts-legend-navigation");
        if (!chart.styledMode && navOptions.style) {
          this.pager.css(navOptions.style);
        }
        this.pager.add(nav);
        this.down = renderer.symbol("triangle-down", 0, 0, arrowSize, arrowSize).add(nav);
        addTracker("downTracker").on("click", function() {
          legend.scroll(1, animation);
        });
      }
      legend.scroll(0);
      legendHeight = spaceHeight;
    } else if (nav) {
      clipToHeight();
      this.nav = nav.destroy();
      this.scrollGroup.attr({
        translateY: 1
      });
      this.clipHeight = 0;
    }
    return legendHeight;
  }
  scroll(scrollBy, animation) {
    const chart = this.chart, pages = this.pages, pageCount = pages.length, clipHeight = this.clipHeight, navOptions = this.options.navigation, pager = this.pager, padding = this.padding;
    let currentPage = this.currentPage + scrollBy;
    if (currentPage > pageCount) {
      currentPage = pageCount;
    }
    if (currentPage > 0) {
      if (typeof animation !== "undefined") {
        setAnimation3(animation, chart);
      }
      this.nav.attr({
        translateX: padding,
        translateY: clipHeight + this.padding + 7 + this.titleHeight,
        visibility: "inherit"
      });
      [this.up, this.upTracker].forEach(function(elem) {
        elem.attr({
          class: currentPage === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
        });
      });
      pager.attr({
        text: currentPage + "/" + pageCount
      });
      [this.down, this.downTracker].forEach(function(elem) {
        elem.attr({
          x: 18 + this.pager.getBBox().width,
          class: currentPage === pageCount ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
        });
      }, this);
      if (!chart.styledMode) {
        this.up.attr({
          fill: currentPage === 1 ? navOptions.inactiveColor : navOptions.activeColor
        });
        this.upTracker.css({
          cursor: currentPage === 1 ? "default" : "pointer"
        });
        this.down.attr({
          fill: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor
        });
        this.downTracker.css({
          cursor: currentPage === pageCount ? "default" : "pointer"
        });
      }
      this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;
      this.scrollGroup.animate({
        translateY: this.scrollOffset
      });
      this.currentPage = currentPage;
      this.positionCheckboxes();
      const animOptions = animObject7(pick20(animation, chart.renderer.globalAnimation, true));
      syncTimeout7(() => {
        fireEvent12(this, "afterScroll", { currentPage });
      }, animOptions.duration);
    }
  }
  setItemEvents(item, legendLabel, useHTML) {
    const legend = this, legendItem = item.legendItem || {}, boxWrapper = legend.chart.renderer.boxWrapper, isPoint = item instanceof Point_default, isSeries = item instanceof Series_default, activeClass = "highcharts-legend-" + (isPoint ? "point" : "series") + "-active", styledMode = legend.chart.styledMode, legendElements = useHTML ? [legendLabel, legendItem.symbol] : [legendItem.group];
    const setOtherItemsState = (state) => {
      legend.allItems.forEach((otherItem) => {
        if (item !== otherItem) {
          [otherItem].concat(otherItem.linkedSeries || []).forEach((otherItem2) => {
            otherItem2.setState(state, !isPoint);
          });
        }
      });
    };
    for (const element of legendElements) {
      if (element) {
        element.on("mouseover", function() {
          if (item.visible) {
            setOtherItemsState("inactive");
          }
          item.setState("hover");
          if (item.visible) {
            boxWrapper.addClass(activeClass);
          }
          if (!styledMode) {
            legendLabel.css(legend.options.itemHoverStyle);
          }
        }).on("mouseout", function() {
          if (!legend.chart.styledMode) {
            legendLabel.css(merge17(item.visible ? legend.itemStyle : legend.itemHiddenStyle));
          }
          setOtherItemsState("");
          boxWrapper.removeClass(activeClass);
          item.setState();
        }).on("click", function(event) {
          const defaultItemClick = function() {
            if (item.setVisible) {
              item.setVisible();
            }
            setOtherItemsState(item.visible ? "inactive" : "");
          };
          boxWrapper.removeClass(activeClass);
          fireEvent12(legend, "itemClick", {
            browserEvent: event,
            legendItem: item
          }, defaultItemClick);
          if (isPoint) {
            item.firePointEvent("legendItemClick", {
              browserEvent: event
            });
          } else if (isSeries) {
            fireEvent12(item, "legendItemClick", {
              browserEvent: event
            });
          }
        });
      }
    }
  }
  createCheckboxForItem(item) {
    const legend = this;
    item.checkbox = createElement6("input", {
      type: "checkbox",
      className: "highcharts-legend-checkbox",
      checked: item.selected,
      defaultChecked: item.selected
    }, legend.options.itemCheckboxStyle, legend.chart.container);
    addEvent10(item.checkbox, "click", function(event) {
      const target = event.target;
      fireEvent12(item.series || item, "checkboxClick", {
        checked: target.checked,
        item
      }, function() {
        item.select();
      });
    });
  }
}
(function(Legend2) {
  function compose(ChartClass) {
    if (pushUnique7(composed4, "Core.Legend")) {
      addEvent10(ChartClass, "beforeMargins", function() {
        this.legend = new Legend2(this, this.options.legend);
      });
    }
  }
  Legend2.compose = compose;
})(Legend || (Legend = {}));
var Legend_default = Legend;

// node_modules/highcharts/es-modules/Core/Chart/Chart.js
var { animate: animate3, animObject: animObject8, setAnimation: setAnimation4 } = AnimationUtilities_default;
var { defaultOptions: defaultOptions8, defaultTime: defaultTime3 } = Defaults_default;
var { numberFormat: numberFormat2 } = Templating_default;
var { registerEventOptions: registerEventOptions4 } = Foundation_default;
var { charts: charts4, doc: doc6, marginNames: marginNames2, svg: svg3, win: win9 } = Globals_default;
var { seriesTypes: seriesTypes2 } = SeriesRegistry_default;
var { addEvent: addEvent11, attr: attr8, createElement: createElement7, css: css9, defined: defined14, diffObjects: diffObjects3, discardElement: discardElement4, erase: erase8, error: error6, extend: extend18, find: find5, fireEvent: fireEvent13, getStyle: getStyle3, isArray: isArray10, isNumber: isNumber18, isObject: isObject9, isString: isString9, merge: merge18, objectEach: objectEach14, pick: pick21, pInt: pInt7, relativeLength: relativeLength4, removeEvent: removeEvent7, splat: splat8, syncTimeout: syncTimeout8, uniqueKey: uniqueKey5 } = Utilities_default;

class Chart {
  static chart(a, b, c) {
    return new Chart(a, b, c);
  }
  constructor(a, b, c) {
    this.sharedClips = {};
    const args = [
      ...arguments
    ];
    if (isString9(a) || a.nodeName) {
      this.renderTo = args.shift();
    }
    this.init(args[0], args[1]);
  }
  setZoomOptions() {
    const chart = this, options = chart.options.chart, zooming = options.zooming;
    chart.zooming = {
      ...zooming,
      type: pick21(options.zoomType, zooming.type),
      key: pick21(options.zoomKey, zooming.key),
      pinchType: pick21(options.pinchType, zooming.pinchType),
      singleTouch: pick21(options.zoomBySingleTouch, zooming.singleTouch, false),
      resetButton: merge18(zooming.resetButton, options.resetZoomButton)
    };
  }
  init(userOptions, callback) {
    fireEvent13(this, "init", { args: arguments }, function() {
      const options = merge18(defaultOptions8, userOptions), optionsChart = options.chart;
      this.userOptions = extend18({}, userOptions);
      this.margin = [];
      this.spacing = [];
      this.labelCollectors = [];
      this.callback = callback;
      this.isResizing = 0;
      this.options = options;
      this.axes = [];
      this.series = [];
      this.time = userOptions.time && Object.keys(userOptions.time).length ? new Time_default(userOptions.time) : Globals_default.time;
      this.numberFormatter = optionsChart.numberFormatter || numberFormat2;
      this.styledMode = optionsChart.styledMode;
      this.hasCartesianSeries = optionsChart.showAxes;
      const chart = this;
      chart.index = charts4.length;
      charts4.push(chart);
      Globals_default.chartCount++;
      registerEventOptions4(this, optionsChart);
      chart.xAxis = [];
      chart.yAxis = [];
      chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;
      this.setZoomOptions();
      fireEvent13(chart, "afterInit");
      chart.firstRender();
    });
  }
  initSeries(options) {
    const chart = this, optionsChart = chart.options.chart, type = options.type || optionsChart.type, SeriesClass = seriesTypes2[type];
    if (!SeriesClass) {
      error6(17, true, chart, { missingModuleFor: type });
    }
    const series = new SeriesClass;
    if (typeof series.init === "function") {
      series.init(chart, options);
    }
    return series;
  }
  setSortedData() {
    this.getSeriesOrderByLinks().forEach(function(series) {
      if (!series.points && !series.data && series.enabledDataSorting) {
        series.setData(series.options.data, false);
      }
    });
  }
  getSeriesOrderByLinks() {
    return this.series.concat().sort(function(a, b) {
      if (a.linkedSeries.length || b.linkedSeries.length) {
        return b.linkedSeries.length - a.linkedSeries.length;
      }
      return 0;
    });
  }
  orderItems(coll, fromIndex = 0) {
    const collection = this[coll], optionsArray = this.options[coll] = splat8(this.options[coll]).slice(), userOptionsArray = this.userOptions[coll] = this.userOptions[coll] ? splat8(this.userOptions[coll]).slice() : [];
    if (this.hasRendered) {
      optionsArray.splice(fromIndex);
      userOptionsArray.splice(fromIndex);
    }
    if (collection) {
      for (let i = fromIndex, iEnd = collection.length;i < iEnd; ++i) {
        const item = collection[i];
        if (item) {
          item.index = i;
          if (item instanceof Series_default) {
            item.name = item.getName();
          }
          if (!item.options.isInternal) {
            optionsArray[i] = item.options;
            userOptionsArray[i] = item.userOptions;
          }
        }
      }
    }
  }
  isInsidePlot(plotX, plotY, options = {}) {
    const { inverted, plotBox, plotLeft, plotTop, scrollablePlotBox } = this, { scrollLeft = 0, scrollTop = 0 } = options.visiblePlotOnly && this.scrollablePlotArea?.scrollingContainer || {}, series = options.series, box = options.visiblePlotOnly && scrollablePlotBox || plotBox, x = options.inverted ? plotY : plotX, y = options.inverted ? plotX : plotY, e = {
      x,
      y,
      isInsidePlot: true,
      options
    };
    if (!options.ignoreX) {
      const xAxis2 = series && (inverted && !this.polar ? series.yAxis : series.xAxis) || {
        pos: plotLeft,
        len: Infinity
      };
      const chartX = options.paneCoordinates ? xAxis2.pos + x : plotLeft + x;
      if (!(chartX >= Math.max(scrollLeft + plotLeft, xAxis2.pos) && chartX <= Math.min(scrollLeft + plotLeft + box.width, xAxis2.pos + xAxis2.len))) {
        e.isInsidePlot = false;
      }
    }
    if (!options.ignoreY && e.isInsidePlot) {
      const yAxis2 = !inverted && options.axis && !options.axis.isXAxis && options.axis || series && (inverted ? series.xAxis : series.yAxis) || {
        pos: plotTop,
        len: Infinity
      };
      const chartY = options.paneCoordinates ? yAxis2.pos + y : plotTop + y;
      if (!(chartY >= Math.max(scrollTop + plotTop, yAxis2.pos) && chartY <= Math.min(scrollTop + plotTop + box.height, yAxis2.pos + yAxis2.len))) {
        e.isInsidePlot = false;
      }
    }
    fireEvent13(this, "afterIsInsidePlot", e);
    return e.isInsidePlot;
  }
  redraw(animation) {
    fireEvent13(this, "beforeRedraw");
    const chart = this, axes = chart.hasCartesianSeries ? chart.axes : chart.colorAxis || [], series = chart.series, pointer = chart.pointer, legend = chart.legend, legendUserOptions = chart.userOptions.legend, renderer = chart.renderer, isHiddenChart = renderer.isHidden(), afterRedraw = [];
    let hasDirtyStacks, hasStackedSeries, i, isDirtyBox = chart.isDirtyBox, redrawLegend = chart.isDirtyLegend, serie;
    renderer.rootFontSize = renderer.boxWrapper.getStyle("font-size");
    if (chart.setResponsive) {
      chart.setResponsive(false);
    }
    setAnimation4(chart.hasRendered ? animation : false, chart);
    if (isHiddenChart) {
      chart.temporaryDisplay();
    }
    chart.layOutTitles(false);
    i = series.length;
    while (i--) {
      serie = series[i];
      if (serie.options.stacking || serie.options.centerInCategory) {
        hasStackedSeries = true;
        if (serie.isDirty) {
          hasDirtyStacks = true;
          break;
        }
      }
    }
    if (hasDirtyStacks) {
      i = series.length;
      while (i--) {
        serie = series[i];
        if (serie.options.stacking) {
          serie.isDirty = true;
        }
      }
    }
    series.forEach(function(serie2) {
      if (serie2.isDirty) {
        if (serie2.options.legendType === "point") {
          if (typeof serie2.updateTotals === "function") {
            serie2.updateTotals();
          }
          redrawLegend = true;
        } else if (legendUserOptions && (!!legendUserOptions.labelFormatter || legendUserOptions.labelFormat)) {
          redrawLegend = true;
        }
      }
      if (serie2.isDirtyData) {
        fireEvent13(serie2, "updatedData");
      }
    });
    if (redrawLegend && legend && legend.options.enabled) {
      legend.render();
      chart.isDirtyLegend = false;
    }
    if (hasStackedSeries) {
      chart.getStacks();
    }
    axes.forEach(function(axis) {
      axis.updateNames();
      axis.setScale();
    });
    chart.getMargins();
    axes.forEach(function(axis) {
      if (axis.isDirty) {
        isDirtyBox = true;
      }
    });
    axes.forEach(function(axis) {
      const key = axis.min + "," + axis.max;
      if (axis.extKey !== key) {
        axis.extKey = key;
        afterRedraw.push(function() {
          fireEvent13(axis, "afterSetExtremes", extend18(axis.eventArgs, axis.getExtremes()));
          delete axis.eventArgs;
        });
      }
      if (isDirtyBox || hasStackedSeries) {
        axis.redraw();
      }
    });
    if (isDirtyBox) {
      chart.drawChartBox();
    }
    fireEvent13(chart, "predraw");
    series.forEach(function(serie2) {
      if ((isDirtyBox || serie2.isDirty) && serie2.visible) {
        serie2.redraw();
      }
      serie2.isDirtyData = false;
    });
    if (pointer) {
      pointer.reset(true);
    }
    renderer.draw();
    fireEvent13(chart, "redraw");
    fireEvent13(chart, "render");
    if (isHiddenChart) {
      chart.temporaryDisplay(true);
    }
    afterRedraw.forEach(function(callback) {
      callback.call();
    });
  }
  get(id) {
    const series = this.series;
    function itemById(item) {
      return item.id === id || item.options && item.options.id === id;
    }
    let ret = find5(this.axes, itemById) || find5(this.series, itemById);
    for (let i = 0;!ret && i < series.length; i++) {
      ret = find5(series[i].points || [], itemById);
    }
    return ret;
  }
  getAxes() {
    const options = this.userOptions;
    fireEvent13(this, "getAxes");
    for (const coll of ["xAxis", "yAxis"]) {
      const arr = options[coll] = splat8(options[coll] || {});
      for (const axisOptions of arr) {
        new Axis_default(this, axisOptions, coll);
      }
    }
    fireEvent13(this, "afterGetAxes");
  }
  getSelectedPoints() {
    return this.series.reduce((acc, series) => {
      series.getPointsCollection().forEach((point) => {
        if (pick21(point.selectedStaging, point.selected)) {
          acc.push(point);
        }
      });
      return acc;
    }, []);
  }
  getSelectedSeries() {
    return this.series.filter(function(serie) {
      return serie.selected;
    });
  }
  setTitle(titleOptions, subtitleOptions, redraw) {
    this.applyDescription("title", titleOptions);
    this.applyDescription("subtitle", subtitleOptions);
    this.applyDescription("caption", undefined);
    this.layOutTitles(redraw);
  }
  applyDescription(name, explicitOptions) {
    const chart = this;
    const options = this.options[name] = merge18(this.options[name], explicitOptions);
    let elem = this[name];
    if (elem && explicitOptions) {
      this[name] = elem = elem.destroy();
    }
    if (options && !elem) {
      elem = this.renderer.text(options.text, 0, 0, options.useHTML).attr({
        align: options.align,
        class: "highcharts-" + name,
        zIndex: options.zIndex || 4
      }).add();
      elem.update = function(updateOptions, redraw) {
        chart.applyDescription(name, updateOptions);
        chart.layOutTitles(redraw);
      };
      if (!this.styledMode) {
        elem.css(extend18(name === "title" ? {
          fontSize: this.options.isStock ? "1em" : "1.2em"
        } : {}, options.style));
      }
      this[name] = elem;
    }
  }
  layOutTitles(redraw = true) {
    const titleOffset = [0, 0, 0], renderer = this.renderer, spacingBox = this.spacingBox;
    ["title", "subtitle", "caption"].forEach(function(key) {
      const title = this[key], titleOptions = this.options[key], verticalAlign = titleOptions.verticalAlign || "top", offset3 = key === "title" ? verticalAlign === "top" ? -3 : 0 : verticalAlign === "top" ? titleOffset[0] + 2 : 0;
      if (title) {
        title.css({
          width: (titleOptions.width || spacingBox.width + (titleOptions.widthAdjust || 0)) + "px"
        });
        const baseline = renderer.fontMetrics(title).b, height = Math.round(title.getBBox(titleOptions.useHTML).height);
        title.align(extend18({
          y: verticalAlign === "bottom" ? baseline : offset3 + baseline,
          height
        }, titleOptions), false, "spacingBox");
        if (!titleOptions.floating) {
          if (verticalAlign === "top") {
            titleOffset[0] = Math.ceil(titleOffset[0] + height);
          } else if (verticalAlign === "bottom") {
            titleOffset[2] = Math.ceil(titleOffset[2] + height);
          }
        }
      }
    }, this);
    if (titleOffset[0] && (this.options.title.verticalAlign || "top") === "top") {
      titleOffset[0] += this.options.title.margin;
    }
    if (titleOffset[2] && this.options.caption.verticalAlign === "bottom") {
      titleOffset[2] += this.options.caption.margin;
    }
    const requiresDirtyBox = !this.titleOffset || this.titleOffset.join(",") !== titleOffset.join(",");
    this.titleOffset = titleOffset;
    fireEvent13(this, "afterLayOutTitles");
    if (!this.isDirtyBox && requiresDirtyBox) {
      this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox;
      if (this.hasRendered && redraw && this.isDirtyBox) {
        this.redraw();
      }
    }
  }
  getContainerBox() {
    return {
      width: getStyle3(this.renderTo, "width", true) || 0,
      height: getStyle3(this.renderTo, "height", true) || 0
    };
  }
  getChartSize() {
    const chart = this, optionsChart = chart.options.chart, widthOption = optionsChart.width, heightOption = optionsChart.height, containerBox = chart.getContainerBox();
    chart.chartWidth = Math.max(0, widthOption || containerBox.width || 600);
    chart.chartHeight = Math.max(0, relativeLength4(heightOption, chart.chartWidth) || (containerBox.height > 1 ? containerBox.height : 400));
    chart.containerBox = containerBox;
  }
  temporaryDisplay(revert) {
    let node = this.renderTo, tempStyle;
    if (!revert) {
      while (node && node.style) {
        if (!doc6.body.contains(node) && !node.parentNode) {
          node.hcOrigDetached = true;
          doc6.body.appendChild(node);
        }
        if (getStyle3(node, "display", false) === "none" || node.hcOricDetached) {
          node.hcOrigStyle = {
            display: node.style.display,
            height: node.style.height,
            overflow: node.style.overflow
          };
          tempStyle = {
            display: "block",
            overflow: "hidden"
          };
          if (node !== this.renderTo) {
            tempStyle.height = 0;
          }
          css9(node, tempStyle);
          if (!node.offsetWidth) {
            node.style.setProperty("display", "block", "important");
          }
        }
        node = node.parentNode;
        if (node === doc6.body) {
          break;
        }
      }
    } else {
      while (node && node.style) {
        if (node.hcOrigStyle) {
          css9(node, node.hcOrigStyle);
          delete node.hcOrigStyle;
        }
        if (node.hcOrigDetached) {
          doc6.body.removeChild(node);
          node.hcOrigDetached = false;
        }
        node = node.parentNode;
      }
    }
  }
  setClassName(className) {
    this.container.className = "highcharts-container " + (className || "");
  }
  getContainer() {
    const chart = this, options = chart.options, optionsChart = options.chart, indexAttrName = "data-highcharts-chart", containerId = uniqueKey5();
    let containerStyle, renderTo = chart.renderTo;
    if (!renderTo) {
      chart.renderTo = renderTo = optionsChart.renderTo;
    }
    if (isString9(renderTo)) {
      chart.renderTo = renderTo = doc6.getElementById(renderTo);
    }
    if (!renderTo) {
      error6(13, true, chart);
    }
    const oldChartIndex = pInt7(attr8(renderTo, indexAttrName));
    if (isNumber18(oldChartIndex) && charts4[oldChartIndex] && charts4[oldChartIndex].hasRendered) {
      charts4[oldChartIndex].destroy();
    }
    attr8(renderTo, indexAttrName, chart.index);
    renderTo.innerHTML = AST_default.emptyHTML;
    if (!optionsChart.skipClone && !renderTo.offsetWidth) {
      chart.temporaryDisplay();
    }
    chart.getChartSize();
    const chartHeight = chart.chartHeight;
    let chartWidth = chart.chartWidth;
    css9(renderTo, {
      overflow: "hidden",
      pointerEvents: Globals_default.isChrome ? "fill" : "auto"
    });
    if (!chart.styledMode) {
      containerStyle = extend18({
        position: "relative",
        overflow: "hidden",
        width: chartWidth + "px",
        height: chartHeight + "px",
        textAlign: "left",
        lineHeight: "normal",
        zIndex: 0,
        "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
        userSelect: "none",
        "touch-action": "manipulation",
        outline: "none"
      }, optionsChart.style || {});
    }
    const container = createElement7("div", {
      id: containerId
    }, containerStyle, renderTo);
    chart.container = container;
    chart.getChartSize();
    if (chartWidth !== chart.chartWidth) {
      chartWidth = chart.chartWidth;
      if (!chart.styledMode) {
        css9(container, {
          width: pick21(optionsChart.style?.width, chartWidth + "px")
        });
      }
    }
    chart.containerBox = chart.getContainerBox();
    chart._cursor = container.style.cursor;
    const Renderer = optionsChart.renderer || !svg3 ? RendererRegistry_default.getRendererType(optionsChart.renderer) : SVGRenderer_default;
    chart.renderer = new Renderer(container, chartWidth, chartHeight, undefined, optionsChart.forExport, options.exporting && options.exporting.allowHTML, chart.styledMode);
    setAnimation4(undefined, chart);
    chart.setClassName(optionsChart.className);
    if (!chart.styledMode) {
      chart.renderer.setStyle(optionsChart.style);
    } else {
      for (const key in options.defs) {
        this.renderer.definition(options.defs[key]);
      }
    }
    chart.renderer.chartIndex = chart.index;
    fireEvent13(this, "afterGetContainer");
  }
  getMargins(skipAxes) {
    const { spacing, margin, titleOffset } = this;
    this.resetMargins();
    if (titleOffset[0] && !defined14(margin[0])) {
      this.plotTop = Math.max(this.plotTop, titleOffset[0] + spacing[0]);
    }
    if (titleOffset[2] && !defined14(margin[2])) {
      this.marginBottom = Math.max(this.marginBottom, titleOffset[2] + spacing[2]);
    }
    if (this.legend && this.legend.display) {
      this.legend.adjustMargins(margin, spacing);
    }
    fireEvent13(this, "getMargins");
    if (!skipAxes) {
      this.getAxisMargins();
    }
  }
  getAxisMargins() {
    const chart = this, axisOffset = chart.axisOffset = [0, 0, 0, 0], colorAxis = chart.colorAxis, margin = chart.margin, getOffset = function(axes) {
      axes.forEach(function(axis) {
        if (axis.visible) {
          axis.getOffset();
        }
      });
    };
    if (chart.hasCartesianSeries) {
      getOffset(chart.axes);
    } else if (colorAxis && colorAxis.length) {
      getOffset(colorAxis);
    }
    marginNames2.forEach(function(m, side) {
      if (!defined14(margin[side])) {
        chart[m] += axisOffset[side];
      }
    });
    chart.setChartSize();
  }
  getOptions() {
    return diffObjects3(this.userOptions, defaultOptions8);
  }
  reflow(e) {
    const chart = this, oldBox = chart.containerBox, containerBox = chart.getContainerBox();
    delete chart.pointer?.chartPosition;
    if (!chart.isPrinting && !chart.isResizing && oldBox && containerBox.width) {
      if (containerBox.width !== oldBox.width || containerBox.height !== oldBox.height) {
        Utilities_default.clearTimeout(chart.reflowTimeout);
        chart.reflowTimeout = syncTimeout8(function() {
          if (chart.container) {
            chart.setSize(undefined, undefined, false);
          }
        }, e ? 100 : 0);
      }
      chart.containerBox = containerBox;
    }
  }
  setReflow() {
    const chart = this;
    const runReflow = (e) => {
      if (chart.options?.chart.reflow && chart.hasLoaded) {
        chart.reflow(e);
      }
    };
    if (typeof ResizeObserver === "function") {
      new ResizeObserver(runReflow).observe(chart.renderTo);
    } else {
      const unbind = addEvent11(win9, "resize", runReflow);
      addEvent11(this, "destroy", unbind);
    }
  }
  setSize(width, height, animation) {
    const chart = this, renderer = chart.renderer;
    chart.isResizing += 1;
    setAnimation4(animation, chart);
    const globalAnimation = renderer.globalAnimation;
    chart.oldChartHeight = chart.chartHeight;
    chart.oldChartWidth = chart.chartWidth;
    if (typeof width !== "undefined") {
      chart.options.chart.width = width;
    }
    if (typeof height !== "undefined") {
      chart.options.chart.height = height;
    }
    chart.getChartSize();
    const { chartWidth, chartHeight, scrollablePixelsX = 0, scrollablePixelsY = 0 } = chart;
    if (chart.isDirtyBox || chartWidth !== chart.oldChartWidth || chartHeight !== chart.oldChartHeight) {
      if (!chart.styledMode) {
        (globalAnimation ? animate3 : css9)(chart.container, {
          width: `${chartWidth + scrollablePixelsX}px`,
          height: `${chartHeight + scrollablePixelsY}px`
        }, globalAnimation);
      }
      chart.setChartSize(true);
      renderer.setSize(chartWidth, chartHeight, globalAnimation);
      chart.axes.forEach(function(axis) {
        axis.isDirty = true;
        axis.setScale();
      });
      chart.isDirtyLegend = true;
      chart.isDirtyBox = true;
      chart.layOutTitles();
      chart.getMargins();
      chart.redraw(globalAnimation);
      chart.oldChartHeight = undefined;
      fireEvent13(chart, "resize");
      setTimeout(() => {
        if (chart) {
          fireEvent13(chart, "endResize");
        }
      }, animObject8(globalAnimation).duration);
    }
    chart.isResizing -= 1;
  }
  setChartSize(skipAxes) {
    const chart = this, { chartHeight, chartWidth, inverted, spacing, renderer } = chart, clipOffset = chart.clipOffset, clipRoundFunc = Math[inverted ? "floor" : "round"];
    let plotLeft, plotTop, plotWidth, plotHeight;
    chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
    chart.plotTop = plotTop = Math.round(chart.plotTop);
    chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));
    chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));
    chart.plotSizeX = inverted ? plotHeight : plotWidth;
    chart.plotSizeY = inverted ? plotWidth : plotHeight;
    chart.spacingBox = renderer.spacingBox = {
      x: spacing[3],
      y: spacing[0],
      width: chartWidth - spacing[3] - spacing[1],
      height: chartHeight - spacing[0] - spacing[2]
    };
    chart.plotBox = renderer.plotBox = {
      x: plotLeft,
      y: plotTop,
      width: plotWidth,
      height: plotHeight
    };
    if (clipOffset) {
      chart.clipBox = {
        x: clipRoundFunc(clipOffset[3]),
        y: clipRoundFunc(clipOffset[0]),
        width: clipRoundFunc(chart.plotSizeX - clipOffset[1] - clipOffset[3]),
        height: clipRoundFunc(chart.plotSizeY - clipOffset[0] - clipOffset[2])
      };
    }
    if (!skipAxes) {
      chart.axes.forEach(function(axis) {
        axis.setAxisSize();
        axis.setAxisTranslation();
      });
      renderer.alignElements();
    }
    fireEvent13(chart, "afterSetChartSize", { skipAxes });
  }
  resetMargins() {
    fireEvent13(this, "resetMargins");
    const chart = this, chartOptions = chart.options.chart, plotBorderWidth = chartOptions.plotBorderWidth || 0, halfWidth = plotBorderWidth / 2;
    ["margin", "spacing"].forEach(function splashArrays(target) {
      const value = chartOptions[target], values = isObject9(value) ? value : [value, value, value, value];
      [
        "Top",
        "Right",
        "Bottom",
        "Left"
      ].forEach(function(sideName, side) {
        chart[target][side] = pick21(chartOptions[target + sideName], values[side]);
      });
    });
    marginNames2.forEach(function(m, side) {
      chart[m] = pick21(chart.margin[side], chart.spacing[side]);
    });
    chart.axisOffset = [0, 0, 0, 0];
    chart.clipOffset = [
      halfWidth,
      halfWidth,
      halfWidth,
      halfWidth
    ];
    chart.plotBorderWidth = plotBorderWidth;
  }
  drawChartBox() {
    const chart = this, optionsChart = chart.options.chart, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, styledMode = chart.styledMode, plotBGImage = chart.plotBGImage, chartBackgroundColor = optionsChart.backgroundColor, plotBackgroundColor = optionsChart.plotBackgroundColor, plotBackgroundImage = optionsChart.plotBackgroundImage, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotBox = chart.plotBox, clipRect = chart.clipRect, clipBox = chart.clipBox;
    let { chartBackground, plotBackground, plotBorder } = chart, chartBorderWidth, mgn, bgAttr, verb = "animate";
    if (!chartBackground) {
      chart.chartBackground = chartBackground = renderer.rect().addClass("highcharts-background").add();
      verb = "attr";
    }
    if (!styledMode) {
      chartBorderWidth = optionsChart.borderWidth || 0;
      mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
      bgAttr = {
        fill: chartBackgroundColor || "none"
      };
      if (chartBorderWidth || chartBackground["stroke-width"]) {
        bgAttr.stroke = optionsChart.borderColor;
        bgAttr["stroke-width"] = chartBorderWidth;
      }
      chartBackground.attr(bgAttr).shadow(optionsChart.shadow);
    } else {
      chartBorderWidth = mgn = chartBackground.strokeWidth();
    }
    chartBackground[verb]({
      x: mgn / 2,
      y: mgn / 2,
      width: chartWidth - mgn - chartBorderWidth % 2,
      height: chartHeight - mgn - chartBorderWidth % 2,
      r: optionsChart.borderRadius
    });
    verb = "animate";
    if (!plotBackground) {
      verb = "attr";
      chart.plotBackground = plotBackground = renderer.rect().addClass("highcharts-plot-background").add();
    }
    plotBackground[verb](plotBox);
    if (!styledMode) {
      plotBackground.attr({
        fill: plotBackgroundColor || "none"
      }).shadow(optionsChart.plotShadow);
      if (plotBackgroundImage) {
        if (!plotBGImage) {
          chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight).add();
        } else {
          if (plotBackgroundImage !== plotBGImage.attr("href")) {
            plotBGImage.attr("href", plotBackgroundImage);
          }
          plotBGImage.animate(plotBox);
        }
      }
    }
    if (!clipRect) {
      chart.clipRect = renderer.clipRect(clipBox);
    } else {
      clipRect.animate({
        width: clipBox.width,
        height: clipBox.height
      });
    }
    verb = "animate";
    if (!plotBorder) {
      verb = "attr";
      chart.plotBorder = plotBorder = renderer.rect().addClass("highcharts-plot-border").attr({
        zIndex: 1
      }).add();
    }
    if (!styledMode) {
      plotBorder.attr({
        stroke: optionsChart.plotBorderColor,
        "stroke-width": optionsChart.plotBorderWidth || 0,
        fill: "none"
      });
    }
    plotBorder[verb](plotBorder.crisp({
      x: plotLeft,
      y: plotTop,
      width: plotWidth,
      height: plotHeight
    }, -plotBorder.strokeWidth()));
    chart.isDirtyBox = false;
    fireEvent13(this, "afterDrawChartBox");
  }
  propFromSeries() {
    const chart = this, optionsChart = chart.options.chart, seriesOptions = chart.options.series;
    let i, klass, value;
    ["inverted", "angular", "polar"].forEach(function(key) {
      klass = seriesTypes2[optionsChart.type];
      value = optionsChart[key] || klass && klass.prototype[key];
      i = seriesOptions && seriesOptions.length;
      while (!value && i--) {
        klass = seriesTypes2[seriesOptions[i].type];
        if (klass && klass.prototype[key]) {
          value = true;
        }
      }
      chart[key] = value;
    });
  }
  linkSeries(isUpdating) {
    const chart = this, chartSeries = chart.series;
    chartSeries.forEach(function(series) {
      series.linkedSeries.length = 0;
    });
    chartSeries.forEach(function(series) {
      const { linkedTo } = series.options;
      if (isString9(linkedTo)) {
        let linkedParent;
        if (linkedTo === ":previous") {
          linkedParent = chart.series[series.index - 1];
        } else {
          linkedParent = chart.get(linkedTo);
        }
        if (linkedParent && linkedParent.linkedParent !== series) {
          linkedParent.linkedSeries.push(series);
          series.linkedParent = linkedParent;
          if (linkedParent.enabledDataSorting) {
            series.setDataSortingOptions();
          }
          series.visible = pick21(series.options.visible, linkedParent.options.visible, series.visible);
        }
      }
    });
    fireEvent13(this, "afterLinkSeries", { isUpdating });
  }
  renderSeries() {
    this.series.forEach(function(serie) {
      serie.translate();
      serie.render();
    });
  }
  render() {
    const chart = this, axes = chart.axes, colorAxis = chart.colorAxis, renderer = chart.renderer, axisLayoutRuns = chart.options.chart.axisLayoutRuns || 2, renderAxes = (axes2) => {
      axes2.forEach((axis) => {
        if (axis.visible) {
          axis.render();
        }
      });
    };
    let expectedSpace = 0, redoHorizontal = true, redoVertical, run = 0;
    chart.setTitle();
    fireEvent13(chart, "beforeMargins");
    chart.getStacks?.();
    chart.getMargins(true);
    chart.setChartSize();
    for (const axis of axes) {
      const { options } = axis, { labels } = options;
      if (chart.hasCartesianSeries && axis.horiz && axis.visible && labels.enabled && axis.series.length && axis.coll !== "colorAxis" && !chart.polar) {
        expectedSpace = options.tickLength;
        axis.createGroups();
        const mockTick = new Tick_default(axis, 0, "", true), label = mockTick.createLabel("x", labels);
        mockTick.destroy();
        if (label && pick21(labels.reserveSpace, !isNumber18(options.crossing))) {
          expectedSpace = label.getBBox().height + labels.distance + Math.max(options.offset || 0, 0);
        }
        if (expectedSpace) {
          label?.destroy();
          break;
        }
      }
    }
    chart.plotHeight = Math.max(chart.plotHeight - expectedSpace, 0);
    while ((redoHorizontal || redoVertical || axisLayoutRuns > 1) && run < axisLayoutRuns) {
      const { plotWidth: tempWidth, plotHeight: tempHeight } = chart;
      for (const axis of axes) {
        if (run === 0) {
          axis.setScale();
        } else if (axis.horiz && redoHorizontal || !axis.horiz && redoVertical) {
          axis.setTickInterval(true);
        }
      }
      if (run === 0) {
        chart.getAxisMargins();
      } else {
        chart.getMargins();
      }
      redoHorizontal = tempWidth / chart.plotWidth > (run ? 1 : 1.1);
      redoVertical = tempHeight / chart.plotHeight > (run ? 1 : 1.05);
      run++;
    }
    chart.drawChartBox();
    if (chart.hasCartesianSeries) {
      renderAxes(axes);
    } else if (colorAxis && colorAxis.length) {
      renderAxes(colorAxis);
    }
    if (!chart.seriesGroup) {
      chart.seriesGroup = renderer.g("series-group").attr({ zIndex: 3 }).shadow(chart.options.chart.seriesGroupShadow).add();
    }
    chart.renderSeries();
    chart.addCredits();
    if (chart.setResponsive) {
      chart.setResponsive();
    }
    chart.hasRendered = true;
  }
  addCredits(credits) {
    const chart = this, creds = merge18(true, this.options.credits, credits);
    if (creds.enabled && !this.credits) {
      this.credits = this.renderer.text(creds.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
        if (creds.href) {
          win9.location.href = creds.href;
        }
      }).attr({
        align: creds.position.align,
        zIndex: 8
      });
      if (!chart.styledMode) {
        this.credits.css(creds.style);
      }
      this.credits.add().align(creds.position);
      this.credits.update = function(options) {
        chart.credits = chart.credits.destroy();
        chart.addCredits(options);
      };
    }
  }
  destroy() {
    const chart = this, axes = chart.axes, series = chart.series, container = chart.container, parentNode = container && container.parentNode;
    let i;
    fireEvent13(chart, "destroy");
    if (chart.renderer.forExport) {
      erase8(charts4, chart);
    } else {
      charts4[chart.index] = undefined;
    }
    Globals_default.chartCount--;
    chart.renderTo.removeAttribute("data-highcharts-chart");
    removeEvent7(chart);
    i = axes.length;
    while (i--) {
      axes[i] = axes[i].destroy();
    }
    if (this.scroller && this.scroller.destroy) {
      this.scroller.destroy();
    }
    i = series.length;
    while (i--) {
      series[i] = series[i].destroy();
    }
    [
      "title",
      "subtitle",
      "chartBackground",
      "plotBackground",
      "plotBGImage",
      "plotBorder",
      "seriesGroup",
      "clipRect",
      "credits",
      "pointer",
      "rangeSelector",
      "legend",
      "resetZoomButton",
      "tooltip",
      "renderer"
    ].forEach(function(name) {
      const prop = chart[name];
      if (prop && prop.destroy) {
        chart[name] = prop.destroy();
      }
    });
    if (container) {
      container.innerHTML = AST_default.emptyHTML;
      removeEvent7(container);
      if (parentNode) {
        discardElement4(container);
      }
    }
    objectEach14(chart, function(val, key) {
      delete chart[key];
    });
  }
  firstRender() {
    const chart = this, options = chart.options;
    chart.getContainer();
    chart.resetMargins();
    chart.setChartSize();
    chart.propFromSeries();
    chart.getAxes();
    const series = isArray10(options.series) ? options.series : [];
    options.series = [];
    series.forEach(function(serieOptions) {
      chart.initSeries(serieOptions);
    });
    chart.linkSeries();
    chart.setSortedData();
    fireEvent13(chart, "beforeRender");
    chart.render();
    chart.pointer?.getChartPosition();
    if (!chart.renderer.imgCount && !chart.hasLoaded) {
      chart.onload();
    }
    chart.temporaryDisplay(true);
  }
  onload() {
    this.callbacks.concat([this.callback]).forEach(function(fn) {
      if (fn && typeof this.index !== "undefined") {
        fn.apply(this, [this]);
      }
    }, this);
    fireEvent13(this, "load");
    fireEvent13(this, "render");
    if (defined14(this.index)) {
      this.setReflow();
    }
    this.warnIfA11yModuleNotLoaded();
    this.hasLoaded = true;
  }
  warnIfA11yModuleNotLoaded() {
    const { options, title } = this;
    if (options && !this.accessibility) {
      this.renderer.boxWrapper.attr({
        role: "img",
        "aria-label": (title && title.element.textContent || "").replace(/</g, "&lt;")
      });
      if (!(options.accessibility && options.accessibility.enabled === false)) {
        error6('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, this);
      }
    }
  }
  addSeries(options, redraw, animation) {
    const chart = this;
    let series;
    if (options) {
      redraw = pick21(redraw, true);
      fireEvent13(chart, "addSeries", { options }, function() {
        series = chart.initSeries(options);
        chart.isDirtyLegend = true;
        chart.linkSeries();
        if (series.enabledDataSorting) {
          series.setData(options.data, false);
        }
        fireEvent13(chart, "afterAddSeries", { series });
        if (redraw) {
          chart.redraw(animation);
        }
      });
    }
    return series;
  }
  addAxis(options, isX, redraw, animation) {
    return this.createAxis(isX ? "xAxis" : "yAxis", { axis: options, redraw, animation });
  }
  addColorAxis(options, redraw, animation) {
    return this.createAxis("colorAxis", { axis: options, redraw, animation });
  }
  createAxis(coll, options) {
    const axis = new Axis_default(this, options.axis, coll);
    if (pick21(options.redraw, true)) {
      this.redraw(options.animation);
    }
    return axis;
  }
  showLoading(str) {
    const chart = this, options = chart.options, loadingOptions = options.loading, setLoadingSize = function() {
      if (loadingDiv) {
        css9(loadingDiv, {
          left: chart.plotLeft + "px",
          top: chart.plotTop + "px",
          width: chart.plotWidth + "px",
          height: chart.plotHeight + "px"
        });
      }
    };
    let { loadingDiv, loadingSpan } = chart;
    if (!loadingDiv) {
      chart.loadingDiv = loadingDiv = createElement7("div", {
        className: "highcharts-loading highcharts-loading-hidden"
      }, null, chart.container);
    }
    if (!loadingSpan) {
      chart.loadingSpan = loadingSpan = createElement7("span", { className: "highcharts-loading-inner" }, null, loadingDiv);
      addEvent11(chart, "redraw", setLoadingSize);
    }
    loadingDiv.className = "highcharts-loading";
    AST_default.setElementHTML(loadingSpan, pick21(str, options.lang.loading, ""));
    if (!chart.styledMode) {
      css9(loadingDiv, extend18(loadingOptions.style, {
        zIndex: 10
      }));
      css9(loadingSpan, loadingOptions.labelStyle);
      if (!chart.loadingShown) {
        css9(loadingDiv, {
          opacity: 0,
          display: ""
        });
        animate3(loadingDiv, {
          opacity: loadingOptions.style.opacity || 0.5
        }, {
          duration: loadingOptions.showDuration || 0
        });
      }
    }
    chart.loadingShown = true;
    setLoadingSize();
  }
  hideLoading() {
    const options = this.options, loadingDiv = this.loadingDiv;
    if (loadingDiv) {
      loadingDiv.className = "highcharts-loading highcharts-loading-hidden";
      if (!this.styledMode) {
        animate3(loadingDiv, {
          opacity: 0
        }, {
          duration: options.loading.hideDuration || 100,
          complete: function() {
            css9(loadingDiv, { display: "none" });
          }
        });
      }
    }
    this.loadingShown = false;
  }
  update(options, redraw, oneToOne, animation) {
    const chart = this, adders = {
      credits: "addCredits",
      title: "setTitle",
      subtitle: "setSubtitle",
      caption: "setCaption"
    }, isResponsiveOptions = options.isResponsiveOptions, itemsForRemoval = [];
    let updateAllAxes, updateAllSeries, runSetSize;
    fireEvent13(chart, "update", { options });
    if (!isResponsiveOptions) {
      chart.setResponsive(false, true);
    }
    options = diffObjects3(options, chart.options);
    chart.userOptions = merge18(chart.userOptions, options);
    const optionsChart = options.chart;
    if (optionsChart) {
      merge18(true, chart.options.chart, optionsChart);
      this.setZoomOptions();
      if ("className" in optionsChart) {
        chart.setClassName(optionsChart.className);
      }
      if ("inverted" in optionsChart || "polar" in optionsChart || "type" in optionsChart) {
        chart.propFromSeries();
        updateAllAxes = true;
      }
      if ("alignTicks" in optionsChart) {
        updateAllAxes = true;
      }
      if ("events" in optionsChart) {
        registerEventOptions4(this, optionsChart);
      }
      objectEach14(optionsChart, function(val, key) {
        if (chart.propsRequireUpdateSeries.indexOf("chart." + key) !== -1) {
          updateAllSeries = true;
        }
        if (chart.propsRequireDirtyBox.indexOf(key) !== -1) {
          chart.isDirtyBox = true;
        }
        if (chart.propsRequireReflow.indexOf(key) !== -1) {
          chart.isDirtyBox = true;
          if (!isResponsiveOptions) {
            runSetSize = true;
          }
        }
      });
      if (!chart.styledMode && optionsChart.style) {
        chart.renderer.setStyle(chart.options.chart.style || {});
      }
    }
    if (!chart.styledMode && options.colors) {
      this.options.colors = options.colors;
    }
    if (options.time) {
      if (this.time === defaultTime3) {
        this.time = new Time_default(options.time);
      }
      merge18(true, chart.options.time, options.time);
    }
    objectEach14(options, function(val, key) {
      if (chart[key] && typeof chart[key].update === "function") {
        chart[key].update(val, false);
      } else if (typeof chart[adders[key]] === "function") {
        chart[adders[key]](val);
      } else if (key !== "colors" && chart.collectionsWithUpdate.indexOf(key) === -1) {
        merge18(true, chart.options[key], options[key]);
      }
      if (key !== "chart" && chart.propsRequireUpdateSeries.indexOf(key) !== -1) {
        updateAllSeries = true;
      }
    });
    this.collectionsWithUpdate.forEach(function(coll) {
      if (options[coll]) {
        splat8(options[coll]).forEach(function(newOptions, i) {
          const hasId = defined14(newOptions.id);
          let item;
          if (hasId) {
            item = chart.get(newOptions.id);
          }
          if (!item && chart[coll]) {
            item = chart[coll][pick21(newOptions.index, i)];
            if (item && (hasId && defined14(item.options.id) || item.options.isInternal)) {
              item = undefined;
            }
          }
          if (item && item.coll === coll) {
            item.update(newOptions, false);
            if (oneToOne) {
              item.touched = true;
            }
          }
          if (!item && oneToOne && chart.collectionsWithInit[coll]) {
            chart.collectionsWithInit[coll][0].apply(chart, [
              newOptions
            ].concat(chart.collectionsWithInit[coll][1] || []).concat([
              false
            ])).touched = true;
          }
        });
        if (oneToOne) {
          chart[coll].forEach(function(item) {
            if (!item.touched && !item.options.isInternal) {
              itemsForRemoval.push(item);
            } else {
              delete item.touched;
            }
          });
        }
      }
    });
    itemsForRemoval.forEach(function(item) {
      if (item.chart && item.remove) {
        item.remove(false);
      }
    });
    if (updateAllAxes) {
      chart.axes.forEach(function(axis) {
        axis.update({}, false);
      });
    }
    if (updateAllSeries) {
      chart.getSeriesOrderByLinks().forEach(function(series) {
        if (series.chart) {
          series.update({}, false);
        }
      }, this);
    }
    const newWidth = optionsChart && optionsChart.width;
    const newHeight = optionsChart && (isString9(optionsChart.height) ? relativeLength4(optionsChart.height, newWidth || chart.chartWidth) : optionsChart.height);
    if (runSetSize || isNumber18(newWidth) && newWidth !== chart.chartWidth || isNumber18(newHeight) && newHeight !== chart.chartHeight) {
      chart.setSize(newWidth, newHeight, animation);
    } else if (pick21(redraw, true)) {
      chart.redraw(animation);
    }
    fireEvent13(chart, "afterUpdate", {
      options,
      redraw,
      animation
    });
  }
  setSubtitle(options, redraw) {
    this.applyDescription("subtitle", options);
    this.layOutTitles(redraw);
  }
  setCaption(options, redraw) {
    this.applyDescription("caption", options);
    this.layOutTitles(redraw);
  }
  showResetZoom() {
    const chart = this, lang = defaultOptions8.lang, btnOptions = chart.zooming.resetButton, theme = btnOptions.theme, alignTo = btnOptions.relativeTo === "chart" || btnOptions.relativeTo === "spacingBox" ? null : "plotBox";
    function zoomOut() {
      chart.zoomOut();
    }
    fireEvent13(this, "beforeShowResetZoom", null, function() {
      chart.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme).attr({
        align: btnOptions.position.align,
        title: lang.resetZoomTitle
      }).addClass("highcharts-reset-zoom").add().align(btnOptions.position, false, alignTo);
    });
    fireEvent13(this, "afterShowResetZoom");
  }
  zoomOut() {
    fireEvent13(this, "selection", { resetSelection: true }, () => this.transform({ reset: true, trigger: "zoom" }));
  }
  pan(event, panning) {
    const chart = this, panningOptions = typeof panning === "object" ? panning : {
      enabled: panning,
      type: "x"
    }, type = panningOptions.type, axes = type && chart[{
      x: "xAxis",
      xy: "axes",
      y: "yAxis"
    }[type]].filter((axis) => axis.options.panningEnabled && !axis.options.isInternal), chartOptions = chart.options.chart;
    if (chartOptions?.panning) {
      chartOptions.panning = panningOptions;
    }
    fireEvent13(this, "pan", { originalEvent: event }, () => {
      chart.transform({
        axes,
        event,
        to: {
          x: event.chartX - (chart.mouseDownX || 0),
          y: event.chartY - (chart.mouseDownY || 0)
        },
        trigger: "pan"
      });
      css9(chart.container, { cursor: "move" });
    });
  }
  transform(params) {
    const { axes = this.axes, event, from = {}, reset, selection, to = {}, trigger } = params, { inverted } = this;
    let hasZoomed = false, displayButton, isAnyAxisPanning;
    this.hoverPoints?.forEach((point) => point.setState());
    for (const axis of axes) {
      const { horiz, len, minPointOffset = 0, options, reversed } = axis, wh = horiz ? "width" : "height", xy = horiz ? "x" : "y", toLength = pick21(to[wh], axis.len), fromLength = pick21(from[wh], axis.len), scale = Math.abs(toLength) < 10 ? 1 : toLength / fromLength, fromCenter = (from[xy] || 0) + fromLength / 2 - axis.pos, toCenter = (to[xy] ?? axis.pos) + toLength / 2 - axis.pos, move = fromCenter - toCenter / scale, pointRangeDirection = reversed && !inverted || !reversed && inverted ? -1 : 1, minPx = move;
      if (!reset && (fromCenter < 0 || fromCenter > axis.len)) {
        continue;
      }
      let newMin = axis.toValue(minPx, true) + (selection ? 0 : minPointOffset * pointRangeDirection), newMax = axis.toValue(minPx + len / scale, true) - (selection ? 0 : minPointOffset * pointRangeDirection || 0), allExtremes = axis.allExtremes;
      if (newMin > newMax) {
        [newMin, newMax] = [newMax, newMin];
      }
      if (scale === 1 && !reset && axis.coll === "yAxis" && !allExtremes) {
        for (const series of axis.series) {
          const seriesExtremes = series.getExtremes(series.getProcessedData(true).yData, true);
          allExtremes ?? (allExtremes = {
            dataMin: Number.MAX_VALUE,
            dataMax: -Number.MAX_VALUE
          });
          if (isNumber18(seriesExtremes.dataMin) && isNumber18(seriesExtremes.dataMax)) {
            allExtremes.dataMin = Math.min(seriesExtremes.dataMin, allExtremes.dataMin);
            allExtremes.dataMax = Math.max(seriesExtremes.dataMax, allExtremes.dataMax);
          }
        }
        axis.allExtremes = allExtremes;
      }
      const { dataMin, dataMax, min, max } = extend18(axis.getExtremes(), allExtremes || {}), safeDataMin = dataMin ?? options.min, safeDataMax = dataMax ?? options.max, range = newMax - newMin, padRange = axis.categories ? 0 : Math.min(range, safeDataMax - safeDataMin), paddedMin = safeDataMin - padRange * (defined14(options.min) ? 0 : options.minPadding), paddedMax = safeDataMax + padRange * (defined14(options.max) ? 0 : options.maxPadding), allowZoomOutside = axis.allowZoomOutside || scale === 1 || trigger !== "zoom" && scale > 1, floor = Math.min(options.min ?? paddedMin, paddedMin, allowZoomOutside ? min : paddedMin), ceiling = Math.max(options.max ?? paddedMax, paddedMax, allowZoomOutside ? max : paddedMax);
      if (!axis.isOrdinal || scale !== 1 || reset) {
        if (newMin < floor) {
          newMin = floor;
          if (scale >= 1) {
            newMax = newMin + range;
          }
        }
        if (newMax > ceiling) {
          newMax = ceiling;
          if (scale >= 1) {
            newMin = newMax - range;
          }
        }
        if (reset || axis.series.length && (newMin !== min || newMax !== max) && newMin >= floor && newMax <= ceiling) {
          if (selection) {
            selection[axis.coll].push({
              axis,
              min: newMin,
              max: newMax
            });
          } else {
            axis.isPanning = trigger !== "zoom";
            if (axis.isPanning) {
              isAnyAxisPanning = true;
            }
            axis.setExtremes(reset ? undefined : newMin, reset ? undefined : newMax, false, false, { move, trigger, scale });
            if (!reset && (newMin > floor || newMax < ceiling) && trigger !== "mousewheel") {
              displayButton = true;
            }
          }
          hasZoomed = true;
        }
        if (event) {
          this[horiz ? "mouseDownX" : "mouseDownY"] = event[horiz ? "chartX" : "chartY"];
        }
      }
    }
    if (hasZoomed) {
      if (selection) {
        fireEvent13(this, "selection", selection, () => {
          delete params.selection;
          params.trigger = "zoom";
          this.transform(params);
        });
      } else {
        if (displayButton && !isAnyAxisPanning && !this.resetZoomButton) {
          this.showResetZoom();
        } else if (!displayButton && this.resetZoomButton) {
          this.resetZoomButton = this.resetZoomButton.destroy();
        }
        this.redraw(trigger === "zoom" && (this.options.chart.animation ?? this.pointCount < 100));
      }
    }
    return hasZoomed;
  }
}
extend18(Chart.prototype, {
  callbacks: [],
  collectionsWithInit: {
    xAxis: [Chart.prototype.addAxis, [true]],
    yAxis: [Chart.prototype.addAxis, [false]],
    series: [Chart.prototype.addSeries]
  },
  collectionsWithUpdate: [
    "xAxis",
    "yAxis",
    "series"
  ],
  propsRequireDirtyBox: [
    "backgroundColor",
    "borderColor",
    "borderWidth",
    "borderRadius",
    "plotBackgroundColor",
    "plotBackgroundImage",
    "plotBorderColor",
    "plotBorderWidth",
    "plotShadow",
    "shadow"
  ],
  propsRequireReflow: [
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "spacing",
    "spacingTop",
    "spacingRight",
    "spacingBottom",
    "spacingLeft"
  ],
  propsRequireUpdateSeries: [
    "chart.inverted",
    "chart.polar",
    "chart.ignoreHiddenSeries",
    "chart.type",
    "colors",
    "plotOptions",
    "time",
    "tooltip"
  ]
});
var Chart_default = Chart;

// node_modules/highcharts/es-modules/Extensions/ScrollablePlotArea.js
var onChartRender = function() {
  let scrollablePlotArea = this.scrollablePlotArea;
  if ((this.scrollablePixelsX || this.scrollablePixelsY) && !scrollablePlotArea) {
    this.scrollablePlotArea = scrollablePlotArea = new ScrollablePlotArea(this);
  }
  scrollablePlotArea?.applyFixed();
};
var markDirty = function() {
  if (this.chart.scrollablePlotArea) {
    this.chart.scrollablePlotArea.isDirty = true;
  }
};
var { stop: stop3 } = AnimationUtilities_default;
var { composed: composed5 } = Globals_default;
var { addEvent: addEvent12, createElement: createElement8, css: css10, defined: defined15, merge: merge19, pushUnique: pushUnique8 } = Utilities_default;

class ScrollablePlotArea {
  static compose(AxisClass, ChartClass, SeriesClass) {
    if (pushUnique8(composed5, this.compose)) {
      addEvent12(AxisClass, "afterInit", markDirty);
      addEvent12(ChartClass, "afterSetChartSize", (e) => this.afterSetSize(e.target, e));
      addEvent12(ChartClass, "render", onChartRender);
      addEvent12(SeriesClass, "show", markDirty);
    }
  }
  static afterSetSize(chart, e) {
    const { minWidth, minHeight } = chart.options.chart.scrollablePlotArea || {}, { clipBox, plotBox, inverted, renderer } = chart;
    let scrollablePixelsX, scrollablePixelsY, recalculateHoriz;
    if (!renderer.forExport) {
      if (minWidth) {
        chart.scrollablePixelsX = scrollablePixelsX = Math.max(0, minWidth - chart.chartWidth);
        if (scrollablePixelsX) {
          chart.scrollablePlotBox = merge19(chart.plotBox);
          plotBox.width = chart.plotWidth += scrollablePixelsX;
          clipBox[inverted ? "height" : "width"] += scrollablePixelsX;
          recalculateHoriz = true;
        }
      } else if (minHeight) {
        chart.scrollablePixelsY = scrollablePixelsY = Math.max(0, minHeight - chart.chartHeight);
        if (defined15(scrollablePixelsY)) {
          chart.scrollablePlotBox = merge19(chart.plotBox);
          plotBox.height = chart.plotHeight += scrollablePixelsY;
          clipBox[inverted ? "width" : "height"] += scrollablePixelsY;
          recalculateHoriz = false;
        }
      }
      if (defined15(recalculateHoriz) && !e.skipAxes) {
        for (const axis of chart.axes) {
          if (axis.horiz === recalculateHoriz) {
            axis.setAxisSize();
            axis.setAxisTranslation();
          }
        }
      }
    }
  }
  constructor(chart) {
    const chartOptions = chart.options.chart, Renderer = RendererRegistry_default.getRendererType(), scrollableOptions = chartOptions.scrollablePlotArea || {}, moveFixedElements = this.moveFixedElements.bind(this), styles = {
      WebkitOverflowScrolling: "touch",
      overflowX: "hidden",
      overflowY: "hidden"
    };
    if (chart.scrollablePixelsX) {
      styles.overflowX = "auto";
    }
    if (chart.scrollablePixelsY) {
      styles.overflowY = "auto";
    }
    this.chart = chart;
    const parentDiv = this.parentDiv = createElement8("div", {
      className: "highcharts-scrolling-parent"
    }, {
      position: "relative"
    }, chart.renderTo), scrollingContainer = this.scrollingContainer = createElement8("div", {
      className: "highcharts-scrolling"
    }, styles, parentDiv), innerContainer = this.innerContainer = createElement8("div", {
      className: "highcharts-inner-container"
    }, undefined, scrollingContainer), fixedDiv = this.fixedDiv = createElement8("div", {
      className: "highcharts-fixed"
    }, {
      position: "absolute",
      overflow: "hidden",
      pointerEvents: "none",
      zIndex: (chartOptions.style?.zIndex || 0) + 2,
      top: 0
    }, undefined, true), fixedRenderer = this.fixedRenderer = new Renderer(fixedDiv, chart.chartWidth, chart.chartHeight, chartOptions.style);
    this.mask = fixedRenderer.path().attr({
      fill: chartOptions.backgroundColor || "#fff",
      "fill-opacity": scrollableOptions.opacity ?? 0.85,
      zIndex: -1
    }).addClass("highcharts-scrollable-mask").add();
    scrollingContainer.parentNode.insertBefore(fixedDiv, scrollingContainer);
    css10(chart.renderTo, { overflow: "visible" });
    addEvent12(chart, "afterShowResetZoom", moveFixedElements);
    addEvent12(chart, "afterApplyDrilldown", moveFixedElements);
    addEvent12(chart, "afterLayOutTitles", moveFixedElements);
    let lastHoverPoint;
    addEvent12(scrollingContainer, "scroll", () => {
      const { pointer, hoverPoint } = chart;
      if (pointer) {
        delete pointer.chartPosition;
        if (hoverPoint) {
          lastHoverPoint = hoverPoint;
        }
        pointer.runPointActions(undefined, lastHoverPoint, true);
      }
    });
    innerContainer.appendChild(chart.container);
  }
  applyFixed() {
    const { chart, fixedRenderer, isDirty, scrollingContainer } = this, { axisOffset, chartWidth, chartHeight, container, plotHeight, plotLeft, plotTop, plotWidth, scrollablePixelsX = 0, scrollablePixelsY = 0 } = chart, chartOptions = chart.options.chart, scrollableOptions = chartOptions.scrollablePlotArea || {}, { scrollPositionX = 0, scrollPositionY = 0 } = scrollableOptions, scrollableWidth = chartWidth + scrollablePixelsX, scrollableHeight = chartHeight + scrollablePixelsY;
    fixedRenderer.setSize(chartWidth, chartHeight);
    if (isDirty ?? true) {
      this.isDirty = false;
      this.moveFixedElements();
    }
    stop3(chart.container);
    css10(container, {
      width: `${scrollableWidth}px`,
      height: `${scrollableHeight}px`
    });
    chart.renderer.boxWrapper.attr({
      width: scrollableWidth,
      height: scrollableHeight,
      viewBox: [0, 0, scrollableWidth, scrollableHeight].join(" ")
    });
    chart.chartBackground?.attr({
      width: scrollableWidth,
      height: scrollableHeight
    });
    css10(scrollingContainer, {
      width: `${chartWidth}px`,
      height: `${chartHeight}px`
    });
    if (!defined15(isDirty)) {
      scrollingContainer.scrollLeft = scrollablePixelsX * scrollPositionX;
      scrollingContainer.scrollTop = scrollablePixelsY * scrollPositionY;
    }
    const maskTop = plotTop - axisOffset[0] - 1, maskLeft = plotLeft - axisOffset[3] - 1, maskBottom = plotTop + plotHeight + axisOffset[2] + 1, maskRight = plotLeft + plotWidth + axisOffset[1] + 1, maskPlotRight = plotLeft + plotWidth - scrollablePixelsX, maskPlotBottom = plotTop + plotHeight - scrollablePixelsY;
    let d = [["M", 0, 0]];
    if (scrollablePixelsX) {
      d = [
        ["M", 0, maskTop],
        ["L", plotLeft - 1, maskTop],
        ["L", plotLeft - 1, maskBottom],
        ["L", 0, maskBottom],
        ["Z"],
        ["M", maskPlotRight, maskTop],
        ["L", chartWidth, maskTop],
        ["L", chartWidth, maskBottom],
        ["L", maskPlotRight, maskBottom],
        ["Z"]
      ];
    } else if (scrollablePixelsY) {
      d = [
        ["M", maskLeft, 0],
        ["L", maskLeft, plotTop - 1],
        ["L", maskRight, plotTop - 1],
        ["L", maskRight, 0],
        ["Z"],
        ["M", maskLeft, maskPlotBottom],
        ["L", maskLeft, chartHeight],
        ["L", maskRight, chartHeight],
        ["L", maskRight, maskPlotBottom],
        ["Z"]
      ];
    }
    if (chart.redrawTrigger !== "adjustHeight") {
      this.mask.attr({ d });
    }
  }
  moveFixedElements() {
    const { container, inverted, scrollablePixelsX, scrollablePixelsY } = this.chart, fixedRenderer = this.fixedRenderer, fixedSelectors = ScrollablePlotArea.fixedSelectors;
    let axisClass;
    if (scrollablePixelsX && !inverted) {
      axisClass = ".highcharts-yaxis";
    } else if (scrollablePixelsX && inverted) {
      axisClass = ".highcharts-xaxis";
    } else if (scrollablePixelsY && !inverted) {
      axisClass = ".highcharts-xaxis";
    } else if (scrollablePixelsY && inverted) {
      axisClass = ".highcharts-yaxis";
    }
    if (axisClass) {
      fixedSelectors.push(`${axisClass}:not(.highcharts-radial-axis)`, `${axisClass}-labels:not(.highcharts-radial-axis-labels)`);
    }
    for (const className of fixedSelectors) {
      [].forEach.call(container.querySelectorAll(className), (elem) => {
        (elem.namespaceURI === fixedRenderer.SVG_NS ? fixedRenderer.box : fixedRenderer.box.parentNode).appendChild(elem);
        elem.style.pointerEvents = "auto";
      });
    }
  }
}
ScrollablePlotArea.fixedSelectors = [
  ".highcharts-breadcrumbs-group",
  ".highcharts-contextbutton",
  ".highcharts-caption",
  ".highcharts-credits",
  ".highcharts-drillup-button",
  ".highcharts-legend",
  ".highcharts-legend-checkbox",
  ".highcharts-navigator-series",
  ".highcharts-navigator-xaxis",
  ".highcharts-navigator-yaxis",
  ".highcharts-navigator",
  ".highcharts-range-selector-group",
  ".highcharts-reset-zoom",
  ".highcharts-scrollbar",
  ".highcharts-subtitle",
  ".highcharts-title"
];
var ScrollablePlotArea_default = ScrollablePlotArea;

// node_modules/highcharts/es-modules/Core/Axis/Stacking/StackItem.js
var { format: format5 } = Templating_default;
var { series: Series4 } = SeriesRegistry_default;
var { destroyObjectProperties: destroyObjectProperties7, fireEvent: fireEvent14, isNumber: isNumber19, pick: pick22 } = Utilities_default;

class StackItem {
  constructor(axis, options, negativeValue, x, stackOption) {
    const inverted = axis.chart.inverted, reversed = axis.reversed;
    this.axis = axis;
    const isNegative = this.isNegative = !!negativeValue !== !!reversed;
    this.options = options = options || {};
    this.x = x;
    this.total = null;
    this.cumulative = null;
    this.points = {};
    this.hasValidPoints = false;
    this.stack = stackOption;
    this.leftCliff = 0;
    this.rightCliff = 0;
    this.alignOptions = {
      align: options.align || (inverted ? isNegative ? "left" : "right" : "center"),
      verticalAlign: options.verticalAlign || (inverted ? "middle" : isNegative ? "bottom" : "top"),
      y: options.y,
      x: options.x
    };
    this.textAlign = options.textAlign || (inverted ? !isNegative ? "left" : "right" : "center");
  }
  destroy() {
    destroyObjectProperties7(this, this.axis);
  }
  render(group) {
    const chart = this.axis.chart, options = this.options, formatOption = options.format, str = formatOption ? format5(formatOption, this, chart) : options.formatter.call(this);
    if (this.label) {
      this.label.attr({ text: str, visibility: "hidden" });
    } else {
      this.label = chart.renderer.label(str, null, undefined, options.shape, undefined, undefined, options.useHTML, false, "stack-labels");
      const attr9 = {
        r: options.borderRadius || 0,
        text: str,
        padding: pick22(options.padding, 5),
        visibility: "hidden"
      };
      if (!chart.styledMode) {
        attr9.fill = options.backgroundColor;
        attr9.stroke = options.borderColor;
        attr9["stroke-width"] = options.borderWidth;
        this.label.css(options.style || {});
      }
      this.label.attr(attr9);
      if (!this.label.added) {
        this.label.add(group);
      }
    }
    this.label.labelrank = chart.plotSizeY;
    fireEvent14(this, "afterRender");
  }
  setOffset(xOffset, width, boxBottom, boxTop, defaultX, xAxis2) {
    const { alignOptions, axis, label, options, textAlign } = this, chart = axis.chart, stackBox = this.getStackBox({
      xOffset,
      width,
      boxBottom,
      boxTop,
      defaultX,
      xAxis: xAxis2
    }), { verticalAlign } = alignOptions;
    if (label && stackBox) {
      const labelBox = label.getBBox(undefined, 0), padding = label.padding;
      let isJustify = pick22(options.overflow, "justify") === "justify", visible;
      alignOptions.x = options.x || 0;
      alignOptions.y = options.y || 0;
      const { x, y } = this.adjustStackPosition({
        labelBox,
        verticalAlign,
        textAlign
      });
      stackBox.x -= x;
      stackBox.y -= y;
      label.align(alignOptions, false, stackBox);
      visible = chart.isInsidePlot(label.alignAttr.x + alignOptions.x + x, label.alignAttr.y + alignOptions.y + y);
      if (!visible) {
        isJustify = false;
      }
      if (isJustify) {
        Series4.prototype.justifyDataLabel.call(axis, label, alignOptions, label.alignAttr, labelBox, stackBox);
      }
      label.attr({
        x: label.alignAttr.x,
        y: label.alignAttr.y,
        rotation: options.rotation,
        rotationOriginX: labelBox.width * {
          left: 0,
          center: 0.5,
          right: 1
        }[options.textAlign || "center"],
        rotationOriginY: labelBox.height / 2
      });
      if (pick22(!isJustify && options.crop, true)) {
        visible = isNumber19(label.x) && isNumber19(label.y) && chart.isInsidePlot(label.x - padding + (label.width || 0), label.y) && chart.isInsidePlot(label.x + padding, label.y);
      }
      label[visible ? "show" : "hide"]();
    }
    fireEvent14(this, "afterSetOffset", { xOffset, width });
  }
  adjustStackPosition({ labelBox, verticalAlign, textAlign }) {
    const factorMap = {
      bottom: 0,
      middle: 1,
      top: 2,
      right: 1,
      center: 0,
      left: -1
    }, verticalAlignFactor = factorMap[verticalAlign], textAlignFactor = factorMap[textAlign];
    return {
      x: labelBox.width / 2 + labelBox.width / 2 * textAlignFactor,
      y: labelBox.height / 2 * verticalAlignFactor
    };
  }
  getStackBox(stackBoxProps) {
    const stackItem = this, axis = this.axis, chart = axis.chart, { boxTop, defaultX, xOffset, width, boxBottom } = stackBoxProps, totalStackValue = axis.stacking.usePercentage ? 100 : pick22(boxTop, this.total, 0), y = axis.toPixels(totalStackValue), xAxis2 = stackBoxProps.xAxis || chart.xAxis[0], x = pick22(defaultX, xAxis2.translate(this.x)) + xOffset, yZero = axis.toPixels(boxBottom || isNumber19(axis.min) && axis.logarithmic && axis.logarithmic.lin2log(axis.min) || 0), height = Math.abs(y - yZero), inverted = chart.inverted, neg = stackItem.isNegative;
    return inverted ? {
      x: (neg ? y : y - height) - chart.plotLeft,
      y: xAxis2.height - x - width + xAxis2.top - chart.plotTop,
      width: height,
      height: width
    } : {
      x: x + xAxis2.transB - chart.plotLeft,
      y: (neg ? y - height : y) - chart.plotTop,
      width,
      height
    };
  }
}
var StackItem_default = StackItem;

// node_modules/highcharts/es-modules/Core/Axis/Stacking/StackingAxis.js
var chartGetStacks = function() {
  const chart = this, inverted = chart.inverted;
  chart.axes.forEach((axis) => {
    if (axis.stacking && axis.stacking.stacks && axis.hasVisibleSeries) {
      axis.stacking.oldStacks = axis.stacking.stacks;
    }
  });
  chart.series.forEach((series) => {
    const xAxisOptions = series.xAxis && series.xAxis.options || {};
    if (series.options.stacking && series.reserveSpace()) {
      series.stackKey = [
        series.type,
        pick23(series.options.stack, ""),
        inverted ? xAxisOptions.top : xAxisOptions.left,
        inverted ? xAxisOptions.height : xAxisOptions.width
      ].join(",");
    }
  });
};
var onAxisDestroy = function() {
  const stacking = this.stacking;
  if (stacking) {
    const stacks = stacking.stacks;
    objectEach15(stacks, (stack, stackKey) => {
      destroyObjectProperties8(stack);
      delete stacks[stackKey];
    });
    stacking.stackTotalGroup?.destroy();
  }
};
var onAxisInit = function() {
  if (!this.stacking) {
    this.stacking = new AxisAdditions(this);
  }
};
var seriesGetStackIndicator = function(stackIndicator, x, index, key) {
  if (!defined16(stackIndicator) || stackIndicator.x !== x || key && stackIndicator.stackKey !== key) {
    stackIndicator = {
      x,
      index: 0,
      key,
      stackKey: key
    };
  } else {
    stackIndicator.index++;
  }
  stackIndicator.key = [index, x, stackIndicator.index].join(",");
  return stackIndicator;
};
var seriesModifyStacks = function() {
  const series = this, yAxis2 = series.yAxis, stackKey = series.stackKey || "", stacks = yAxis2.stacking.stacks, processedXData = series.processedXData, stacking = series.options.stacking, stacker = series[stacking + "Stacker"];
  let stackIndicator;
  if (stacker) {
    [stackKey, "-" + stackKey].forEach((key) => {
      let i = processedXData.length, x, stackItem, pointExtremes;
      while (i--) {
        x = processedXData[i];
        stackIndicator = series.getStackIndicator(stackIndicator, x, series.index, key);
        stackItem = stacks[key]?.[x];
        pointExtremes = stackItem?.points[stackIndicator.key || ""];
        if (pointExtremes) {
          stacker.call(series, pointExtremes, stackItem, i);
        }
      }
    });
  }
};
var seriesPercentStacker = function(pointExtremes, stack, i) {
  const totalFactor = stack.total ? 100 / stack.total : 0;
  pointExtremes[0] = correctFloat5(pointExtremes[0] * totalFactor);
  pointExtremes[1] = correctFloat5(pointExtremes[1] * totalFactor);
  this.stackedYData[i] = pointExtremes[1];
};
var seriesSetGroupedPoints = function(axis) {
  if (this.is("column") || this.is("columnrange")) {
    if (this.options.centerInCategory && !this.options.stacking && this.chart.series.length > 1) {
      seriesProto.setStackedPoints.call(this, axis, "group");
    } else {
      axis.stacking.resetStacks();
    }
  }
};
var seriesSetStackedPoints = function(axis, stackingParam) {
  const type = stackingParam || this.options.stacking;
  if (!type || !this.reserveSpace() || ({ group: "xAxis" }[type] || "yAxis") !== axis.coll) {
    return;
  }
  const series = this, xData = series.processedXData, yData = series.processedYData, stackedYData = [], yDataLength = yData.length, seriesOptions = series.options, threshold = seriesOptions.threshold || 0, stackThreshold = seriesOptions.startFromThreshold ? threshold : 0, stackOption = seriesOptions.stack, stackKey = stackingParam ? `${series.type},${type}` : series.stackKey || "", negKey = "-" + stackKey, negStacks = series.negStacks, stacking = axis.stacking, stacks = stacking.stacks, oldStacks = stacking.oldStacks;
  let stackIndicator, isNegative, stack, other, key, pointKey, i, x, y;
  stacking.stacksTouched += 1;
  for (i = 0;i < yDataLength; i++) {
    x = xData[i];
    y = yData[i];
    stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
    pointKey = stackIndicator.key || "";
    isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
    key = isNegative ? negKey : stackKey;
    if (!stacks[key]) {
      stacks[key] = {};
    }
    if (!stacks[key][x]) {
      if (oldStacks[key]?.[x]) {
        stacks[key][x] = oldStacks[key][x];
        stacks[key][x].total = null;
      } else {
        stacks[key][x] = new StackItem_default(axis, axis.options.stackLabels, !!isNegative, x, stackOption);
      }
    }
    stack = stacks[key][x];
    if (y !== null) {
      stack.points[pointKey] = stack.points[series.index] = [
        pick23(stack.cumulative, stackThreshold)
      ];
      if (!defined16(stack.cumulative)) {
        stack.base = pointKey;
      }
      stack.touched = stacking.stacksTouched;
      if (stackIndicator.index > 0 && series.singleStacks === false) {
        stack.points[pointKey][0] = stack.points[series.index + "," + x + ",0"][0];
      }
    } else {
      delete stack.points[pointKey];
      delete stack.points[series.index];
    }
    let total = stack.total || 0;
    if (type === "percent") {
      other = isNegative ? stackKey : negKey;
      if (negStacks && stacks[other]?.[x]) {
        other = stacks[other][x];
        total = other.total = Math.max(other.total || 0, total) + Math.abs(y) || 0;
      } else {
        total = correctFloat5(total + (Math.abs(y) || 0));
      }
    } else if (type === "group") {
      if (isArray11(y)) {
        y = y[0];
      }
      if (y !== null) {
        total++;
      }
    } else {
      total = correctFloat5(total + (y || 0));
    }
    if (type === "group") {
      stack.cumulative = (total || 1) - 1;
    } else {
      stack.cumulative = correctFloat5(pick23(stack.cumulative, stackThreshold) + (y || 0));
    }
    stack.total = total;
    if (y !== null) {
      stack.points[pointKey].push(stack.cumulative);
      stackedYData[i] = stack.cumulative;
      stack.hasValidPoints = true;
    }
  }
  if (type === "percent") {
    stacking.usePercentage = true;
  }
  if (type !== "group") {
    this.stackedYData = stackedYData;
  }
  stacking.oldStacks = {};
};
var { getDeferredAnimation: getDeferredAnimation2 } = AnimationUtilities_default;
var { series: { prototype: seriesProto } } = SeriesRegistry_default;
var { addEvent: addEvent13, correctFloat: correctFloat5, defined: defined16, destroyObjectProperties: destroyObjectProperties8, fireEvent: fireEvent15, isArray: isArray11, isNumber: isNumber20, objectEach: objectEach15, pick: pick23 } = Utilities_default;

class AxisAdditions {
  constructor(axis) {
    this.oldStacks = {};
    this.stacks = {};
    this.stacksTouched = 0;
    this.axis = axis;
  }
  buildStacks() {
    const stacking = this, axis = stacking.axis, axisSeries = axis.series, isXAxis = axis.coll === "xAxis", reversedStacks = axis.options.reversedStacks, len = axisSeries.length;
    let actualSeries, i;
    this.resetStacks();
    stacking.usePercentage = false;
    i = len;
    while (i--) {
      actualSeries = axisSeries[reversedStacks ? i : len - i - 1];
      if (isXAxis) {
        actualSeries.setGroupedPoints(axis);
      }
      actualSeries.setStackedPoints(axis);
    }
    if (!isXAxis) {
      for (i = 0;i < len; i++) {
        axisSeries[i].modifyStacks();
      }
    }
    fireEvent15(axis, "afterBuildStacks");
  }
  cleanStacks() {
    if (this.oldStacks) {
      this.stacks = this.oldStacks;
      objectEach15(this.stacks, (type) => {
        objectEach15(type, (stack) => {
          stack.cumulative = stack.total;
        });
      });
    }
  }
  resetStacks() {
    objectEach15(this.stacks, (type) => {
      objectEach15(type, (stack, x) => {
        if (isNumber20(stack.touched) && stack.touched < this.stacksTouched) {
          stack.destroy();
          delete type[x];
        } else {
          stack.total = null;
          stack.cumulative = null;
        }
      });
    });
  }
  renderStackTotals() {
    const stacking = this, axis = stacking.axis, chart = axis.chart, renderer = chart.renderer, stacks = stacking.stacks, stackLabelsAnim = axis.options.stackLabels?.animation, animationConfig = getDeferredAnimation2(chart, stackLabelsAnim || false), stackTotalGroup = stacking.stackTotalGroup = stacking.stackTotalGroup || renderer.g("stack-labels").attr({
      zIndex: 6,
      opacity: 0
    }).add();
    stackTotalGroup.translate(chart.plotLeft, chart.plotTop);
    objectEach15(stacks, (type) => {
      objectEach15(type, (stack) => {
        stack.render(stackTotalGroup);
      });
    });
    stackTotalGroup.animate({
      opacity: 1
    }, animationConfig);
  }
}
var StackingAxis;
(function(StackingAxis2) {
  function compose(AxisClass, ChartClass, SeriesClass) {
    const chartProto = ChartClass.prototype, seriesProto2 = SeriesClass.prototype;
    if (!chartProto.getStacks) {
      addEvent13(AxisClass, "init", onAxisInit);
      addEvent13(AxisClass, "destroy", onAxisDestroy);
      chartProto.getStacks = chartGetStacks;
      seriesProto2.getStackIndicator = seriesGetStackIndicator;
      seriesProto2.modifyStacks = seriesModifyStacks;
      seriesProto2.percentStacker = seriesPercentStacker;
      seriesProto2.setGroupedPoints = seriesSetGroupedPoints;
      seriesProto2.setStackedPoints = seriesSetStackedPoints;
    }
  }
  StackingAxis2.compose = compose;
})(StackingAxis || (StackingAxis = {}));
var StackingAxis_default = StackingAxis;

// node_modules/highcharts/es-modules/Series/Line/LineSeries.js
var { defined: defined17, merge: merge20, isObject: isObject10 } = Utilities_default;

class LineSeries extends Series_default {
  drawGraph() {
    const options = this.options, graphPath = (this.gappedPath || this.getGraphPath).call(this), styledMode = this.chart.styledMode;
    [this, ...this.zones].forEach((owner, i) => {
      let attribs, graph = owner.graph;
      const verb = graph ? "animate" : "attr", dashStyle = owner.dashStyle || options.dashStyle;
      if (graph) {
        graph.endX = this.preventGraphAnimation ? null : graphPath.xMap;
        graph.animate({ d: graphPath });
      } else if (graphPath.length) {
        owner.graph = graph = this.chart.renderer.path(graphPath).addClass("highcharts-graph" + (i ? ` highcharts-zone-graph-${i - 1} ` : " ") + (i && owner.className || "")).attr({ zIndex: 1 }).add(this.group);
      }
      if (graph && !styledMode) {
        attribs = {
          stroke: !i && options.lineColor || owner.color || this.color || "#cccccc",
          "stroke-width": options.lineWidth || 0,
          fill: this.fillGraph && this.color || "none"
        };
        if (dashStyle) {
          attribs.dashstyle = dashStyle;
        } else if (options.linecap !== "square") {
          attribs["stroke-linecap"] = attribs["stroke-linejoin"] = "round";
        }
        graph[verb](attribs).shadow(i < 2 && options.shadow && merge20({ filterUnits: "userSpaceOnUse" }, isObject10(options.shadow) ? options.shadow : {}));
      }
      if (graph) {
        graph.startX = graphPath.xMap;
        graph.isArea = graphPath.isArea;
      }
    });
  }
  getGraphPath(points, nullsAsZeroes, connectCliffs) {
    const series = this, options = series.options, graphPath = [], xMap = [];
    let gap, step = options.step;
    points = points || series.points;
    const reversed = points.reversed;
    if (reversed) {
      points.reverse();
    }
    step = {
      right: 1,
      center: 2
    }[step] || step && 3;
    if (step && reversed) {
      step = 4 - step;
    }
    points = this.getValidPoints(points, false, !(options.connectNulls && !nullsAsZeroes && !connectCliffs));
    points.forEach(function(point, i) {
      const { plotX, plotY } = point, lastPoint = points[i - 1], isNull = point.isNull || typeof plotY !== "number";
      let pathToPoint;
      if ((point.leftCliff || lastPoint && lastPoint.rightCliff) && !connectCliffs) {
        gap = true;
      }
      if (isNull && !defined17(nullsAsZeroes) && i > 0) {
        gap = !options.connectNulls;
      } else if (isNull && !nullsAsZeroes) {
        gap = true;
      } else {
        if (i === 0 || gap) {
          pathToPoint = [[
            "M",
            point.plotX,
            point.plotY
          ]];
        } else if (series.getPointSpline) {
          pathToPoint = [series.getPointSpline(points, point, i)];
        } else if (step) {
          if (step === 1) {
            pathToPoint = [[
              "L",
              lastPoint.plotX,
              plotY
            ]];
          } else if (step === 2) {
            pathToPoint = [[
              "L",
              (lastPoint.plotX + plotX) / 2,
              lastPoint.plotY
            ], [
              "L",
              (lastPoint.plotX + plotX) / 2,
              plotY
            ]];
          } else {
            pathToPoint = [[
              "L",
              plotX,
              lastPoint.plotY
            ]];
          }
          pathToPoint.push([
            "L",
            plotX,
            plotY
          ]);
        } else {
          pathToPoint = [[
            "L",
            plotX,
            plotY
          ]];
        }
        xMap.push(point.x);
        if (step) {
          xMap.push(point.x);
          if (step === 2) {
            xMap.push(point.x);
          }
        }
        graphPath.push.apply(graphPath, pathToPoint);
        gap = false;
      }
    });
    graphPath.xMap = xMap;
    series.graphPath = graphPath;
    return graphPath;
  }
}
LineSeries.defaultOptions = merge20(Series_default.defaultOptions, {
  legendSymbol: "lineMarker"
});
SeriesRegistry_default.registerSeriesType("line", LineSeries);

// node_modules/highcharts/es-modules/Series/Area/AreaSeriesDefaults.js
var AreaSeriesDefaults = {
  threshold: 0,
  legendSymbol: "areaMarker"
};
var AreaSeriesDefaults_default = AreaSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Area/AreaSeries.js
var { seriesTypes: { line: LineSeries2 } } = SeriesRegistry_default;
var { extend: extend19, merge: merge21, objectEach: objectEach16, pick: pick24 } = Utilities_default;

class AreaSeries extends LineSeries2 {
  drawGraph() {
    this.areaPath = [];
    super.drawGraph.apply(this);
    const { areaPath, options } = this;
    [this, ...this.zones].forEach((owner, i) => {
      const attribs = {}, fillColor = owner.fillColor || options.fillColor;
      let area = owner.area;
      const verb = area ? "animate" : "attr";
      if (area) {
        area.endX = this.preventGraphAnimation ? null : areaPath.xMap;
        area.animate({ d: areaPath });
      } else {
        attribs.zIndex = 0;
        area = owner.area = this.chart.renderer.path(areaPath).addClass("highcharts-area" + (i ? ` highcharts-zone-area-${i - 1} ` : " ") + (i && owner.className || "")).add(this.group);
        area.isArea = true;
      }
      if (!this.chart.styledMode) {
        attribs.fill = fillColor || owner.color || this.color;
        attribs["fill-opacity"] = fillColor ? 1 : options.fillOpacity ?? 0.75;
        area.css({
          pointerEvents: this.stickyTracking ? "none" : "auto"
        });
      }
      area[verb](attribs);
      area.startX = areaPath.xMap;
      area.shiftUnit = options.step ? 2 : 1;
    });
  }
  getGraphPath(points) {
    const getGraphPath = LineSeries2.prototype.getGraphPath, options = this.options, stacking = options.stacking, yAxis2 = this.yAxis, bottomPoints = [], graphPoints = [], seriesIndex = this.index, stacks = yAxis2.stacking.stacks[this.stackKey], threshold = options.threshold, translatedThreshold = Math.round(yAxis2.getThreshold(options.threshold)), connectNulls = pick24(options.connectNulls, stacking === "percent"), addDummyPoints = function(i, otherI, side) {
      const point = points[i], stackedValues = stacking && stacks[point.x].points[seriesIndex], nullVal = point[side + "Null"] || 0, cliffVal = point[side + "Cliff"] || 0;
      let top, bottom, isNull2 = true;
      if (cliffVal || nullVal) {
        top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
        bottom = stackedValues[0] + cliffVal;
        isNull2 = !!nullVal;
      } else if (!stacking && points[otherI] && points[otherI].isNull) {
        top = bottom = threshold;
      }
      if (typeof top !== "undefined") {
        graphPoints.push({
          plotX,
          plotY: top === null ? translatedThreshold : yAxis2.getThreshold(top),
          isNull: isNull2,
          isCliff: true
        });
        bottomPoints.push({
          plotX,
          plotY: bottom === null ? translatedThreshold : yAxis2.getThreshold(bottom),
          doCurve: false
        });
      }
    };
    let plotX, isNull, yBottom;
    points = points || this.points;
    if (stacking) {
      points = this.getStackPoints(points);
    }
    for (let i = 0, iEnd = points.length;i < iEnd; ++i) {
      if (!stacking) {
        points[i].leftCliff = points[i].rightCliff = points[i].leftNull = points[i].rightNull = undefined;
      }
      isNull = points[i].isNull;
      plotX = pick24(points[i].rectPlotX, points[i].plotX);
      yBottom = stacking ? pick24(points[i].yBottom, translatedThreshold) : translatedThreshold;
      if (!isNull || connectNulls) {
        if (!connectNulls) {
          addDummyPoints(i, i - 1, "left");
        }
        if (!(isNull && !stacking && connectNulls)) {
          graphPoints.push(points[i]);
          bottomPoints.push({
            x: i,
            plotX,
            plotY: yBottom
          });
        }
        if (!connectNulls) {
          addDummyPoints(i, i + 1, "right");
        }
      }
    }
    const topPath = getGraphPath.call(this, graphPoints, true, true);
    bottomPoints.reversed = true;
    const bottomPath = getGraphPath.call(this, bottomPoints, true, true);
    const firstBottomPoint = bottomPath[0];
    if (firstBottomPoint && firstBottomPoint[0] === "M") {
      bottomPath[0] = ["L", firstBottomPoint[1], firstBottomPoint[2]];
    }
    const areaPath = topPath.concat(bottomPath);
    if (areaPath.length) {
      areaPath.push(["Z"]);
    }
    const graphPath = getGraphPath.call(this, graphPoints, false, connectNulls);
    if (this.chart.series.length > 1 && stacking && graphPoints.some((point) => point.isCliff)) {
      areaPath.hasStackedCliffs = graphPath.hasStackedCliffs = true;
    }
    areaPath.xMap = topPath.xMap;
    this.areaPath = areaPath;
    return graphPath;
  }
  getStackPoints(points) {
    const series = this, segment = [], keys2 = [], xAxis2 = this.xAxis, yAxis2 = this.yAxis, stack = yAxis2.stacking.stacks[this.stackKey], pointMap = {}, yAxisSeries = yAxis2.series, seriesLength = yAxisSeries.length, upOrDown = yAxis2.options.reversedStacks ? 1 : -1, seriesIndex = yAxisSeries.indexOf(series);
    points = points || this.points;
    if (this.options.stacking) {
      for (let i = 0;i < points.length; i++) {
        points[i].leftNull = points[i].rightNull = undefined;
        pointMap[points[i].x] = points[i];
      }
      objectEach16(stack, function(stackX, x) {
        if (stackX.total !== null) {
          keys2.push(x);
        }
      });
      keys2.sort(function(a, b) {
        return a - b;
      });
      const visibleSeries = yAxisSeries.map((s) => s.visible);
      keys2.forEach(function(x, idx) {
        let y = 0, stackPoint, stackedValues;
        if (pointMap[x] && !pointMap[x].isNull) {
          segment.push(pointMap[x]);
          [-1, 1].forEach(function(direction) {
            const nullName = direction === 1 ? "rightNull" : "leftNull", cliffName = direction === 1 ? "rightCliff" : "leftCliff", otherStack = stack[keys2[idx + direction]];
            let cliff = 0;
            if (otherStack) {
              let i = seriesIndex;
              while (i >= 0 && i < seriesLength) {
                const si = yAxisSeries[i].index;
                stackPoint = otherStack.points[si];
                if (!stackPoint) {
                  if (si === series.index) {
                    pointMap[x][nullName] = true;
                  } else if (visibleSeries[i]) {
                    stackedValues = stack[x].points[si];
                    if (stackedValues) {
                      cliff -= stackedValues[1] - stackedValues[0];
                    }
                  }
                }
                i += upOrDown;
              }
            }
            pointMap[x][cliffName] = cliff;
          });
        } else {
          let i = seriesIndex;
          while (i >= 0 && i < seriesLength) {
            const si = yAxisSeries[i].index;
            stackPoint = stack[x].points[si];
            if (stackPoint) {
              y = stackPoint[1];
              break;
            }
            i += upOrDown;
          }
          y = pick24(y, 0);
          y = yAxis2.translate(y, 0, 1, 0, 1);
          segment.push({
            isNull: true,
            plotX: xAxis2.translate(x, 0, 0, 0, 1),
            x,
            plotY: y,
            yBottom: y
          });
        }
      });
    }
    return segment;
  }
}
AreaSeries.defaultOptions = merge21(LineSeries2.defaultOptions, AreaSeriesDefaults_default);
extend19(AreaSeries.prototype, {
  singleStacks: false
});
SeriesRegistry_default.registerSeriesType("area", AreaSeries);

// node_modules/highcharts/es-modules/Series/Spline/SplineSeries.js
var { line: LineSeries3 } = SeriesRegistry_default.seriesTypes;
var { merge: merge22, pick: pick25 } = Utilities_default;

class SplineSeries extends LineSeries3 {
  getPointSpline(points, point, i) {
    const smoothing = 1.5, denom = smoothing + 1, plotX = point.plotX || 0, plotY = point.plotY || 0, lastPoint = points[i - 1], nextPoint = points[i + 1];
    let leftContX, leftContY, rightContX, rightContY;
    function doCurve(otherPoint) {
      return otherPoint && !otherPoint.isNull && otherPoint.doCurve !== false && !point.isCliff;
    }
    if (doCurve(lastPoint) && doCurve(nextPoint)) {
      const lastX = lastPoint.plotX || 0, lastY = lastPoint.plotY || 0, nextX = nextPoint.plotX || 0, nextY = nextPoint.plotY || 0;
      let correction = 0;
      leftContX = (smoothing * plotX + lastX) / denom;
      leftContY = (smoothing * plotY + lastY) / denom;
      rightContX = (smoothing * plotX + nextX) / denom;
      rightContY = (smoothing * plotY + nextY) / denom;
      if (rightContX !== leftContX) {
        correction = (rightContY - leftContY) * (rightContX - plotX) / (rightContX - leftContX) + plotY - rightContY;
      }
      leftContY += correction;
      rightContY += correction;
      if (leftContY > lastY && leftContY > plotY) {
        leftContY = Math.max(lastY, plotY);
        rightContY = 2 * plotY - leftContY;
      } else if (leftContY < lastY && leftContY < plotY) {
        leftContY = Math.min(lastY, plotY);
        rightContY = 2 * plotY - leftContY;
      }
      if (rightContY > nextY && rightContY > plotY) {
        rightContY = Math.max(nextY, plotY);
        leftContY = 2 * plotY - rightContY;
      } else if (rightContY < nextY && rightContY < plotY) {
        rightContY = Math.min(nextY, plotY);
        leftContY = 2 * plotY - rightContY;
      }
      point.rightContX = rightContX;
      point.rightContY = rightContY;
      point.controlPoints = {
        low: [leftContX, leftContY],
        high: [rightContX, rightContY]
      };
    }
    const ret = [
      "C",
      pick25(lastPoint.rightContX, lastPoint.plotX, 0),
      pick25(lastPoint.rightContY, lastPoint.plotY, 0),
      pick25(leftContX, plotX, 0),
      pick25(leftContY, plotY, 0),
      plotX,
      plotY
    ];
    lastPoint.rightContX = lastPoint.rightContY = undefined;
    return ret;
  }
}
SplineSeries.defaultOptions = merge22(LineSeries3.defaultOptions);
SeriesRegistry_default.registerSeriesType("spline", SplineSeries);
var SplineSeries_default = SplineSeries;

// node_modules/highcharts/es-modules/Series/AreaSpline/AreaSplineSeries.js
var { area: AreaSeries2, area: { prototype: areaProto } } = SeriesRegistry_default.seriesTypes;
var { extend: extend20, merge: merge23 } = Utilities_default;

class AreaSplineSeries extends SplineSeries_default {
}
AreaSplineSeries.defaultOptions = merge23(SplineSeries_default.defaultOptions, AreaSeries2.defaultOptions);
extend20(AreaSplineSeries.prototype, {
  getGraphPath: areaProto.getGraphPath,
  getStackPoints: areaProto.getStackPoints,
  drawGraph: areaProto.drawGraph
});
SeriesRegistry_default.registerSeriesType("areaspline", AreaSplineSeries);

// node_modules/highcharts/es-modules/Series/Column/ColumnSeriesDefaults.js
var ColumnSeriesDefaults = {
  borderRadius: 3,
  centerInCategory: false,
  groupPadding: 0.2,
  marker: null,
  pointPadding: 0.1,
  minPointLength: 0,
  cropThreshold: 50,
  pointRange: null,
  states: {
    hover: {
      halo: false,
      brightness: 0.1
    },
    select: {
      color: "#cccccc",
      borderColor: "#000000"
    }
  },
  dataLabels: {
    align: undefined,
    verticalAlign: undefined,
    y: undefined
  },
  startFromThreshold: true,
  stickyTracking: false,
  tooltip: {
    distance: 6
  },
  threshold: 0,
  borderColor: "#ffffff"
};
var ColumnSeriesDefaults_default = ColumnSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Column/ColumnSeries.js
var { animObject: animObject9 } = AnimationUtilities_default;
var { parse: color3 } = Color_default;
var { noop: noop2 } = Globals_default;
var { clamp: clamp7, crisp: crisp6, defined: defined18, extend: extend21, fireEvent: fireEvent16, isArray: isArray12, isNumber: isNumber21, merge: merge24, pick: pick26, objectEach: objectEach17 } = Utilities_default;

class ColumnSeries extends Series_default {
  animate(init) {
    const series = this, yAxis2 = this.yAxis, yAxisPos = yAxis2.pos, reversed = yAxis2.reversed, options = series.options, { clipOffset, inverted } = this.chart, attr9 = {}, translateProp = inverted ? "translateX" : "translateY";
    let translateStart, translatedThreshold;
    if (init && clipOffset) {
      attr9.scaleY = 0.001;
      translatedThreshold = clamp7(yAxis2.toPixels(options.threshold), yAxisPos, yAxisPos + yAxis2.len);
      if (inverted) {
        translatedThreshold += reversed ? -Math.floor(clipOffset[0]) : Math.ceil(clipOffset[2]);
        attr9.translateX = translatedThreshold - yAxis2.len;
      } else {
        translatedThreshold += reversed ? Math.ceil(clipOffset[0]) : -Math.floor(clipOffset[2]);
        attr9.translateY = translatedThreshold;
      }
      if (series.clipBox) {
        series.setClip();
      }
      series.group.attr(attr9);
    } else {
      translateStart = Number(series.group.attr(translateProp));
      series.group.animate({ scaleY: 1 }, extend21(animObject9(series.options.animation), {
        step: function(val, fx) {
          if (series.group) {
            attr9[translateProp] = translateStart + fx.pos * (yAxisPos - translateStart);
            series.group.attr(attr9);
          }
        }
      }));
    }
  }
  init(chart, options) {
    super.init.apply(this, arguments);
    const series = this;
    chart = series.chart;
    if (chart.hasRendered) {
      chart.series.forEach(function(otherSeries) {
        if (otherSeries.type === series.type) {
          otherSeries.isDirty = true;
        }
      });
    }
  }
  getColumnMetrics() {
    const series = this, options = series.options, xAxis2 = series.xAxis, yAxis2 = series.yAxis, reversedStacks = xAxis2.options.reversedStacks, reverseStacks = xAxis2.reversed && !reversedStacks || !xAxis2.reversed && reversedStacks, stackGroups = {};
    let stackKey, columnCount = 0;
    if (options.grouping === false) {
      columnCount = 1;
    } else {
      series.chart.series.forEach(function(otherSeries) {
        const { yAxis: otherYAxis, options: otherOptions } = otherSeries;
        let columnIndex;
        if (otherSeries.type === series.type && otherSeries.reserveSpace() && yAxis2.len === otherYAxis.len && yAxis2.pos === otherYAxis.pos) {
          if (otherOptions.stacking && otherOptions.stacking !== "group") {
            stackKey = otherSeries.stackKey;
            if (typeof stackGroups[stackKey] === "undefined") {
              stackGroups[stackKey] = columnCount++;
            }
            columnIndex = stackGroups[stackKey];
          } else if (otherOptions.grouping !== false) {
            columnIndex = columnCount++;
          }
          otherSeries.columnIndex = columnIndex;
        }
      });
    }
    const categoryWidth = Math.min(Math.abs(xAxis2.transA) * (!xAxis2.brokenAxis?.hasBreaks && xAxis2.ordinal?.slope || options.pointRange || xAxis2.closestPointRange || xAxis2.tickInterval || 1), xAxis2.len), groupPadding = categoryWidth * options.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / (columnCount || 1), pointWidth = Math.min(options.maxPointWidth || xAxis2.len, pick26(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))), pointPadding = (pointOffsetWidth - pointWidth) / 2, colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0), pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - categoryWidth / 2) * (reverseStacks ? -1 : 1);
    series.columnMetrics = {
      width: pointWidth,
      offset: pointXOffset,
      paddedWidth: pointOffsetWidth,
      columnCount
    };
    return series.columnMetrics;
  }
  crispCol(x, y, width, height) {
    const borderWidth = this.borderWidth, inverted = this.chart.inverted, bottom = crisp6(y + height, borderWidth, inverted);
    y = crisp6(y, borderWidth, inverted);
    height = bottom - y;
    if (this.options.crisp) {
      const right = crisp6(x + width, borderWidth);
      x = crisp6(x, borderWidth);
      width = right - x;
    }
    return { x, y, width, height };
  }
  adjustForMissingColumns(x, pointWidth, point, metrics) {
    if (!point.isNull && metrics.columnCount > 1) {
      const visibleSeries = this.xAxis.series.filter((s) => s.visible).map((s) => s.index);
      let indexInCategory = 0, totalInCategory = 0;
      objectEach17(this.xAxis.stacking?.stacks, (stack) => {
        if (typeof point.x === "number") {
          const stackItem = stack[point.x.toString()];
          if (stackItem) {
            const pointValues = stackItem.points[this.index];
            if (isArray12(pointValues)) {
              const seriesIndexes = Object.keys(stackItem.points).filter((pointKey) => !pointKey.match(",") && stackItem.points[pointKey] && stackItem.points[pointKey].length > 1).map(parseFloat).filter((index) => visibleSeries.indexOf(index) !== -1).sort((a, b) => b - a);
              indexInCategory = seriesIndexes.indexOf(this.index);
              totalInCategory = seriesIndexes.length;
            }
          }
        }
      });
      indexInCategory = this.xAxis.reversed ? totalInCategory - 1 - indexInCategory : indexInCategory;
      const boxWidth = (totalInCategory - 1) * metrics.paddedWidth + pointWidth;
      x = (point.plotX || 0) + boxWidth / 2 - pointWidth - indexInCategory * metrics.paddedWidth;
    }
    return x;
  }
  translate() {
    const series = this, chart = series.chart, options = series.options, dense = series.dense = series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick26(options.borderWidth, dense ? 0 : 1), xAxis2 = series.xAxis, yAxis2 = series.yAxis, threshold = options.threshold, minPointLength = pick26(options.minPointLength, 5), metrics = series.getColumnMetrics(), seriesPointWidth = metrics.width, seriesXOffset = series.pointXOffset = metrics.offset, dataMin = series.dataMin, dataMax = series.dataMax, translatedThreshold = series.translatedThreshold = yAxis2.getThreshold(threshold);
    let seriesBarW = series.barW = Math.max(seriesPointWidth, 1 + 2 * borderWidth);
    if (options.pointPadding) {
      seriesBarW = Math.ceil(seriesBarW);
    }
    Series_default.prototype.translate.apply(series);
    series.points.forEach(function(point) {
      const yBottom = pick26(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotX = point.plotX || 0, plotY = clamp7(point.plotY, -safeDistance, yAxis2.len + safeDistance);
      let up, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, pointWidth = seriesPointWidth, barX = plotX + seriesXOffset, barW = seriesBarW;
      if (minPointLength && Math.abs(barH) < minPointLength) {
        barH = minPointLength;
        up = !yAxis2.reversed && !point.negative || yAxis2.reversed && point.negative;
        if (isNumber21(threshold) && isNumber21(dataMax) && point.y === threshold && dataMax <= threshold && (yAxis2.min || 0) < threshold && (dataMin !== dataMax || (yAxis2.max || 0) <= threshold)) {
          up = !up;
          point.negative = !point.negative;
        }
        barY = Math.abs(barY - translatedThreshold) > minPointLength ? yBottom - minPointLength : translatedThreshold - (up ? minPointLength : 0);
      }
      if (defined18(point.options.pointWidth)) {
        pointWidth = barW = Math.ceil(point.options.pointWidth);
        barX -= Math.round((pointWidth - seriesPointWidth) / 2);
      }
      if (options.centerInCategory && !options.stacking) {
        barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);
      }
      point.barX = barX;
      point.pointWidth = pointWidth;
      point.tooltipPos = chart.inverted ? [
        clamp7(yAxis2.len + yAxis2.pos - chart.plotLeft - plotY, yAxis2.pos - chart.plotLeft, yAxis2.len + yAxis2.pos - chart.plotLeft),
        xAxis2.len + xAxis2.pos - chart.plotTop - barX - barW / 2,
        barH
      ] : [
        xAxis2.left - chart.plotLeft + barX + barW / 2,
        clamp7(plotY + yAxis2.pos - chart.plotTop, yAxis2.pos - chart.plotTop, yAxis2.len + yAxis2.pos - chart.plotTop),
        barH
      ];
      point.shapeType = series.pointClass.prototype.shapeType || "roundedRect";
      point.shapeArgs = series.crispCol(barX, point.isNull ? translatedThreshold : barY, barW, point.isNull ? 0 : barH);
    });
    fireEvent16(this, "afterColumnTranslate");
  }
  drawGraph() {
    this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
  }
  pointAttribs(point, state) {
    const options = this.options, p2o = this.pointAttrToOptions || {}, strokeOption = p2o.stroke || "borderColor", strokeWidthOption = p2o["stroke-width"] || "borderWidth";
    let stateOptions, zone, brightness, fill = point && point.color || this.color, stroke = point && point[strokeOption] || options[strokeOption] || fill, dashstyle = point && point.options.dashStyle || options.dashStyle, strokeWidth = point && point[strokeWidthOption] || options[strokeWidthOption] || this[strokeWidthOption] || 0, opacity = pick26(point && point.opacity, options.opacity, 1);
    if (point && this.zones.length) {
      zone = point.getZone();
      fill = point.options.color || zone && (zone.color || point.nonZonedColor) || this.color;
      if (zone) {
        stroke = zone.borderColor || stroke;
        dashstyle = zone.dashStyle || dashstyle;
        strokeWidth = zone.borderWidth || strokeWidth;
      }
    }
    if (state && point) {
      stateOptions = merge24(options.states[state], point.options.states && point.options.states[state] || {});
      brightness = stateOptions.brightness;
      fill = stateOptions.color || typeof brightness !== "undefined" && color3(fill).brighten(stateOptions.brightness).get() || fill;
      stroke = stateOptions[strokeOption] || stroke;
      strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
      dashstyle = stateOptions.dashStyle || dashstyle;
      opacity = pick26(stateOptions.opacity, opacity);
    }
    const ret = {
      fill,
      stroke,
      "stroke-width": strokeWidth,
      opacity
    };
    if (dashstyle) {
      ret.dashstyle = dashstyle;
    }
    return ret;
  }
  drawPoints(points = this.points) {
    const series = this, chart = this.chart, options = series.options, renderer = chart.renderer, animationLimit = options.animationLimit || 250;
    let shapeArgs;
    points.forEach(function(point) {
      const plotY = point.plotY;
      let graphic = point.graphic, hasGraphic = !!graphic, verb = graphic && chart.pointCount < animationLimit ? "animate" : "attr";
      if (isNumber21(plotY) && point.y !== null) {
        shapeArgs = point.shapeArgs;
        if (graphic && point.hasNewShapeType()) {
          graphic = graphic.destroy();
        }
        if (series.enabledDataSorting) {
          point.startXPos = series.xAxis.reversed ? -(shapeArgs ? shapeArgs.width || 0 : 0) : series.xAxis.width;
        }
        if (!graphic) {
          point.graphic = graphic = renderer[point.shapeType](shapeArgs).add(point.group || series.group);
          if (graphic && series.enabledDataSorting && chart.hasRendered && chart.pointCount < animationLimit) {
            graphic.attr({
              x: point.startXPos
            });
            hasGraphic = true;
            verb = "animate";
          }
        }
        if (graphic && hasGraphic) {
          graphic[verb](merge24(shapeArgs));
        }
        if (!chart.styledMode) {
          graphic[verb](series.pointAttribs(point, point.selected && "select")).shadow(point.allowShadow !== false && options.shadow);
        }
        if (graphic) {
          graphic.addClass(point.getClassName(), true);
          graphic.attr({
            visibility: point.visible ? "inherit" : "hidden"
          });
        }
      } else if (graphic) {
        point.graphic = graphic.destroy();
      }
    });
  }
  drawTracker(points = this.points) {
    const series = this, chart = series.chart, pointer = chart.pointer, onMouseOver = function(e) {
      const point = pointer?.getPointFromEvent(e);
      if (pointer && point && series.options.enableMouseTracking) {
        pointer.isDirectTouch = true;
        point.onMouseOver(e);
      }
    };
    let dataLabels;
    points.forEach(function(point) {
      dataLabels = isArray12(point.dataLabels) ? point.dataLabels : point.dataLabel ? [point.dataLabel] : [];
      if (point.graphic) {
        point.graphic.element.point = point;
      }
      dataLabels.forEach(function(dataLabel) {
        (dataLabel.div || dataLabel.element).point = point;
      });
    });
    if (!series._hasTracking) {
      series.trackerGroups.forEach(function(key) {
        if (series[key]) {
          series[key].addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", function(e) {
            pointer?.onTrackerMouseOut(e);
          }).on("touchstart", onMouseOver);
          if (!chart.styledMode && series.options.cursor) {
            series[key].css({ cursor: series.options.cursor });
          }
        }
      });
      series._hasTracking = true;
    }
    fireEvent16(this, "afterDrawTracker");
  }
  remove() {
    const series = this, chart = series.chart;
    if (chart.hasRendered) {
      chart.series.forEach(function(otherSeries) {
        if (otherSeries.type === series.type) {
          otherSeries.isDirty = true;
        }
      });
    }
    Series_default.prototype.remove.apply(series, arguments);
  }
}
ColumnSeries.defaultOptions = merge24(Series_default.defaultOptions, ColumnSeriesDefaults_default);
extend21(ColumnSeries.prototype, {
  directTouch: true,
  getSymbol: noop2,
  negStacks: true,
  trackerGroups: ["group", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("column", ColumnSeries);
var ColumnSeries_default = ColumnSeries;

// node_modules/highcharts/es-modules/Core/Series/DataLabel.js
var { getDeferredAnimation: getDeferredAnimation3 } = AnimationUtilities_default;
var { format: format6 } = Templating_default;
var { defined: defined19, extend: extend22, fireEvent: fireEvent17, isArray: isArray13, isString: isString10, merge: merge25, objectEach: objectEach18, pick: pick27, pInt: pInt8, splat: splat9 } = Utilities_default;
var DataLabel;
(function(DataLabel2) {
  function hasDataLabels() {
    return mergedDataLabelOptions(this).some((o) => o?.enabled);
  }
  function alignDataLabel(point, dataLabel, options, alignTo, isNew) {
    const series = this, { chart, enabledDataSorting } = this, inverted = this.isCartesian && chart.inverted, plotX = point.plotX, plotY = point.plotY, rotation = options.rotation || 0, isInsidePlot = defined19(plotX) && defined19(plotY) && chart.isInsidePlot(plotX, Math.round(plotY), {
      inverted,
      paneCoordinates: true,
      series
    }), setStartPos = (alignOptions) => {
      if (enabledDataSorting && series.xAxis && !justify) {
        series.setDataLabelStartPos(point, dataLabel, isNew, isInsidePlot, alignOptions);
      }
    }, justify = rotation === 0 ? pick27(options.overflow, enabledDataSorting ? "none" : "justify") === "justify" : false;
    let visible = this.visible && point.visible !== false && defined19(plotX) && (point.series.forceDL || enabledDataSorting && !justify || isInsidePlot || pick27(options.inside, !!this.options.stacking) && alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, {
      inverted,
      paneCoordinates: true,
      series
    }));
    const pos = point.pos();
    if (visible && pos) {
      const bBox = dataLabel.getBBox(), unrotatedbBox = dataLabel.getBBox(undefined, 0), alignFactor = {
        right: 1,
        center: 0.5
      }[options.align || 0] || 0, verticalAlignFactor = {
        bottom: 1,
        middle: 0.5
      }[options.verticalAlign || 0] || 0;
      alignTo = extend22({
        x: pos[0],
        y: Math.round(pos[1]),
        width: 0,
        height: 0
      }, alignTo || {});
      if (options.alignTo === "plotEdges" && series.isCartesian) {
        alignTo[inverted ? "x" : "y"] = 0;
        alignTo[inverted ? "width" : "height"] = this.yAxis?.len || 0;
      }
      extend22(options, {
        width: bBox.width,
        height: bBox.height
      });
      setStartPos(alignTo);
      dataLabel.align(merge25(options, {
        width: unrotatedbBox.width,
        height: unrotatedbBox.height
      }), false, alignTo, false);
      dataLabel.alignAttr.x += alignFactor * (unrotatedbBox.width - bBox.width);
      dataLabel.alignAttr.y += verticalAlignFactor * (unrotatedbBox.height - bBox.height);
      dataLabel[dataLabel.placed ? "animate" : "attr"]({
        x: dataLabel.alignAttr.x + (bBox.width - unrotatedbBox.width) / 2,
        y: dataLabel.alignAttr.y + (bBox.height - unrotatedbBox.height) / 2,
        rotationOriginX: (dataLabel.width || 0) / 2,
        rotationOriginY: (dataLabel.height || 0) / 2
      });
      if (justify && alignTo.height >= 0) {
        this.justifyDataLabel(dataLabel, options, dataLabel.alignAttr, bBox, alignTo, isNew);
      } else if (pick27(options.crop, true)) {
        const { x, y } = dataLabel.alignAttr, correction = 1;
        visible = chart.isInsidePlot(x, y, {
          paneCoordinates: true,
          series
        }) && chart.isInsidePlot(x + bBox.width - correction, y + bBox.height - correction, {
          paneCoordinates: true,
          series
        });
      }
      if (options.shape && !rotation) {
        dataLabel[isNew ? "attr" : "animate"]({
          anchorX: pos[0],
          anchorY: pos[1]
        });
      }
    }
    if (isNew && enabledDataSorting) {
      dataLabel.placed = false;
    }
    if (!visible && (!enabledDataSorting || justify)) {
      dataLabel.hide();
      dataLabel.placed = false;
    } else {
      dataLabel.show();
      dataLabel.placed = true;
    }
  }
  function applyFilter(point, options) {
    const filter = options.filter;
    if (filter) {
      const op = filter.operator, prop = point[filter.property], val = filter.value;
      if (op === ">" && prop > val || op === "<" && prop < val || op === ">=" && prop >= val || op === "<=" && prop <= val || op === "==" && prop == val || op === "===" && prop === val || op === "!=" && prop != val || op === "!==" && prop !== val) {
        return true;
      }
      return false;
    }
    return true;
  }
  function compose(SeriesClass) {
    const seriesProto2 = SeriesClass.prototype;
    if (!seriesProto2.initDataLabels) {
      seriesProto2.initDataLabels = initDataLabels;
      seriesProto2.initDataLabelsGroup = initDataLabelsGroup;
      seriesProto2.alignDataLabel = alignDataLabel;
      seriesProto2.drawDataLabels = drawDataLabels;
      seriesProto2.justifyDataLabel = justifyDataLabel;
      seriesProto2.setDataLabelStartPos = setDataLabelStartPos;
      seriesProto2.hasDataLabels = hasDataLabels;
    }
  }
  DataLabel2.compose = compose;
  function initDataLabelsGroup() {
    return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
  }
  function initDataLabels(animationConfig) {
    const series = this, hasRendered = series.hasRendered || 0;
    const dataLabelsGroup = this.initDataLabelsGroup().attr({ opacity: +hasRendered });
    if (!hasRendered && dataLabelsGroup) {
      if (series.visible) {
        dataLabelsGroup.show();
      }
      if (series.options.animation) {
        dataLabelsGroup.animate({ opacity: 1 }, animationConfig);
      } else {
        dataLabelsGroup.attr({ opacity: 1 });
      }
    }
    return dataLabelsGroup;
  }
  function drawDataLabels(points) {
    points = points || this.points;
    const series = this, chart = series.chart, seriesOptions = series.options, renderer = chart.renderer, { backgroundColor, plotBackgroundColor } = chart.options.chart, contrastColor = renderer.getContrast(isString10(plotBackgroundColor) && plotBackgroundColor || isString10(backgroundColor) && backgroundColor || "#000000"), seriesDlOptions = mergedDataLabelOptions(series);
    let pointOptions, dataLabelsGroup;
    const { animation, defer } = seriesDlOptions[0], animationConfig = defer ? getDeferredAnimation3(chart, animation, series) : { defer: 0, duration: 0 };
    fireEvent17(this, "drawDataLabels");
    if (series.hasDataLabels?.()) {
      dataLabelsGroup = this.initDataLabels(animationConfig);
      points.forEach((point) => {
        const dataLabels = point.dataLabels || [];
        pointOptions = splat9(mergeArrays(seriesDlOptions, point.dlOptions || point.options?.dataLabels));
        pointOptions.forEach((labelOptions, i) => {
          const labelEnabled = labelOptions.enabled && (point.visible || point.dataLabelOnHidden) && (!point.isNull || point.dataLabelOnNull) && applyFilter(point, labelOptions), { backgroundColor: backgroundColor2, borderColor, distance, style = {} } = labelOptions;
          let labelConfig, formatString, labelText, rotation, attr9 = {}, dataLabel = dataLabels[i], isNew = !dataLabel, labelBgColor;
          if (labelEnabled) {
            formatString = pick27(labelOptions[point.formatPrefix + "Format"], labelOptions.format);
            labelConfig = point.getLabelConfig();
            labelText = defined19(formatString) ? format6(formatString, labelConfig, chart) : (labelOptions[point.formatPrefix + "Formatter"] || labelOptions.formatter).call(labelConfig, labelOptions);
            rotation = labelOptions.rotation;
            if (!chart.styledMode) {
              style.color = pick27(labelOptions.color, style.color, isString10(series.color) ? series.color : undefined, "#000000");
              if (style.color === "contrast") {
                if (backgroundColor2 !== "none") {
                  labelBgColor = backgroundColor2;
                }
                point.contrastColor = renderer.getContrast(labelBgColor !== "auto" && labelBgColor || (point.color || series.color));
                style.color = labelBgColor || !defined19(distance) && labelOptions.inside || pInt8(distance || 0) < 0 || seriesOptions.stacking ? point.contrastColor : contrastColor;
              } else {
                delete point.contrastColor;
              }
              if (seriesOptions.cursor) {
                style.cursor = seriesOptions.cursor;
              }
            }
            attr9 = {
              r: labelOptions.borderRadius || 0,
              rotation,
              padding: labelOptions.padding,
              zIndex: 1
            };
            if (!chart.styledMode) {
              attr9.fill = backgroundColor2 === "auto" ? point.color : backgroundColor2;
              attr9.stroke = borderColor === "auto" ? point.color : borderColor;
              attr9["stroke-width"] = labelOptions.borderWidth;
            }
            objectEach18(attr9, (val, name) => {
              if (typeof val === "undefined") {
                delete attr9[name];
              }
            });
          }
          if (dataLabel && (!labelEnabled || !defined19(labelText) || !!dataLabel.div !== !!labelOptions.useHTML || (!dataLabel.rotation || !labelOptions.rotation) && dataLabel.rotation !== labelOptions.rotation)) {
            dataLabel = undefined;
            isNew = true;
          }
          if (labelEnabled && defined19(labelText)) {
            if (!dataLabel) {
              dataLabel = renderer.label(labelText, 0, 0, labelOptions.shape, undefined, undefined, labelOptions.useHTML, undefined, "data-label");
              dataLabel.addClass(" highcharts-data-label-color-" + point.colorIndex + " " + (labelOptions.className || "") + (labelOptions.useHTML ? " highcharts-tracker" : ""));
            } else {
              attr9.text = labelText;
            }
            if (dataLabel) {
              dataLabel.options = labelOptions;
              dataLabel.attr(attr9);
              if (!chart.styledMode) {
                dataLabel.css(style).shadow(labelOptions.shadow);
              }
              fireEvent17(dataLabel, "beforeAddingDataLabel", { labelOptions, point });
              if (!dataLabel.added) {
                dataLabel.add(dataLabelsGroup);
              }
              series.alignDataLabel(point, dataLabel, labelOptions, undefined, isNew);
              dataLabel.isActive = true;
              if (dataLabels[i] && dataLabels[i] !== dataLabel) {
                dataLabels[i].destroy();
              }
              dataLabels[i] = dataLabel;
            }
          }
        });
        let j = dataLabels.length;
        while (j--) {
          if (!dataLabels[j] || !dataLabels[j].isActive) {
            dataLabels[j]?.destroy();
            dataLabels.splice(j, 1);
          } else {
            dataLabels[j].isActive = false;
          }
        }
        point.dataLabel = dataLabels[0];
        point.dataLabels = dataLabels;
      });
    }
    fireEvent17(this, "afterDrawDataLabels");
  }
  function justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew) {
    const chart = this.chart, align = options.align, verticalAlign = options.verticalAlign, padding = dataLabel.box ? 0 : dataLabel.padding || 0, horizontalAxis = chart.inverted ? this.yAxis : this.xAxis, horizontalAxisShift = horizontalAxis ? horizontalAxis.left - chart.plotLeft : 0, verticalAxis = chart.inverted ? this.xAxis : this.yAxis, verticalAxisShift = verticalAxis ? verticalAxis.top - chart.plotTop : 0;
    let { x = 0, y = 0 } = options, off, justified;
    off = (alignAttr.x || 0) + padding + horizontalAxisShift;
    if (off < 0) {
      if (align === "right" && x >= 0) {
        options.align = "left";
        options.inside = true;
      } else {
        x -= off;
      }
      justified = true;
    }
    off = (alignAttr.x || 0) + bBox.width - padding + horizontalAxisShift;
    if (off > chart.plotWidth) {
      if (align === "left" && x <= 0) {
        options.align = "right";
        options.inside = true;
      } else {
        x += chart.plotWidth - off;
      }
      justified = true;
    }
    off = alignAttr.y + padding + verticalAxisShift;
    if (off < 0) {
      if (verticalAlign === "bottom" && y >= 0) {
        options.verticalAlign = "top";
        options.inside = true;
      } else {
        y -= off;
      }
      justified = true;
    }
    off = (alignAttr.y || 0) + bBox.height - padding + verticalAxisShift;
    if (off > chart.plotHeight) {
      if (verticalAlign === "top" && y <= 0) {
        options.verticalAlign = "bottom";
        options.inside = true;
      } else {
        y += chart.plotHeight - off;
      }
      justified = true;
    }
    if (justified) {
      options.x = x;
      options.y = y;
      dataLabel.placed = !isNew;
      dataLabel.align(options, undefined, alignTo);
    }
    return justified;
  }
  function mergeArrays(one, two) {
    let res = [], i;
    if (isArray13(one) && !isArray13(two)) {
      res = one.map(function(el) {
        return merge25(el, two);
      });
    } else if (isArray13(two) && !isArray13(one)) {
      res = two.map(function(el) {
        return merge25(one, el);
      });
    } else if (!isArray13(one) && !isArray13(two)) {
      res = merge25(one, two);
    } else if (isArray13(one) && isArray13(two)) {
      i = Math.max(one.length, two.length);
      while (i--) {
        res[i] = merge25(one[i], two[i]);
      }
    }
    return res;
  }
  function mergedDataLabelOptions(series) {
    const plotOptions = series.chart.options.plotOptions;
    return splat9(mergeArrays(mergeArrays(plotOptions?.series?.dataLabels, plotOptions?.[series.type]?.dataLabels), series.options.dataLabels));
  }
  function setDataLabelStartPos(point, dataLabel, isNew, isInside, alignOptions) {
    const chart = this.chart, inverted = chart.inverted, xAxis2 = this.xAxis, reversed = xAxis2.reversed, labelCenter = ((inverted ? dataLabel.height : dataLabel.width) || 0) / 2, pointWidth = point.pointWidth, halfWidth = pointWidth ? pointWidth / 2 : 0;
    dataLabel.startXPos = inverted ? alignOptions.x : reversed ? -labelCenter - halfWidth : xAxis2.width - labelCenter + halfWidth;
    dataLabel.startYPos = inverted ? reversed ? this.yAxis.height - labelCenter + halfWidth : -labelCenter - halfWidth : alignOptions.y;
    if (!isInside) {
      dataLabel.attr({ opacity: 1 }).animate({ opacity: 0 }, undefined, dataLabel.hide);
    } else if (dataLabel.visibility === "hidden") {
      dataLabel.show();
      dataLabel.attr({ opacity: 0 }).animate({ opacity: 1 });
    }
    if (!chart.hasRendered) {
      return;
    }
    if (isNew) {
      dataLabel.attr({ x: dataLabel.startXPos, y: dataLabel.startYPos });
    }
    dataLabel.placed = true;
  }
})(DataLabel || (DataLabel = {}));
var DataLabel_default = DataLabel;

// node_modules/highcharts/es-modules/Series/Column/ColumnDataLabel.js
var { composed: composed6 } = Globals_default;
var { series: Series7 } = SeriesRegistry_default;
var { merge: merge26, pick: pick28, pushUnique: pushUnique9 } = Utilities_default;
var ColumnDataLabel;
(function(ColumnDataLabel2) {
  function alignDataLabel(point, dataLabel, options, alignTo, isNew) {
    const inverted = this.chart.inverted, series = point.series, xLen = (series.xAxis ? series.xAxis.len : this.chart.plotSizeX) || 0, yLen = (series.yAxis ? series.yAxis.len : this.chart.plotSizeY) || 0, dlBox = point.dlBox || point.shapeArgs, below = pick28(point.below, point.plotY > pick28(this.translatedThreshold, yLen)), inside = pick28(options.inside, !!this.options.stacking);
    if (dlBox) {
      alignTo = merge26(dlBox);
      if (!(options.overflow === "allow" && options.crop === false)) {
        if (alignTo.y < 0) {
          alignTo.height += alignTo.y;
          alignTo.y = 0;
        }
        const overshoot = alignTo.y + alignTo.height - yLen;
        if (overshoot > 0 && overshoot < alignTo.height - 1) {
          alignTo.height -= overshoot;
        }
      }
      if (inverted) {
        alignTo = {
          x: yLen - alignTo.y - alignTo.height,
          y: xLen - alignTo.x - alignTo.width,
          width: alignTo.height,
          height: alignTo.width
        };
      }
      if (!inside) {
        if (inverted) {
          alignTo.x += below ? 0 : alignTo.width;
          alignTo.width = 0;
        } else {
          alignTo.y += below ? alignTo.height : 0;
          alignTo.height = 0;
        }
      }
    }
    options.align = pick28(options.align, !inverted || inside ? "center" : below ? "right" : "left");
    options.verticalAlign = pick28(options.verticalAlign, inverted || inside ? "middle" : below ? "top" : "bottom");
    Series7.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
    if (options.inside && point.contrastColor) {
      dataLabel.css({
        color: point.contrastColor
      });
    }
  }
  function compose(ColumnSeriesClass) {
    DataLabel_default.compose(Series7);
    if (pushUnique9(composed6, "ColumnDataLabel")) {
      ColumnSeriesClass.prototype.alignDataLabel = alignDataLabel;
    }
  }
  ColumnDataLabel2.compose = compose;
})(ColumnDataLabel || (ColumnDataLabel = {}));
var ColumnDataLabel_default = ColumnDataLabel;

// node_modules/highcharts/es-modules/Series/Bar/BarSeries.js
var { extend: extend23, merge: merge27 } = Utilities_default;

class BarSeries extends ColumnSeries_default {
}
BarSeries.defaultOptions = merge27(ColumnSeries_default.defaultOptions, {});
extend23(BarSeries.prototype, {
  inverted: true
});
SeriesRegistry_default.registerSeriesType("bar", BarSeries);

// node_modules/highcharts/es-modules/Series/Scatter/ScatterSeriesDefaults.js
var ScatterSeriesDefaults = {
  lineWidth: 0,
  findNearestPointBy: "xy",
  jitter: {
    x: 0,
    y: 0
  },
  marker: {
    enabled: true
  },
  tooltip: {
    headerFormat: '<span style="color:{point.color}">\u25CF</span> ' + '<span style="font-size: 0.8em"> {series.name}</span><br/>',
    pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
  }
};
var ScatterSeriesDefaults_default = ScatterSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Scatter/ScatterSeries.js
var { column: ColumnSeries3, line: LineSeries4 } = SeriesRegistry_default.seriesTypes;
var { addEvent: addEvent14, extend: extend24, merge: merge28 } = Utilities_default;

class ScatterSeries extends LineSeries4 {
  applyJitter() {
    const series = this, jitter = this.options.jitter, len = this.points.length;
    function unrandom(seed) {
      const rand = Math.sin(seed) * 1e4;
      return rand - Math.floor(rand);
    }
    if (jitter) {
      this.points.forEach(function(point, i) {
        ["x", "y"].forEach(function(dim, j) {
          if (jitter[dim] && !point.isNull) {
            const plotProp = `plot${dim.toUpperCase()}`, axis = series[`${dim}Axis`], translatedJitter = jitter[dim] * axis.transA;
            if (axis && !axis.logarithmic) {
              const min = Math.max(0, (point[plotProp] || 0) - translatedJitter), max = Math.min(axis.len, (point[plotProp] || 0) + translatedJitter);
              point[plotProp] = min + (max - min) * unrandom(i + j * len);
              if (dim === "x") {
                point.clientX = point.plotX;
              }
            }
          }
        });
      });
    }
  }
  drawGraph() {
    if (this.options.lineWidth) {
      super.drawGraph();
    } else if (this.graph) {
      this.graph = this.graph.destroy();
    }
  }
}
ScatterSeries.defaultOptions = merge28(LineSeries4.defaultOptions, ScatterSeriesDefaults_default);
extend24(ScatterSeries.prototype, {
  drawTracker: ColumnSeries3.prototype.drawTracker,
  sorted: false,
  requireSorting: false,
  noSharedTooltip: true,
  trackerGroups: ["group", "markerGroup", "dataLabelsGroup"]
});
addEvent14(ScatterSeries, "afterTranslate", function() {
  this.applyJitter();
});
SeriesRegistry_default.registerSeriesType("scatter", ScatterSeries);

// node_modules/highcharts/es-modules/Series/CenteredUtilities.js
var { deg2rad: deg2rad5 } = Globals_default;
var { fireEvent: fireEvent18, isNumber: isNumber22, pick: pick29, relativeLength: relativeLength5 } = Utilities_default;
var CenteredUtilities;
(function(CenteredUtilities2) {
  function getCenter() {
    const options = this.options, chart = this.chart, slicingRoom = 2 * (options.slicedOffset || 0), plotWidth = chart.plotWidth - 2 * slicingRoom, plotHeight = chart.plotHeight - 2 * slicingRoom, centerOption = options.center, smallestSize = Math.min(plotWidth, plotHeight), thickness = options.thickness;
    let handleSlicingRoom, size = options.size, innerSize = options.innerSize || 0, i, value;
    if (typeof size === "string") {
      size = parseFloat(size);
    }
    if (typeof innerSize === "string") {
      innerSize = parseFloat(innerSize);
    }
    const positions = [
      pick29(centerOption[0], "50%"),
      pick29(centerOption[1], "50%"),
      pick29(size && size < 0 ? undefined : options.size, "100%"),
      pick29(innerSize && innerSize < 0 ? undefined : options.innerSize || 0, "0%")
    ];
    if (chart.angular && !(this instanceof Series_default)) {
      positions[3] = 0;
    }
    for (i = 0;i < 4; ++i) {
      value = positions[i];
      handleSlicingRoom = i < 2 || i === 2 && /%$/.test(value);
      positions[i] = relativeLength5(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) + (handleSlicingRoom ? slicingRoom : 0);
    }
    if (positions[3] > positions[2]) {
      positions[3] = positions[2];
    }
    if (isNumber22(thickness) && thickness * 2 < positions[2] && thickness > 0) {
      positions[3] = positions[2] - thickness * 2;
    }
    fireEvent18(this, "afterGetCenter", { positions });
    return positions;
  }
  CenteredUtilities2.getCenter = getCenter;
  function getStartAndEndRadians(start, end) {
    const startAngle = isNumber22(start) ? start : 0, endAngle = isNumber22(end) && end > startAngle && end - startAngle < 360 ? end : startAngle + 360, correction = -90;
    return {
      start: deg2rad5 * (startAngle + correction),
      end: deg2rad5 * (endAngle + correction)
    };
  }
  CenteredUtilities2.getStartAndEndRadians = getStartAndEndRadians;
})(CenteredUtilities || (CenteredUtilities = {}));
var CenteredUtilities_default = CenteredUtilities;

// node_modules/highcharts/es-modules/Series/Pie/PiePoint.js
var { setAnimation: setAnimation5 } = AnimationUtilities_default;
var { addEvent: addEvent15, defined: defined20, extend: extend25, isNumber: isNumber23, pick: pick30, relativeLength: relativeLength6 } = Utilities_default;

class PiePoint extends Point_default {
  getConnectorPath(dataLabel) {
    const labelPosition = dataLabel.dataLabelPosition, options = dataLabel.options || {}, connectorShape = options.connectorShape, shapeFunc = this.connectorShapes[connectorShape] || connectorShape;
    return labelPosition && shapeFunc.call(this, {
      ...labelPosition.computed,
      alignment: labelPosition.alignment
    }, labelPosition.connectorPosition, options) || [];
  }
  getTranslate() {
    return this.sliced && this.slicedTranslation || {
      translateX: 0,
      translateY: 0
    };
  }
  haloPath(size) {
    const shapeArgs = this.shapeArgs;
    return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(shapeArgs.x, shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
      innerR: shapeArgs.r - 1,
      start: shapeArgs.start,
      end: shapeArgs.end,
      borderRadius: shapeArgs.borderRadius
    });
  }
  constructor(series, options, x) {
    super(series, options, x);
    this.half = 0;
    this.name ?? (this.name = "Slice");
    const toggleSlice = (e) => {
      this.slice(e.type === "select");
    };
    addEvent15(this, "select", toggleSlice);
    addEvent15(this, "unselect", toggleSlice);
  }
  isValid() {
    return isNumber23(this.y) && this.y >= 0;
  }
  setVisible(vis, redraw = true) {
    if (vis !== this.visible) {
      this.update({
        visible: vis ?? !this.visible
      }, redraw, undefined, false);
    }
  }
  slice(sliced, redraw, animation) {
    const series = this.series, chart = series.chart;
    setAnimation5(animation, chart);
    redraw = pick30(redraw, true);
    this.sliced = this.options.sliced = sliced = defined20(sliced) ? sliced : !this.sliced;
    series.options.data[series.data.indexOf(this)] = this.options;
    if (this.graphic) {
      this.graphic.animate(this.getTranslate());
    }
  }
}
extend25(PiePoint.prototype, {
  connectorShapes: {
    fixedOffset: function(labelPosition, connectorPosition, options) {
      const { breakAt, touchingSliceAt } = connectorPosition, lineSegment = options.softConnector ? [
        "C",
        labelPosition.x + (labelPosition.alignment === "left" ? -5 : 5),
        labelPosition.y,
        2 * breakAt.x - touchingSliceAt.x,
        2 * breakAt.y - touchingSliceAt.y,
        breakAt.x,
        breakAt.y
      ] : [
        "L",
        breakAt.x,
        breakAt.y
      ];
      return [
        ["M", labelPosition.x, labelPosition.y],
        lineSegment,
        ["L", touchingSliceAt.x, touchingSliceAt.y]
      ];
    },
    straight: function(labelPosition, connectorPosition) {
      const touchingSliceAt = connectorPosition.touchingSliceAt;
      return [
        ["M", labelPosition.x, labelPosition.y],
        ["L", touchingSliceAt.x, touchingSliceAt.y]
      ];
    },
    crookedLine: function(labelPosition, connectorPosition, options) {
      const { breakAt, touchingSliceAt } = connectorPosition, { series } = this, [cx, cy, diameter] = series.center, r = diameter / 2, { plotLeft, plotWidth } = series.chart, leftAligned = labelPosition.alignment === "left", { x, y } = labelPosition;
      let crookX = breakAt.x;
      if (options.crookDistance) {
        const crookDistance = relativeLength6(options.crookDistance, 1);
        crookX = leftAligned ? cx + r + (plotWidth + plotLeft - cx - r) * (1 - crookDistance) : plotLeft + (cx - r) * crookDistance;
      } else {
        crookX = cx + (cy - y) * Math.tan((this.angle || 0) - Math.PI / 2);
      }
      const path = [["M", x, y]];
      if (leftAligned ? crookX <= x && crookX >= breakAt.x : crookX >= x && crookX <= breakAt.x) {
        path.push(["L", crookX, y]);
      }
      path.push(["L", breakAt.x, breakAt.y], ["L", touchingSliceAt.x, touchingSliceAt.y]);
      return path;
    }
  }
});
var PiePoint_default = PiePoint;

// node_modules/highcharts/es-modules/Series/Pie/PieSeriesDefaults.js
var PieSeriesDefaults = {
  borderRadius: 3,
  center: [null, null],
  clip: false,
  colorByPoint: true,
  dataLabels: {
    connectorPadding: 5,
    connectorShape: "crookedLine",
    crookDistance: undefined,
    distance: 30,
    enabled: true,
    formatter: function() {
      return this.point.isNull ? undefined : this.point.name;
    },
    softConnector: true,
    x: 0
  },
  fillColor: undefined,
  ignoreHiddenPoint: true,
  inactiveOtherPoints: true,
  legendType: "point",
  marker: null,
  size: null,
  showInLegend: false,
  slicedOffset: 10,
  stickyTracking: false,
  tooltip: {
    followPointer: true
  },
  borderColor: "#ffffff",
  borderWidth: 1,
  lineWidth: undefined,
  states: {
    hover: {
      brightness: 0.1
    }
  }
};
var PieSeriesDefaults_default = PieSeriesDefaults;

// node_modules/highcharts/es-modules/Series/Pie/PieSeries.js
var { getStartAndEndRadians } = CenteredUtilities_default;
var { noop: noop3 } = Globals_default;
var { clamp: clamp8, extend: extend26, fireEvent: fireEvent19, merge: merge29, pick: pick31 } = Utilities_default;

class PieSeries extends Series_default {
  animate(init) {
    const series = this, points = series.points, startAngleRad = series.startAngleRad;
    if (!init) {
      points.forEach(function(point) {
        const { graphic, shapeArgs: args } = point;
        if (graphic && args) {
          graphic.attr({
            r: pick31(point.startR, series.center && series.center[3] / 2),
            start: startAngleRad,
            end: startAngleRad
          });
          graphic.animate({
            r: args.r,
            start: args.start,
            end: args.end
          }, series.options.animation);
        }
      });
    }
  }
  drawEmpty() {
    const start = this.startAngleRad, end = this.endAngleRad, options = this.options;
    let centerX, centerY;
    if (this.total === 0 && this.center) {
      centerX = this.center[0];
      centerY = this.center[1];
      if (!this.graph) {
        this.graph = this.chart.renderer.arc(centerX, centerY, this.center[1] / 2, 0, start, end).addClass("highcharts-empty-series").add(this.group);
      }
      this.graph.attr({
        d: Symbols_default.arc(centerX, centerY, this.center[2] / 2, 0, {
          start,
          end,
          innerR: this.center[3] / 2
        })
      });
      if (!this.chart.styledMode) {
        this.graph.attr({
          "stroke-width": options.borderWidth,
          fill: options.fillColor || "none",
          stroke: options.color || "#cccccc"
        });
      }
    } else if (this.graph) {
      this.graph = this.graph.destroy();
    }
  }
  drawPoints() {
    const renderer = this.chart.renderer;
    this.points.forEach(function(point) {
      if (point.graphic && point.hasNewShapeType()) {
        point.graphic = point.graphic.destroy();
      }
      if (!point.graphic) {
        point.graphic = renderer[point.shapeType](point.shapeArgs).add(point.series.group);
        point.delayedRendering = true;
      }
    });
  }
  generatePoints() {
    super.generatePoints();
    this.updateTotals();
  }
  getX(y, left, point, dataLabel) {
    const center = this.center, radius = this.radii ? this.radii[point.index] || 0 : center[2] / 2, labelPosition = dataLabel.dataLabelPosition, distance = labelPosition?.distance || 0;
    const angle = Math.asin(clamp8((y - center[1]) / (radius + distance), -1, 1));
    const x = center[0] + (left ? -1 : 1) * (Math.cos(angle) * (radius + distance)) + (distance > 0 ? (left ? -1 : 1) * (dataLabel.padding || 0) : 0);
    return x;
  }
  hasData() {
    return !!this.processedXData.length;
  }
  redrawPoints() {
    const series = this, chart = series.chart;
    let groupTranslation, graphic, pointAttr, shapeArgs;
    this.drawEmpty();
    if (series.group && !chart.styledMode) {
      series.group.shadow(series.options.shadow);
    }
    series.points.forEach(function(point) {
      const animateTo = {};
      graphic = point.graphic;
      if (!point.isNull && graphic) {
        shapeArgs = point.shapeArgs;
        groupTranslation = point.getTranslate();
        if (!chart.styledMode) {
          pointAttr = series.pointAttribs(point, point.selected && "select");
        }
        if (!point.delayedRendering) {
          graphic.setRadialReference(series.center);
          if (!chart.styledMode) {
            merge29(true, animateTo, pointAttr);
          }
          merge29(true, animateTo, shapeArgs, groupTranslation);
          graphic.animate(animateTo);
        } else {
          graphic.setRadialReference(series.center).attr(shapeArgs).attr(groupTranslation);
          if (!chart.styledMode) {
            graphic.attr(pointAttr).attr({ "stroke-linejoin": "round" });
          }
          point.delayedRendering = false;
        }
        graphic.attr({
          visibility: point.visible ? "inherit" : "hidden"
        });
        graphic.addClass(point.getClassName(), true);
      } else if (graphic) {
        point.graphic = graphic.destroy();
      }
    });
  }
  sortByAngle(points, sign) {
    points.sort(function(a, b) {
      return typeof a.angle !== "undefined" && (b.angle - a.angle) * sign;
    });
  }
  translate(positions) {
    fireEvent19(this, "translate");
    this.generatePoints();
    const series = this, precision = 1000, options = series.options, slicedOffset = options.slicedOffset, radians = getStartAndEndRadians(options.startAngle, options.endAngle), startAngleRad = series.startAngleRad = radians.start, endAngleRad = series.endAngleRad = radians.end, circ = endAngleRad - startAngleRad, points = series.points, ignoreHiddenPoint = options.ignoreHiddenPoint, len = points.length;
    let start, end, angle, radiusX, radiusY, i, point, cumulative = 0;
    if (!positions) {
      series.center = positions = series.getCenter();
    }
    for (i = 0;i < len; i++) {
      point = points[i];
      start = startAngleRad + cumulative * circ;
      if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
        cumulative += point.percentage / 100;
      }
      end = startAngleRad + cumulative * circ;
      const shapeArgs = {
        x: positions[0],
        y: positions[1],
        r: positions[2] / 2,
        innerR: positions[3] / 2,
        start: Math.round(start * precision) / precision,
        end: Math.round(end * precision) / precision
      };
      point.shapeType = "arc";
      point.shapeArgs = shapeArgs;
      angle = (end + start) / 2;
      if (angle > 1.5 * Math.PI) {
        angle -= 2 * Math.PI;
      } else if (angle < -Math.PI / 2) {
        angle += 2 * Math.PI;
      }
      point.slicedTranslation = {
        translateX: Math.round(Math.cos(angle) * slicedOffset),
        translateY: Math.round(Math.sin(angle) * slicedOffset)
      };
      radiusX = Math.cos(angle) * positions[2] / 2;
      radiusY = Math.sin(angle) * positions[2] / 2;
      point.tooltipPos = [
        positions[0] + radiusX * 0.7,
        positions[1] + radiusY * 0.7
      ];
      point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
      point.angle = angle;
    }
    fireEvent19(series, "afterTranslate");
  }
  updateTotals() {
    const points = this.points, len = points.length, ignoreHiddenPoint = this.options.ignoreHiddenPoint;
    let i, point, total = 0;
    for (i = 0;i < len; i++) {
      point = points[i];
      if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
        total += point.y;
      }
    }
    this.total = total;
    for (i = 0;i < len; i++) {
      point = points[i];
      point.percentage = total > 0 && (point.visible || !ignoreHiddenPoint) ? point.y / total * 100 : 0;
      point.total = total;
    }
  }
}
PieSeries.defaultOptions = merge29(Series_default.defaultOptions, PieSeriesDefaults_default);
extend26(PieSeries.prototype, {
  axisTypes: [],
  directTouch: true,
  drawGraph: undefined,
  drawTracker: ColumnSeries_default.prototype.drawTracker,
  getCenter: CenteredUtilities_default.getCenter,
  getSymbol: noop3,
  invertible: false,
  isCartesian: false,
  noSharedTooltip: true,
  pointAttribs: ColumnSeries_default.prototype.pointAttribs,
  pointClass: PiePoint_default,
  requireSorting: false,
  searchPoint: noop3,
  trackerGroups: ["group", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("pie", PieSeries);

// node_modules/highcharts/es-modules/Series/Pie/PieDataLabel.js
var { composed: composed7, noop: noop4 } = Globals_default;
var { distribute: distribute3 } = RendererUtilities_default;
var { series: Series10 } = SeriesRegistry_default;
var { arrayMax: arrayMax5, clamp: clamp9, defined: defined21, pick: pick32, pushUnique: pushUnique10, relativeLength: relativeLength7 } = Utilities_default;
var ColumnDataLabel2;
(function(ColumnDataLabel3) {
  const dataLabelPositioners = {
    radialDistributionY: function(point, dataLabel) {
      return (dataLabel.dataLabelPosition?.top || 0) + point.distributeBox.pos;
    },
    radialDistributionX: function(series, point, y, naturalY, dataLabel) {
      const pos = dataLabel.dataLabelPosition;
      return series.getX(y < (pos?.top || 0) + 2 || y > (pos?.bottom || 0) - 2 ? naturalY : y, point.half, point, dataLabel);
    },
    justify: function(point, dataLabel, radius, seriesCenter) {
      return seriesCenter[0] + (point.half ? -1 : 1) * (radius + (dataLabel.dataLabelPosition?.distance || 0));
    },
    alignToPlotEdges: function(dataLabel, half, plotWidth, plotLeft) {
      const dataLabelWidth = dataLabel.getBBox().width;
      return half ? dataLabelWidth + plotLeft : plotWidth - dataLabelWidth - plotLeft;
    },
    alignToConnectors: function(points, half, plotWidth, plotLeft) {
      let maxDataLabelWidth = 0, dataLabelWidth;
      points.forEach(function(point) {
        dataLabelWidth = point.dataLabel.getBBox().width;
        if (dataLabelWidth > maxDataLabelWidth) {
          maxDataLabelWidth = dataLabelWidth;
        }
      });
      return half ? maxDataLabelWidth + plotLeft : plotWidth - maxDataLabelWidth - plotLeft;
    }
  };
  function compose(PieSeriesClass) {
    DataLabel_default.compose(Series10);
    if (pushUnique10(composed7, "PieDataLabel")) {
      const pieProto = PieSeriesClass.prototype;
      pieProto.dataLabelPositioners = dataLabelPositioners;
      pieProto.alignDataLabel = noop4;
      pieProto.drawDataLabels = drawDataLabels;
      pieProto.getDataLabelPosition = getDataLabelPosition;
      pieProto.placeDataLabels = placeDataLabels;
      pieProto.verifyDataLabelOverflow = verifyDataLabelOverflow;
    }
  }
  ColumnDataLabel3.compose = compose;
  function getDataLabelPosition(point, distance) {
    const { center, options } = this, r = center[2] / 2, angle = point.angle || 0, cosAngle = Math.cos(angle), sinAngle = Math.sin(angle), x = center[0] + cosAngle * r, y = center[1] + sinAngle * r, finalConnectorOffset = Math.min((options.slicedOffset || 0) + (options.borderWidth || 0), distance / 5);
    return {
      natural: {
        x: x + cosAngle * distance,
        y: y + sinAngle * distance
      },
      computed: {},
      alignment: distance < 0 ? "center" : point.half ? "right" : "left",
      connectorPosition: {
        breakAt: {
          x: x + cosAngle * finalConnectorOffset,
          y: y + sinAngle * finalConnectorOffset
        },
        touchingSliceAt: {
          x,
          y
        }
      },
      distance
    };
  }
  function drawDataLabels() {
    const series = this, points = series.points, chart = series.chart, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotLeft = chart.plotLeft, maxWidth = Math.round(chart.chartWidth / 3), seriesCenter = series.center, radius = seriesCenter[2] / 2, centerY = seriesCenter[1], halves = [
      [],
      []
    ], overflow = [0, 0, 0, 0], dataLabelPositioners2 = series.dataLabelPositioners;
    let connector, dataLabelWidth, labelHeight, maxLabelDistance = 0;
    if (!series.visible || !series.hasDataLabels?.()) {
      return;
    }
    points.forEach((point) => {
      (point.dataLabels || []).forEach((dataLabel) => {
        if (dataLabel.shortened) {
          dataLabel.attr({
            width: "auto"
          }).css({
            width: "auto",
            textOverflow: "clip"
          });
          dataLabel.shortened = false;
        }
      });
    });
    Series10.prototype.drawDataLabels.apply(series);
    points.forEach((point) => {
      (point.dataLabels || []).forEach((dataLabel, i) => {
        const r = seriesCenter[2] / 2, dataLabelOptions = dataLabel.options, distance = relativeLength7(dataLabelOptions?.distance || 0, r);
        if (i === 0) {
          halves[point.half].push(point);
        }
        if (!defined21(dataLabelOptions?.style?.width)) {
          if (dataLabel.getBBox().width > maxWidth) {
            dataLabel.css({
              width: Math.round(maxWidth * 0.7) + "px"
            });
            dataLabel.shortened = true;
          }
        }
        dataLabel.dataLabelPosition = this.getDataLabelPosition(point, distance);
        maxLabelDistance = Math.max(maxLabelDistance, distance);
      });
    });
    halves.forEach((points2, halfIdx) => {
      const length = points2.length, positions = [];
      let top, bottom, size = 0, distributionLength;
      if (!length) {
        return;
      }
      series.sortByAngle(points2, halfIdx - 0.5);
      if (maxLabelDistance > 0) {
        top = Math.max(0, centerY - radius - maxLabelDistance);
        bottom = Math.min(centerY + radius + maxLabelDistance, chart.plotHeight);
        points2.forEach((point) => {
          (point.dataLabels || []).forEach((dataLabel) => {
            const labelPosition = dataLabel.dataLabelPosition;
            if (labelPosition && labelPosition.distance > 0) {
              labelPosition.top = Math.max(0, centerY - radius - labelPosition.distance);
              labelPosition.bottom = Math.min(centerY + radius + labelPosition.distance, chart.plotHeight);
              size = dataLabel.getBBox().height || 21;
              dataLabel.lineHeight = chart.renderer.fontMetrics(dataLabel.text || dataLabel).h + 2 * dataLabel.padding;
              point.distributeBox = {
                target: (dataLabel.dataLabelPosition?.natural.y || 0) - labelPosition.top + dataLabel.lineHeight / 2,
                size,
                rank: point.y
              };
              positions.push(point.distributeBox);
            }
          });
        });
        distributionLength = bottom + size - top;
        distribute3(positions, distributionLength, distributionLength / 5);
      }
      points2.forEach((point) => {
        (point.dataLabels || []).forEach((dataLabel) => {
          const dataLabelOptions = dataLabel.options || {}, distributeBox = point.distributeBox, labelPosition = dataLabel.dataLabelPosition, naturalY = labelPosition?.natural.y || 0, connectorPadding = dataLabelOptions.connectorPadding || 0, lineHeight = dataLabel.lineHeight || 21, bBox = dataLabel.getBBox(), topOffset = (lineHeight - bBox.height) / 2;
          let x = 0, y = naturalY, visibility = "inherit";
          if (labelPosition) {
            if (positions && defined21(distributeBox) && labelPosition.distance > 0) {
              if (typeof distributeBox.pos === "undefined") {
                visibility = "hidden";
              } else {
                labelHeight = distributeBox.size;
                y = dataLabelPositioners2.radialDistributionY(point, dataLabel);
              }
            }
            if (dataLabelOptions.justify) {
              x = dataLabelPositioners2.justify(point, dataLabel, radius, seriesCenter);
            } else {
              switch (dataLabelOptions.alignTo) {
                case "connectors":
                  x = dataLabelPositioners2.alignToConnectors(points2, halfIdx, plotWidth, plotLeft);
                  break;
                case "plotEdges":
                  x = dataLabelPositioners2.alignToPlotEdges(dataLabel, halfIdx, plotWidth, plotLeft);
                  break;
                default:
                  x = dataLabelPositioners2.radialDistributionX(series, point, y - topOffset, naturalY, dataLabel);
              }
            }
            labelPosition.attribs = {
              visibility,
              align: labelPosition.alignment
            };
            labelPosition.posAttribs = {
              x: x + (dataLabelOptions.x || 0) + ({
                left: connectorPadding,
                right: -connectorPadding
              }[labelPosition.alignment] || 0),
              y: y + (dataLabelOptions.y || 0) - lineHeight / 2
            };
            labelPosition.computed.x = x;
            labelPosition.computed.y = y - topOffset;
            if (pick32(dataLabelOptions.crop, true)) {
              dataLabelWidth = dataLabel.getBBox().width;
              let sideOverflow;
              if (x - dataLabelWidth < connectorPadding && halfIdx === 1) {
                sideOverflow = Math.round(dataLabelWidth - x + connectorPadding);
                overflow[3] = Math.max(sideOverflow, overflow[3]);
              } else if (x + dataLabelWidth > plotWidth - connectorPadding && halfIdx === 0) {
                sideOverflow = Math.round(x + dataLabelWidth - plotWidth + connectorPadding);
                overflow[1] = Math.max(sideOverflow, overflow[1]);
              }
              if (y - labelHeight / 2 < 0) {
                overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0]);
              } else if (y + labelHeight / 2 > plotHeight) {
                overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2]);
              }
              labelPosition.sideOverflow = sideOverflow;
            }
          }
        });
      });
    });
    if (arrayMax5(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
      this.placeDataLabels();
      this.points.forEach((point) => {
        (point.dataLabels || []).forEach((dataLabel) => {
          const { connectorColor, connectorWidth = 1 } = dataLabel.options || {}, labelPosition = dataLabel.dataLabelPosition;
          if (connectorWidth) {
            let isNew;
            connector = dataLabel.connector;
            if (labelPosition && labelPosition.distance > 0) {
              isNew = !connector;
              if (!connector) {
                dataLabel.connector = connector = chart.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + point.colorIndex + (point.className ? " " + point.className : "")).add(series.dataLabelsGroup);
              }
              if (!chart.styledMode) {
                connector.attr({
                  "stroke-width": connectorWidth,
                  stroke: connectorColor || point.color || "#666666"
                });
              }
              connector[isNew ? "attr" : "animate"]({
                d: point.getConnectorPath(dataLabel)
              });
              connector.attr({
                visibility: labelPosition.attribs?.visibility
              });
            } else if (connector) {
              dataLabel.connector = connector.destroy();
            }
          }
        });
      });
    }
  }
  function placeDataLabels() {
    this.points.forEach((point) => {
      (point.dataLabels || []).forEach((dataLabel) => {
        const labelPosition = dataLabel.dataLabelPosition;
        if (labelPosition) {
          if (labelPosition.sideOverflow) {
            dataLabel.css({
              width: Math.max(dataLabel.getBBox().width - labelPosition.sideOverflow, 0) + "px",
              textOverflow: (dataLabel.options?.style || {}).textOverflow || "ellipsis"
            });
            dataLabel.shortened = true;
          }
          dataLabel.attr(labelPosition.attribs);
          dataLabel[dataLabel.moved ? "animate" : "attr"](labelPosition.posAttribs);
          dataLabel.moved = true;
        } else if (dataLabel) {
          dataLabel.attr({ y: -9999 });
        }
      });
      delete point.distributeBox;
    }, this);
  }
  function verifyDataLabelOverflow(overflow) {
    const center = this.center, options = this.options, centerOption = options.center, minSize = options.minSize || 80;
    let newSize = minSize, ret = options.size !== null;
    if (!ret) {
      if (centerOption[0] !== null) {
        newSize = Math.max(center[2] - Math.max(overflow[1], overflow[3]), minSize);
      } else {
        newSize = Math.max(center[2] - overflow[1] - overflow[3], minSize);
        center[0] += (overflow[3] - overflow[1]) / 2;
      }
      if (centerOption[1] !== null) {
        newSize = clamp9(newSize, minSize, center[2] - Math.max(overflow[0], overflow[2]));
      } else {
        newSize = clamp9(newSize, minSize, center[2] - overflow[0] - overflow[2]);
        center[1] += (overflow[0] - overflow[2]) / 2;
      }
      if (newSize < center[2]) {
        center[2] = newSize;
        center[3] = Math.min(options.thickness ? Math.max(0, newSize - options.thickness * 2) : Math.max(0, relativeLength7(options.innerSize || 0, newSize)), newSize);
        this.translate(center);
        if (this.drawDataLabels) {
          this.drawDataLabels();
        }
      } else {
        ret = true;
      }
    }
    return ret;
  }
})(ColumnDataLabel2 || (ColumnDataLabel2 = {}));
var PieDataLabel_default = ColumnDataLabel2;

// node_modules/highcharts/es-modules/Core/Geometry/GeometryUtilities.js
var GeometryUtilities;
(function(GeometryUtilities2) {
  function getCenterOfPoints(points) {
    const sum = points.reduce((sum2, point) => {
      sum2.x += point.x;
      sum2.y += point.y;
      return sum2;
    }, { x: 0, y: 0 });
    return {
      x: sum.x / points.length,
      y: sum.y / points.length
    };
  }
  GeometryUtilities2.getCenterOfPoints = getCenterOfPoints;
  function getDistanceBetweenPoints(p1, p2) {
    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
  }
  GeometryUtilities2.getDistanceBetweenPoints = getDistanceBetweenPoints;
  function getAngleBetweenPoints(p1, p2) {
    return Math.atan2(p2.x - p1.x, p2.y - p1.y);
  }
  GeometryUtilities2.getAngleBetweenPoints = getAngleBetweenPoints;
  function pointInPolygon({ x, y }, polygon) {
    const len = polygon.length;
    let i, j, inside = false;
    for (i = 0, j = len - 1;i < len; j = i++) {
      const [x1, y1] = polygon[i], [x2, y2] = polygon[j];
      if (y1 > y !== y2 > y && x < (x2 - x1) * (y - y1) / (y2 - y1) + x1) {
        inside = !inside;
      }
    }
    return inside;
  }
  GeometryUtilities2.pointInPolygon = pointInPolygon;
})(GeometryUtilities || (GeometryUtilities = {}));
var GeometryUtilities_default = GeometryUtilities;

// node_modules/highcharts/es-modules/Extensions/OverlappingDataLabels.js
var chartHideOverlappingLabels = function(labels) {
  const chart = this, len = labels.length, isIntersectRect = (box12, box22) => !(box22.x >= box12.x + box12.width || box22.x + box22.width <= box12.x || box22.y >= box12.y + box12.height || box22.y + box22.height <= box12.y), isPolygonOverlap = (box1Poly, box2Poly) => {
    for (const p of box1Poly) {
      if (pointInPolygon({ x: p[0], y: p[1] }, box2Poly)) {
        return true;
      }
    }
    return false;
  };
  function getAbsoluteBox(label3) {
    if (label3 && (!label3.alignAttr || label3.placed)) {
      const padding = label3.box ? 0 : label3.padding || 0, pos = label3.alignAttr || {
        x: label3.attr("x"),
        y: label3.attr("y")
      }, bBox = label3.getBBox();
      label3.width = bBox.width;
      label3.height = bBox.height;
      return {
        x: pos.x + (label3.parentGroup?.translateX || 0) + padding,
        y: pos.y + (label3.parentGroup?.translateY || 0) + padding,
        width: (label3.width || 0) - 2 * padding,
        height: (label3.height || 0) - 2 * padding,
        polygon: bBox?.polygon
      };
    }
  }
  let label, label1, label2, box1, box2, isLabelAffected = false;
  for (let i = 0;i < len; i++) {
    label = labels[i];
    if (label) {
      label.oldOpacity = label.opacity;
      label.newOpacity = 1;
      label.absoluteBox = getAbsoluteBox(label);
    }
  }
  labels.sort((a, b) => (b.labelrank || 0) - (a.labelrank || 0));
  for (let i = 0;i < len; ++i) {
    label1 = labels[i];
    box1 = label1 && label1.absoluteBox;
    const box1Poly = box1?.polygon;
    for (let j = i + 1;j < len; ++j) {
      label2 = labels[j];
      box2 = label2 && label2.absoluteBox;
      let toHide = false;
      if (box1 && box2 && label1 !== label2 && label1.newOpacity !== 0 && label2.newOpacity !== 0 && label1.visibility !== "hidden" && label2.visibility !== "hidden") {
        const box2Poly = box2.polygon;
        if (box1Poly && box2Poly && box1Poly !== box2Poly) {
          if (isPolygonOverlap(box1Poly, box2Poly)) {
            toHide = true;
          }
        } else if (isIntersectRect(box1, box2)) {
          toHide = true;
        }
        if (toHide) {
          const overlappingLabel = label1.labelrank < label2.labelrank ? label1 : label2, labelText = overlappingLabel.text;
          overlappingLabel.newOpacity = 0;
          if (labelText?.element.querySelector("textPath")) {
            labelText.hide();
          }
        }
      }
    }
  }
  for (const label3 of labels) {
    if (hideOrShow(label3, chart)) {
      isLabelAffected = true;
    }
  }
  if (isLabelAffected) {
    fireEvent20(chart, "afterHideAllOverlappingLabels");
  }
};
var compose = function(ChartClass) {
  const chartProto = ChartClass.prototype;
  if (!chartProto.hideOverlappingLabels) {
    chartProto.hideOverlappingLabels = chartHideOverlappingLabels;
    addEvent16(ChartClass, "render", onChartRender2);
  }
};
var hideOrShow = function(label, chart) {
  let complete, newOpacity, isLabelAffected = false;
  if (label) {
    newOpacity = label.newOpacity;
    if (label.oldOpacity !== newOpacity) {
      if (label.hasClass("highcharts-data-label")) {
        label[newOpacity ? "removeClass" : "addClass"]("highcharts-data-label-hidden");
        complete = function() {
          if (!chart.styledMode) {
            label.css({
              pointerEvents: newOpacity ? "auto" : "none"
            });
          }
        };
        isLabelAffected = true;
        label[label.isOld ? "animate" : "attr"]({ opacity: newOpacity }, undefined, complete);
        fireEvent20(chart, "afterHideOverlappingLabel");
      } else {
        label.attr({
          opacity: newOpacity
        });
      }
    }
    label.isOld = true;
  }
  return isLabelAffected;
};
var onChartRender2 = function() {
  const chart = this;
  let labels = [];
  for (const collector of chart.labelCollectors || []) {
    labels = labels.concat(collector());
  }
  for (const yAxis2 of chart.yAxis || []) {
    if (yAxis2.stacking && yAxis2.options.stackLabels && !yAxis2.options.stackLabels.allowOverlap) {
      objectEach19(yAxis2.stacking.stacks, (stack) => {
        objectEach19(stack, (stackItem) => {
          if (stackItem.label) {
            labels.push(stackItem.label);
          }
        });
      });
    }
  }
  for (const series of chart.series || []) {
    if (series.visible && series.hasDataLabels?.()) {
      const push = (points) => {
        for (const point of points) {
          if (point.visible) {
            (point.dataLabels || []).forEach((label) => {
              const options = label.options || {};
              label.labelrank = pick33(options.labelrank, point.labelrank, point.shapeArgs?.height);
              if (options.allowOverlap ?? Number(options.distance) > 0) {
                label.oldOpacity = label.opacity;
                label.newOpacity = 1;
                hideOrShow(label, chart);
              } else {
                labels.push(label);
              }
            });
          }
        }
      };
      push(series.nodes || []);
      push(series.points);
    }
  }
  this.hideOverlappingLabels(labels);
};
var { pointInPolygon } = GeometryUtilities_default;
var { addEvent: addEvent16, fireEvent: fireEvent20, objectEach: objectEach19, pick: pick33 } = Utilities_default;
var OverlappingDataLabels = {
  compose
};
var OverlappingDataLabels_default = OverlappingDataLabels;

// node_modules/highcharts/es-modules/Extensions/BorderRadius.js
var applyBorderRadius = function(path, i, r) {
  const a = path[i];
  let b = path[i + 1];
  if (b[0] === "Z") {
    b = path[0];
  }
  let line, arc2, fromLineToArc;
  if ((a[0] === "M" || a[0] === "L") && b[0] === "A") {
    line = a;
    arc2 = b;
    fromLineToArc = true;
  } else if (a[0] === "A" && (b[0] === "M" || b[0] === "L")) {
    line = b;
    arc2 = a;
  }
  if (line && arc2 && arc2.params) {
    const bigR = arc2[1], clockwise = arc2[5], params = arc2.params, { start, end, cx, cy } = params;
    const relativeR = clockwise ? bigR - r : bigR + r, angleOfBorderRadius = relativeR ? Math.asin(r / relativeR) : 0, angleOffset = clockwise ? angleOfBorderRadius : -angleOfBorderRadius, distanceBigCenterToStartArc = Math.cos(angleOfBorderRadius) * relativeR;
    if (fromLineToArc) {
      params.start = start + angleOffset;
      line[1] = cx + distanceBigCenterToStartArc * Math.cos(start);
      line[2] = cy + distanceBigCenterToStartArc * Math.sin(start);
      path.splice(i + 1, 0, [
        "A",
        r,
        r,
        0,
        0,
        1,
        cx + bigR * Math.cos(params.start),
        cy + bigR * Math.sin(params.start)
      ]);
    } else {
      params.end = end - angleOffset;
      arc2[6] = cx + bigR * Math.cos(params.end);
      arc2[7] = cy + bigR * Math.sin(params.end);
      path.splice(i + 1, 0, [
        "A",
        r,
        r,
        0,
        0,
        1,
        cx + distanceBigCenterToStartArc * Math.cos(end),
        cy + distanceBigCenterToStartArc * Math.sin(end)
      ]);
    }
    arc2[4] = Math.abs(params.end - params.start) < Math.PI ? 0 : 1;
  }
};
var arc2 = function(x, y, w, h, options = {}) {
  const path = oldArc(x, y, w, h, options), { innerR = 0, r = w, start = 0, end = 0 } = options;
  if (options.open || !options.borderRadius) {
    return path;
  }
  const alpha = end - start, sinHalfAlpha = Math.sin(alpha / 2), borderRadius = Math.max(Math.min(relativeLength8(options.borderRadius || 0, r - innerR), (r - innerR) / 2, r * sinHalfAlpha / (1 + sinHalfAlpha)), 0), innerBorderRadius = Math.min(borderRadius, 2 * (alpha / Math.PI) * innerR);
  let i = path.length - 1;
  while (i--) {
    applyBorderRadius(path, i, i > 1 ? innerBorderRadius : borderRadius);
  }
  return path;
};
var seriesOnAfterColumnTranslate = function() {
  if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
    const { options, yAxis: yAxis2 } = this, percent = options.stacking === "percent", seriesDefault = defaultOptions9.plotOptions?.[this.type]?.borderRadius, borderRadius = optionsToObject(options.borderRadius, isObject11(seriesDefault) ? seriesDefault : {}), reversed = yAxis2.options.reversed;
    for (const point of this.points) {
      const { shapeArgs } = point;
      if (point.shapeType === "roundedRect" && shapeArgs) {
        const { width = 0, height = 0, y = 0 } = shapeArgs;
        let brBoxY = y, brBoxHeight = height;
        if (borderRadius.scope === "stack" && point.stackTotal) {
          const stackEnd = yAxis2.translate(percent ? 100 : point.stackTotal, false, true, false, true), stackThreshold = yAxis2.translate(options.threshold || 0, false, true, false, true), box = this.crispCol(0, Math.min(stackEnd, stackThreshold), 0, Math.abs(stackEnd - stackThreshold));
          brBoxY = box.y;
          brBoxHeight = box.height;
        }
        const flip = (point.negative ? -1 : 1) * (reversed ? -1 : 1) === -1;
        let where = borderRadius.where;
        if (!where && this.is("waterfall") && Math.abs((point.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth) {
          where = "all";
        }
        if (!where) {
          where = "end";
        }
        const r = Math.min(relativeLength8(borderRadius.radius, width), width / 2, where === "all" ? height / 2 : Infinity) || 0;
        if (where === "end") {
          if (flip) {
            brBoxY -= r;
            brBoxHeight += r;
          } else {
            brBoxHeight += r;
          }
        }
        extend27(shapeArgs, { brBoxHeight, brBoxY, r });
      }
    }
  }
};
var compose2 = function(SeriesClass, SVGElementClass, SVGRendererClass) {
  const PieSeriesClass = SeriesClass.types.pie;
  if (!SVGElementClass.symbolCustomAttribs.includes("borderRadius")) {
    const symbols = SVGRendererClass.prototype.symbols;
    addEvent17(SeriesClass, "afterColumnTranslate", seriesOnAfterColumnTranslate, {
      order: 9
    });
    addEvent17(PieSeriesClass, "afterTranslate", pieSeriesOnAfterTranslate);
    SVGElementClass.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY");
    oldArc = symbols.arc;
    oldRoundedRect = symbols.roundedRect;
    symbols.arc = arc2;
    symbols.roundedRect = roundedRect2;
  }
};
var optionsToObject = function(options, seriesBROptions) {
  if (!isObject11(options)) {
    options = { radius: options || 0 };
  }
  return merge30(defaultBorderRadiusOptions, seriesBROptions, options);
};
var pieSeriesOnAfterTranslate = function() {
  const borderRadius = optionsToObject(this.options.borderRadius);
  for (const point of this.points) {
    const shapeArgs = point.shapeArgs;
    if (shapeArgs) {
      shapeArgs.borderRadius = relativeLength8(borderRadius.radius, (shapeArgs.r || 0) - (shapeArgs.innerR || 0));
    }
  }
};
var roundedRect2 = function(x, y, width, height, options = {}) {
  const path = oldRoundedRect(x, y, width, height, options), { r = 0, brBoxHeight = height, brBoxY = y } = options, brOffsetTop = y - brBoxY, brOffsetBtm = brBoxY + brBoxHeight - (y + height), rTop = brOffsetTop - r > -0.1 ? 0 : r, rBtm = brOffsetBtm - r > -0.1 ? 0 : r, cutTop = Math.max(rTop && brOffsetTop, 0), cutBtm = Math.max(rBtm && brOffsetBtm, 0);
  const a = [x + rTop, y], b = [x + width - rTop, y], c = [x + width, y + rTop], d = [
    x + width,
    y + height - rBtm
  ], e = [
    x + width - rBtm,
    y + height
  ], f = [x + rBtm, y + height], g = [x, y + height - rBtm], h = [x, y + rTop];
  const applyPythagoras = (r2, altitude) => Math.sqrt(Math.pow(r2, 2) - Math.pow(altitude, 2));
  if (cutTop) {
    const base = applyPythagoras(rTop, rTop - cutTop);
    a[0] -= base;
    b[0] += base;
    c[1] = h[1] = y + rTop - cutTop;
  }
  if (height < rTop - cutTop) {
    const base = applyPythagoras(rTop, rTop - cutTop - height);
    c[0] = d[0] = x + width - rTop + base;
    e[0] = Math.min(c[0], e[0]);
    f[0] = Math.max(d[0], f[0]);
    g[0] = h[0] = x + rTop - base;
    c[1] = h[1] = y + height;
  }
  if (cutBtm) {
    const base = applyPythagoras(rBtm, rBtm - cutBtm);
    e[0] += base;
    f[0] -= base;
    d[1] = g[1] = y + height - rBtm + cutBtm;
  }
  if (height < rBtm - cutBtm) {
    const base = applyPythagoras(rBtm, rBtm - cutBtm - height);
    c[0] = d[0] = x + width - rBtm + base;
    b[0] = Math.min(c[0], b[0]);
    a[0] = Math.max(d[0], a[0]);
    g[0] = h[0] = x + rBtm - base;
    d[1] = g[1] = y;
  }
  path.length = 0;
  path.push(["M", ...a], ["L", ...b], ["A", rTop, rTop, 0, 0, 1, ...c], ["L", ...d], ["A", rBtm, rBtm, 0, 0, 1, ...e], ["L", ...f], ["A", rBtm, rBtm, 0, 0, 1, ...g], ["L", ...h], ["A", rTop, rTop, 0, 0, 1, ...a], ["Z"]);
  return path;
};
var { defaultOptions: defaultOptions9 } = Defaults_default;
var { noop: noop5 } = Globals_default;
var { addEvent: addEvent17, extend: extend27, isObject: isObject11, merge: merge30, relativeLength: relativeLength8 } = Utilities_default;
var defaultBorderRadiusOptions = {
  radius: 0,
  scope: "stack",
  where: undefined
};
var oldArc = noop5;
var oldRoundedRect = noop5;
var BorderRadius = {
  compose: compose2,
  optionsToObject
};
var BorderRadius_default = BorderRadius;

// node_modules/highcharts/es-modules/Core/Responsive.js
var { diffObjects: diffObjects4, extend: extend28, find: find6, merge: merge31, pick: pick34, uniqueKey: uniqueKey6 } = Utilities_default;
var Responsive;
(function(Responsive2) {
  function compose3(ChartClass) {
    const chartProto = ChartClass.prototype;
    if (!chartProto.matchResponsiveRule) {
      extend28(chartProto, {
        matchResponsiveRule,
        setResponsive
      });
    }
    return ChartClass;
  }
  Responsive2.compose = compose3;
  function matchResponsiveRule(rule, matches) {
    const condition = rule.condition, fn = condition.callback || function() {
      return this.chartWidth <= pick34(condition.maxWidth, Number.MAX_VALUE) && this.chartHeight <= pick34(condition.maxHeight, Number.MAX_VALUE) && this.chartWidth >= pick34(condition.minWidth, 0) && this.chartHeight >= pick34(condition.minHeight, 0);
    };
    if (fn.call(this)) {
      matches.push(rule._id);
    }
  }
  function setResponsive(redraw, reset) {
    const options = this.options.responsive, currentResponsive = this.currentResponsive;
    let ruleIds = [], undoOptions;
    if (!reset && options && options.rules) {
      options.rules.forEach((rule) => {
        if (typeof rule._id === "undefined") {
          rule._id = uniqueKey6();
        }
        this.matchResponsiveRule(rule, ruleIds);
      }, this);
    }
    const mergedOptions = merge31(...ruleIds.map((ruleId) => find6((options || {}).rules || [], (rule) => rule._id === ruleId)).map((rule) => rule && rule.chartOptions));
    mergedOptions.isResponsiveOptions = true;
    ruleIds = ruleIds.toString() || undefined;
    const currentRuleIds = currentResponsive && currentResponsive.ruleIds;
    if (ruleIds !== currentRuleIds) {
      if (currentResponsive) {
        this.currentResponsive = undefined;
        this.updatingResponsive = true;
        this.update(currentResponsive.undoOptions, redraw, true);
        this.updatingResponsive = false;
      }
      if (ruleIds) {
        undoOptions = diffObjects4(mergedOptions, this.options, true, this.collectionsWithUpdate);
        undoOptions.isResponsiveOptions = true;
        this.currentResponsive = {
          ruleIds,
          mergedOptions,
          undoOptions
        };
        if (!this.updatingResponsive) {
          this.update(mergedOptions, redraw, true);
        }
      } else {
        this.currentResponsive = undefined;
      }
    }
  }
})(Responsive || (Responsive = {}));
var Responsive_default = Responsive;

// node_modules/highcharts/es-modules/masters/highcharts.src.js
var G = Globals_default;
G.AST = AST_default;
G.Axis = Axis_default;
G.Chart = Chart_default;
G.Color = Color_default;
G.DataLabel = DataLabel_default;
G.Fx = Fx_default;
G.HTMLElement = HTMLElement_default;
G.Legend = Legend_default;
G.LegendSymbol = LegendSymbol_default;
G.OverlappingDataLabels = G.OverlappingDataLabels || OverlappingDataLabels_default;
G.PlotLineOrBand = PlotLineOrBand_default;
G.Point = Point_default;
G.Pointer = Pointer_default;
G.RendererRegistry = RendererRegistry_default;
G.Series = Series_default;
G.SeriesRegistry = SeriesRegistry_default;
G.StackItem = StackItem_default;
G.SVGElement = SVGElement_default;
G.SVGRenderer = SVGRenderer_default;
G.Templating = Templating_default;
G.Tick = Tick_default;
G.Time = Time_default;
G.Tooltip = Tooltip_default;
G.animate = AnimationUtilities_default.animate;
G.animObject = AnimationUtilities_default.animObject;
G.chart = Chart_default.chart;
G.color = Color_default.parse;
G.dateFormat = Templating_default.dateFormat;
G.defaultOptions = Defaults_default.defaultOptions;
G.distribute = RendererUtilities_default.distribute;
G.format = Templating_default.format;
G.getDeferredAnimation = AnimationUtilities_default.getDeferredAnimation;
G.getOptions = Defaults_default.getOptions;
G.numberFormat = Templating_default.numberFormat;
G.seriesType = SeriesRegistry_default.seriesType;
G.setAnimation = AnimationUtilities_default.setAnimation;
G.setOptions = Defaults_default.setOptions;
G.stop = AnimationUtilities_default.stop;
G.time = Defaults_default.defaultTime;
G.timers = Fx_default.timers;
BorderRadius_default.compose(G.Series, G.SVGElement, G.SVGRenderer);
ColumnDataLabel_default.compose(G.Series.types.column);
DataLabel_default.compose(G.Series);
DateTimeAxis_default.compose(G.Axis);
HTMLElement_default.compose(G.SVGRenderer);
Legend_default.compose(G.Chart);
LogarithmicAxis_default.compose(G.Axis);
OverlappingDataLabels_default.compose(G.Chart);
PieDataLabel_default.compose(G.Series.types.pie);
PlotLineOrBand_default.compose(G.Axis);
Pointer_default.compose(G.Chart);
Responsive_default.compose(G.Chart);
ScrollablePlotArea_default.compose(G.Axis, G.Chart, G.Series);
StackingAxis_default.compose(G.Axis, G.Chart, G.Series);
Tooltip_default.compose(G.Pointer);
Utilities_default.extend(G, Utilities_default);
var highcharts_src_default = G;

// public_scripts/channel.ts
async function renderGraph() {
  const data = await fetch("/api?id=" + getID + "&graphs=true").then((resp) => resp.json());
  const d = data.channelGraphs.dateArr.map((a) => {
    const inputDate = a.toString();
    const [year, month, day] = [
      parseInt(inputDate.slice(0, 4)),
      parseInt(inputDate.slice(4, 6)),
      parseInt(inputDate.slice(6, 8))
    ];
    const isoDate = new Date(Date.UTC(year, month - 1, day)).getTime();
    return isoDate;
  });
  var currCount = data.channelGraphs.counts.filter((a) => a.type == otherWay.find((ab) => ab[1] == getType)?.[0])[0].count;
  var options = {
    chart: {
      type: "area",
      backgroundColor: "transparent",
      zooming: {
        type: "x"
      }
    },
    title: {
      text: ""
    },
    plotOptions: {
      area: {
        threshold: null
      }
    },
    series: [
      {
        name: getType,
        type: "area",
        data: data.channelGraphs.counts.filter((a) => a.type == otherWay.find((ab) => ab[1] == getType)?.[0])[0].array.reverse().map((a, idx) => {
          const curr = currCount;
          currCount -= a;
          return isChange == false ? curr : a;
        }).reverse().map((a, idx) => {
          return [d[idx], a];
        })
      }
    ],
    legend: {
      itemStyle: {
        color: "white"
      }
    },
    xAxis: {
      type: "datetime",
      tickPixelInterval: 150,
      labels: {
        style: {
          color: "white"
        }
      }
    },
    yAxis: {
      title: {
        text: ""
      },
      gridLineColor: "gray",
      labels: {
        style: {
          color: "white"
        }
      }
    },
    accessibility: {
      enabled: false
    },
    credits: {
      text: "studio.nia-statistics.com",
      href: "https://studio.nia-statistics.com/"
    }
  };
  if (!chart)
    chart = highcharts_src_default.chart(document.getElementById("graph"), options);
  else {
    chart.update({
      series: options.series
    });
  }
}
var getOdometer = document.getElementById("odo");
var sideCounts = document.querySelectorAll(".sidecounters");
var getID = location.pathname.split("/")[1].split("/")[0];
var Types = {
  VIDEO_THUMBNAIL_IMPRESSIONS: "Impressions",
  VIEWS: "Views",
  SUBSCRIBERS_NET_CHANGE: "Subscribers",
  RATINGS_LIKES: "Likes",
  RATINGS_DISLIKES: "Dislikes",
  SHARINGS: "Shares",
  COMMENTS: "Comments"
};
var otherWay = Object.entries({
  VIDEO_THUMBNAIL_IMPRESSIONS: "Impressions",
  VIEWS: "Views",
  SUBSCRIBERS_NET_CHANGE: "Subscribers",
  RATINGS_LIKES: "Likes",
  RATINGS_DISLIKES: "Dislikes",
  SHARINGS: "Shares",
  COMMENTS: "Comments"
});
var url = new URL(location.href);
var counter = url.searchParams.get("counter") ?? "SUBSCRIBERS_NET_CHANGE";
var getType = Types[counter];
if (!getType)
  getType = Types["SUBSCRIBERS_NET_CHANGE"];
getData();
setInterval(() => getData(), 2000);
var isChange = false;
document.addEventListener("DOMContentLoaded", async function() {
  renderGraph();
  document.getElementById("isChangeBTN").onclick = () => {
    isChange = isChange == false;
    renderGraph();
  };
});
setInterval(() => {
  renderGraph();
}, 60000);
var chart;
</script><div class="min-h-screen bg-zinc-900 text-white text-center"><br/><div class="max-w-2xl shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/nI5C3yeKkvufYZDr3kHOBktuGJWzqbuoR2jj9z83XMX1rzaCQZUppK-sLksoYt-aJ0dIySBNDQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl">Cheetary</div><div class="opacity-50 text-sm">@CheetaryOfficial</div><div class="flex justify-center items-center"><div id="odo" class="odometer text-center text-5xl md:text-7xl m-auto">831</div></div><div class="opacity-50 text-sm">Subscribers</div></div><div class="mx-auto max-w-2xl grid grid-cols-2 gap-1 mt-1"><a href="/UCoH56JoGy1Lje2LgojRneSA?counter=VIDEO_THUMBNAIL_IMPRESSIONS" class="w-full shadow-lg m-auto p-2 bg-slate-800 rounded-md text-center"><div class="flex justify-center items-center"><div class="odometer text-center text-xl md:text-3xl m-auto sidecounters">238,229</div></div><div class="opacity-50 text-sm">Impressions</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA?counter=VIEWS" class="w-full shadow-lg m-auto p-2 bg-slate-800 rounded-md text-center"><div class="flex justify-center items-center"><div class="odometer text-center text-xl md:text-3xl m-auto sidecounters">179,685</div></div><div class="opacity-50 text-sm">Views</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA?counter=RATINGS_LIKES" class="w-full shadow-lg m-auto p-2 bg-slate-800 rounded-md text-center"><div class="flex justify-center items-center"><div class="odometer text-center text-xl md:text-3xl m-auto sidecounters">3,988</div></div><div class="opacity-50 text-sm">Likes</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA?counter=RATINGS_DISLIKES" class="w-full shadow-lg m-auto p-2 bg-slate-800 rounded-md text-center"><div class="flex justify-center items-center"><div class="odometer text-center text-xl md:text-3xl m-auto sidecounters">284</div></div><div class="opacity-50 text-sm">Dislikes</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA?counter=SHARINGS" class="w-full shadow-lg m-auto p-2 bg-slate-800 rounded-md text-center"><div class="flex justify-center items-center"><div class="odometer text-center text-xl md:text-3xl m-auto sidecounters">135</div></div><div class="opacity-50 text-sm">Shares</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA?counter=COMMENTS" class="w-full shadow-lg m-auto p-2 bg-slate-800 rounded-md text-center"><div class="flex justify-center items-center"><div class="odometer text-center text-xl md:text-3xl m-auto sidecounters">351</div></div><div class="opacity-50 text-sm">Comments</div></a></div><div id="graph" class="max-w-2xl w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center mt-1"></div><div class="max-w-2xl mx-auto flex justify-center items-center mt-5 gap-1"><button id="isChangeBTN" class="w-full  p-2 bg-blue-400 text-white rounded-full px-4 mx-auto text-center">Change graph type (daily/total)</button><a href="/" class="w-full p-2 bg-blue-400 text-white rounded-full px-4 mx-auto text-center">Back</a></div><div class="text-2xl mt-2">Compare</div><div class="max-w-5xl m-auto grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-2 justify-center"><a href="/UCoH56JoGy1Lje2LgojRneSA/UCFqeiSR8Cnqr5N4F9AEpTMA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/wE9rarLVtmPx5pwnq8DoFBCfLwAQKZm2aWsCr4IjpKKDg-tSmINDAHBql3SNa20PJk_gazf2oA=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Milrus">Milrus</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@MilrusWW">@MilrusWW</div><div class="text-4xl">2,859,472</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCGp78rh1uRGo-HvWs1Gpixg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/3tAcpu-U43hIIvsguh-KYG7NrqH5yxRb6xUBJfM45nfJrz1TAB3CX3zpDdHkuiqjFYLs9qHs=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Enter">Enter</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@EnterMCShorts">@EnterMCShorts</div><div class="text-4xl">692,743</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC0CECri_BjurGbExz0pQRmg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/mlAvwzf4YqUJXi8_3K1eFPPCu97cxm_nEjH0PrhZjDQbzeehxYMcwDixjSG5Ub8EMv9ngYZ0zw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="SzaSzabi Shorts">SzaSzabi Shorts</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@SzaSzabiShorts">@SzaSzabiShorts</div><div class="text-4xl">606,930</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCtXr17_O7rHCwPg7icF5E9Q?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/HgBhyXojTagZdnwyCxC0LRJJgdTqTamxP8Il-ea-DWAE5IHegk_rGUNaAyFPhGVAFMFG6AZx=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="KAREL">KAREL</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@KAREL99">@KAREL99</div><div class="text-4xl">202,447</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCdGvqM62VIiVnykAphk3xfw?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/uu-UyCTdqNjrdXqbZ5QJK5J4zV2-BnMDmEG-5eh7v844dF2weZmH4O6A28Cr210fJhBtB7wQOw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="KAREL Shorts">KAREL Shorts</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@KAREL99shorts">@KAREL99shorts</div><div class="text-4xl">176,766</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCd8-fD1QcLHsxk04juSB2kg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/r9_CFTOEmt7knuSRlAUC7B2Q-dEIHefkW_Ci0GUuet6EsnIsdWaHUsdfT0yZxHL0iU6xw8OQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Legendary Beast Fans">Legendary Beast Fans</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@legendarybeastfans">@legendarybeastfans</div><div class="text-4xl">114,276</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC9sAfYw51vThMEMDpV1LTgw?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/obyD5P4vpCdwur-yc3s48vFr0aHEmFGooRCdUO8rRezioO8qii84GTtfMCdIbJaTlpiO_gsC=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="GS">GS</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@GS_GD">@GS_GD</div><div class="text-4xl">61,413</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UClpVRPyMnFhR-LMiWLnCWbQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/9xpAG3n40JUUM-k21tezjYZ00dEEhAToiDjGsLhoEgwaWXGcrJ-pfYW_7kb89eEKcQ56gFgy=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="MrRexta">MrRexta</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@MrRexta">@MrRexta</div><div class="text-4xl">59,059</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCX8PoyrYM2XPsDN3Nh5_foQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/AdiHQFAYbh6ZQyK4w3Jr3vnex0dcsEg_ZdvJ2r9CAWyV3_uvwc_Cp7g5EWEgSqNZkRMRN0-ksw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Skibidle">Skibidle</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@Skibidle">@Skibidle</div><div class="text-4xl">43,888</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCLx_71AviKMmR5DsSXpLPqQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/rHgR09vZ5WYPRY7sLFZldWrOCCzjyMRInGzU1Gpgb4H36hm5s2jwc_sVv9bEJN5vvH5bsW1OSQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="statcounts">statcounts</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@StatCounts">@StatCounts</div><div class="text-4xl">24,598</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCyHI_Z6gDCHcDlvciooQB1Q?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/ytc/AIdro_kVmLLCLk9OEaSBdACOtcca4qbkYJaket9sRKeBLoe-Xlw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="JfreNL Games">JfreNL Games</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@JfreNLGames">@JfreNLGames</div><div class="text-4xl">20,299</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC6AMhXzdB3GgXsRD8VpS77g?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/AlyVL2glNRm8JtSUvDh9rA_-anhaU_l25fNUsKP4T0ttpFOOK51ZDTuuBb4iCQ6vpa5S8zF69g=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="KAREL Plus">KAREL Plus</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@KAREL99plus">@KAREL99plus</div><div class="text-4xl">18,491</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC6z8y5o8uaKuWTxP2zsHxiQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/ytc/AIdro_l27XeFhSDwrpubKuwPHdmmM2S4lNR1Ma5sfMSQiU97xp8=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="SuperWindows78">SuperWindows78</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@SuperWindows78">@SuperWindows78</div><div class="text-4xl">17,907</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCz9n--mDBBs5jKQ0y-7vM0w?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/utQp92GHgStDaL252Q9SehfI9gqKDcvH9f0DtYilbk1gmT2gPgMwBxtvZM_W-eJm9hj1E6mSzrU=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="TRAINAlytics">TRAINAlytics</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@TRAINAlytics">@TRAINAlytics</div><div class="text-4xl">17,146</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCwJMf2dhM7T2drNlIUggf9w?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/zG2O7bqnMKA9PKpcJjdV-2jkUlocsoWf_6zGi7Z0rtT4SHjYCV-uUgHJ2tpwztquKEHOwE-DIw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="oulQ">oulQ</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@gouleqYT">@gouleqYT</div><div class="text-4xl">14,530</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCO2wAyXNTeqYUR7MwH3TULw?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/gI2s4Hi36mrAEfkNJpmrMwa7acpn10_cCgS6sK4fm9ws1XVlMryp9w2j1zcST9ncvFnxMBFIa0E=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="maxxamer bonus">maxxamer bonus</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@maxxamerbonus2532">@maxxamerbonus2532</div><div class="text-4xl">13,446</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCT2ryU039C77JULQGBN1tuQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/d8ZIEKgKXgzf0LNrlUvScIrCmNNK3RJX7m6brrCbzzZKe_bMAhNpQmusLtmUymmB5GUnbLkT-w=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="IvanIO">IvanIO</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@IvanIO_Official">@IvanIO_Official</div><div class="text-4xl">11,847</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCFfRxhOpPt-AmPs4tLtRQSg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/SiWWVCB1-M0124vNIt92VlI9rzt-Syg-Lqp8wXCc2BaoMVdqn8nt6qOPRpol-vDGhOW3TrfGnGQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Pozzis - Minecraft Bedrock">Pozzis - Minecraft Bedrock</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@Pozzis">@Pozzis</div><div class="text-4xl">11,119</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCeGCG8SYUIgFO13NyOe6reQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/Mf7TZwxiqYy3AeT2Jc9EZbDKZHmW36nXOOCWPzzweEzBJGPHInM-TP4SMW2VX6rtQ-UhrkN8=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Nia Stats">Nia Stats</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@niastats">@niastats</div><div class="text-4xl">10,097</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCGJXFC0YsDzVP3ar8RzhCmA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/jGCwCDBUNVtPB0tZQF4XBgacQfEndXKEwF3zn1W8R6qH3UlLuCEzRXaxjj1Ob-A027b9R9bB=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Stats100">Stats100</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@stats100">@stats100</div><div class="text-4xl">8,220</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCTXjlJy0yfMgDdPEaV1NWpg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/PZxEDQMCYc3kZFIRNcFFi_x0OXEOkzHd1itYJKVb33317DwthFoo0R_Z-qJXvAReeKbETnYrWw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Staterested">Staterested</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@Staterested">@Staterested</div><div class="text-4xl">5,328</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCAiavoIkGG7iX7WM6HVaxew?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/tVuZlI3dJcBr4ZpXfga3o68-kydZCXY4xDV3EHMnwo1LbTI02BDNiGMKI7VYQM9Pw1hs96uRkA=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="StayHalalBro">StayHalalBro</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@stayhalal654">@stayhalal654</div><div class="text-4xl">3,870</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCdbCAoWx7GVuRcQXiDRzAbw?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/5Tl0EXsd_pk88zih9PFpmv-qKNCXd_YQ2QLJ4IpMnSHTMwjXsuMX8JoK9NjCtqLTpJlqnVLA=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Choccy Stats">Choccy Stats</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@ChoccyStatistics">@ChoccyStatistics</div><div class="text-4xl">3,471</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCqy3IisYmcCifVl2sPgpWrA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/Z-JC5EQYo7A5z8n6-IYVgqIk5Fy_fQm2h0Z9Z4154mcRyBcqwJBwkbbZTOi0DQLPH65iwVO0=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Vlad Statistics ?! Shorts">Vlad Statistics ?! Shorts</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@vladstatisticsshorts3857">@vladstatisticsshorts3857</div><div class="text-4xl">3,433</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UChfqq_0FuGqrVZ9gBzvMuVA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/kTsCGzb7cPdr2d5Ym8PT7D6GZ6FjZkRAiMAYemZbD9KijgZ96narpnNvsDYyBWIr3CkhuAix=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Ziggy Statistics">Ziggy Statistics</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@ZiggyStatistics">@ZiggyStatistics</div><div class="text-4xl">3,347</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UClOyuxZvQkoHoIn15kNbkUw?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/zZa5_LIZoT_2TqhiNdterb2GFv7oZEI7QcgAJeLeD7_4aHVJZ1VZXciJ_ouplogGy_x-T6VrYw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="HuntingStats378">HuntingStats378</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@HuntingStats378">@HuntingStats378</div><div class="text-4xl">3,221</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCVfKmfOY5SWfx_rt51oG92Q?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/_ZaVlZXRgttXv3Z-Ecf44pXqXJvSC8RSuNNquryvPIwgXQsLdvpXOXS6YDQ3xIbaSSEOQNAOFg=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="HuntingStats378-Random">HuntingStats378-Random</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@HuntingStats378-Random">@HuntingStats378-Random</div><div class="text-4xl">3,147</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCEc7RduJzBZhfV2zHLAVoYA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/kX-8hcjZ5q3nW3lM39GYf1-5RA0V1iTx59qSqAHXW1_dDAfud-SXCQp-E0K5x6G2jWGba1GM3A=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="GeneVR">GeneVR</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@GeneVRVR">@GeneVRVR</div><div class="text-4xl">2,860</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC98HsJRiYIXIbp-Mpzu0SvA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/X3TLdxygD3IX5SpS8ZsU3lcWHlZpG0jB4-B_qkXm3SHixkbwNmYQZ1ZHaJgjsy3k5oqROdThPQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="xdn">xdn</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@xdn22">@xdn22</div><div class="text-4xl">2,794</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC_pjqsbBYQKwhy5aZ0Bkt5w?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/SYhDXNZxea5R4DVC60OeRQ8JyllDgaNG8xlmS7_PfYRI-cFk1ctDK13MCkqEJbmNXMPUIurA5A=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="WTIF2024 / stella!">WTIF2024 / stella!</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@WTIF2024">@WTIF2024</div><div class="text-4xl">2,784</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCQtTdTITPBrcpPDZH0yfXbw?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/Zbjcp0_ObSRxoPygQxR_-sowd9NpNTeV3ibam_YcEw6CJDp7Um5aRY6Qg4IHz-5Z_pzRcGpe=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="twixsee ">twixsee </div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@twinkiette">@twinkiette</div><div class="text-4xl">2,667</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC7v4b5-8E79Bq4MCVa0rQYQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/ytc/AIdro_keTV_3Jjhtlv-f6IAxaL4k-hB79aWngZIM6L7FK6Ko5w=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Redblock">Redblock</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@Redblock">@Redblock</div><div class="text-4xl">2,511</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCYVFzmIe0vCdgSKOhftx6uQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/229Z5Xr_kDO84QS4WCOexrL7Z8sbIcS5EpxEwSH3HUdqLaHyUBNPblrmV_CFq1KotLQhB5qD=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="MrMeta Shorts">MrMeta Shorts</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@MrMetaShorts">@MrMetaShorts</div><div class="text-4xl">2,378</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCpe2y5mn-cfW09saoqFUwNQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/Jo0lxSx-TtBtpCkQhg8yiNHz0q78guezZpyOfUKzTnnSXR5oP7HE6zyJrrSw_7UYec5BJGIx460=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="PeterDaily">PeterDaily</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@PeterDailyOG">@PeterDailyOG</div><div class="text-4xl">2,201</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCTivr_cUaKQBqmQcUI5qo5w?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/uI7k1RPZiF6rf0pnI8ckGgkUDblXdXEM9-6BoFGliKuhHqPz1eo-DvtY-4DtzKO6mWPd5wNhCQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="mcfos">mcfos</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@fossiemc">@fossiemc</div><div class="text-4xl">2,063</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCFKfuinFVNy2Kqfn2jTipag?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/qwn-dW3J7qlqWIsL0xEZ-iqlBpjVl0D8waqu4cG9W5Ho3uUaZrF5604Ok_Fo0ip82VQ5sg6fOCA=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="MrAschtax ">MrAschtax </div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@mr.aschtax">@mr.aschtax</div><div class="text-4xl">1,979</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCGnBFOsv4EjpspOVCAjYFJg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/3_7QDywO2mJSM4R5cc9bUxKS7zzDb3th-sLeEZZjK_vzkQkcInHLP9p7jr-ESCkfn4sDRpWC=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="SkyStats">SkyStats</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@skystats2420">@skystats2420</div><div class="text-4xl">1,720</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCD_yf-w0WZvJbR3LSEfyLhw?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/SusdzSi7IwamJvCxEdePRcT1BHG_KPRtpGpPhvPOvjka87DqYDIjxMPSznf79j1OQbj-f8U3=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="HexagonStatistics">HexagonStatistics</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@HexagonStatistics">@HexagonStatistics</div><div class="text-4xl">1,518</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCLm-i95nb0SCfk7eCL9Z7Eg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/Yp_9gtHnDJtvODVmBYT3Vr9ejJp1vqRzIZGpqyaDfJyoTOtJK2Ack_modhFFjj7gTuGuuM60=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="The Axolotl">The Axolotl</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@TheAxolotlOriginal">@TheAxolotlOriginal</div><div class="text-4xl">1,444</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCFUYEVd36t5zdBF4WqFqDIA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/oG-kpe-RaenPoAtqrj8MEI9rQiojvfi-iEWHeA_nfh8ogqFpGSd65xiIDjhjfAqA6_uCNTO5Jg=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Seni">Seni</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@SeniStats">@SeniStats</div><div class="text-4xl">1,335</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCJoKJM-V1XbFAh8t6yY32mA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/lLFUbIgr3rgHTBc0ak_b4Inp9g3BWeAJUddke5J9t17JHTtHC77-VaPEtWxg3MmayM1a5ZBGpQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="im done here lmao">im done here lmao</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@notanormalpersonjk">@notanormalpersonjk</div><div class="text-4xl">1,280</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCR9xl31xBSsOmjXSlz1OoWA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/ug4tAPvE5_TCj_iOfBSDO4vmP1rQULZCAVJGbs-fuUrc16pyymH6X8fXJu-GBxTLg-iTuZIsFA=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="8-PixelAlex">8-PixelAlex</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@8PixelAlex">@8PixelAlex</div><div class="text-4xl">1,271</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCOkSVsHQV0d4pz36xs6zEFA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/wDzEc60YuUSj3YVbvod7bA9K9CpUvKmVU7KIQ6R9CL1ap6hq2ubAqqu14pMKyIUirEp32DcLOw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Random Milestones">Random Milestones</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@Random_Milestones">@Random_Milestones</div><div class="text-4xl">1,239</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCjrii0S-8k6sfc_ds3V-mRg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/fEffPQngEoYnKisuqdWCypAcVndOqXcnGW3IViZrWfMp5X9859W5BGKDewztKQl1dGXTtYt-Yss=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="CurtisPlays">CurtisPlays</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@CurtisPlaysYT">@CurtisPlaysYT</div><div class="text-4xl">1,169</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCwuOMyTU3KTOc13PjXWMvUA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/81kzZ5GQ3oShpYw_j2H2AlL89sUEpenvD9Wcxv7noNlI0u-XCztgLJ2rf3nFDDcD-G9_CEVb=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="LMALG">LMALG</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@LMALG47">@LMALG47</div><div class="text-4xl">1,143</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCO1x2VAEzphHG9ZAANJ0D5A?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/GzA6k_DOmmxYc-d12Mdb7G3uMsbiGGM8M6NgYwtQ5eU6_S6xR6ro_8YPiiGXdnl8Zx0ywTCq__o=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title=" "> </div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@SpacemobYt">@SpacemobYt</div><div class="text-4xl">1,050</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCP9WhreuypXy7c8gBvKWflg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/cY73EGvzE0QgLGsEeXlKlpYGcbKb7uPKlq0eTGvzfImHP3_nAuXPbuRWdTf6itnZxJPx7t78sA=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="IfyStats">IfyStats</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@IfyStats">@IfyStats</div><div class="text-4xl">946</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCKYUPDAsaCSPYDkdjsz8wTw?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/wgX8YY9vbgY5ys9C1NKdOZalTTKuCZNmc4pGQeg2YJ08NnU7Ft4CtABnUPl3LyRPyGuP3JKVpA=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Tintin4">Tintin4</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@Tintin4">@Tintin4</div><div class="text-4xl">926</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC1y3b962pZdihVyWOdKK2cQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/NOCpWcitiRRnDC_ddkv3md9qM3dLMgxrHiCyjBcA90Ouf0IyH7q37Y_P4gdGUJLXl9JcKu-XKA=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Baritified YTB">Baritified YTB</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@BaritifiedYTB">@BaritifiedYTB</div><div class="text-4xl">789</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCYYIZI3v_uxhOIcGgvUNgKg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/32zaMcb85YqA7fg1pa1-x8EUSkQ7ayDww1vyJYaVTMDtcTq-isJs303RB6WJ1MjUMabuJ0Gvuxk=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="George Is Random">George Is Random</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@GeorgeIsRandom">@GeorgeIsRandom</div><div class="text-4xl">780</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCMcItRaCvywVwgR4x_jJqlQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/b4Gn1W9sX8ooYuq66ry0mjJE5HldLwL1flO7ASfyqsmfIMFvdaueSNsxBvVntccDOk0wCWSFzw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Rexta">Rexta</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@MrRextaYT">@MrRextaYT</div><div class="text-4xl">578</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCcezNpcKHm5ZFgtCcVDfgJg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/9KAoo0X-aRPWwMAaU0Z93q_EyvGK4uW0luo9asZVP9UEl52d7BQNfxoSqA_BrlvkpGYmhcbEsiQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="55Stats">55Stats</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@55Stats">@55Stats</div><div class="text-4xl">558</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCBGLzdRIWaYyZl-Y6uxMVaA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/F5W_zvuKIIjsbLoJW_AUCYc4J27HWQ0rxfoeUiVDLmTcbaeENlKqzS999g78BZ54DwdTVS1oVQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Laura Paris">Laura Paris</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@LauraParisBear">@LauraParisBear</div><div class="text-4xl">540</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCz7iouByfcs26DZjImVe6VQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/6zlXgSf28NGyhdshC5NFO5ThPyClCb7sM02zF_SJzi7AaDN9D0l_bFWoXdTG5QH1WzO_DaSN=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="alexdrinkswater">alexdrinkswater</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@alexdrinkswateryt.">@alexdrinkswateryt.</div><div class="text-4xl">537</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCHyWlppyelhTaxf9BC8H8PA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/b0P6nqq6595xjVmBOAsQzOz4Fv3RvQqOkH9Scgzuo-mQzZKI5J7fkX-g7IfMY4rDZjkdJcqAOQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="MrMeta Stats">MrMeta Stats</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@MrMeta1230">@MrMeta1230</div><div class="text-4xl">510</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC5tA-t9rZwrC5aI0WI3F0xg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/l1B5xc24IMjjqbXnw3DAA7djd21Fj5DZRteKOod8A4OfcK58Kqwhl4-B0OLTOBBR4Yir4SNR=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="downloads folder sh,tposts">downloads folder sh,tposts</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@downloadsfolder69420">@downloadsfolder69420</div><div class="text-4xl">465</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCGNFzx44gUxXWvFsAgx6lLA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/Oklh61OZ2ipD5uWbmogbsz7F907Nx4Y-1QNCwf_mHHR8yO4gi7j_wJ9E4TdSAQ7FXFSmqi6C=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="{UTA}elmoFX09">{UTA}elmoFX09</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@elmofx09">@elmofx09</div><div class="text-4xl">460</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC4clLOlxvvcDbpi2Q_ujQlQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/UrackZ6ziuDMVDKe8bFr765nYSL28BVBIbMCB5od-_WqQp5hz-dGtqSnnDJxFBTof5DTrhRZhLY=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Stats Community Visualized">Stats Community Visualized</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@SCVisualized">@SCVisualized</div><div class="text-4xl">423</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCHh6Kxon7PNUu5zKsNtp0ZA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/g9sOmGPeBoOIsDt5kO8rT6xaxazLfMMk_4ExHKN99h5ZqVkUBlRzvhsRDEo4-K6wbWlc7ocCew=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Nia&#x27;s Extra Channel :3">Nia&#x27;s Extra Channel :3</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@mixaxernextra">@mixaxernextra</div><div class="text-4xl">367</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCkaQHnnaXDmdu-OhaCeJUGA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/NOiUhzzxQ2nzEoLHek_bQFdrXMFJQmHZ0rh3tFclV06ofMworZqk5XHXsQSNbOXW2VLUnVBJ5AA=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Trackify">Trackify</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@TrackifyCounts">@TrackifyCounts</div><div class="text-4xl">291</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC4yl4xMgnzAtA0-m98k7kmw?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/7sll4BEa2OYky2fj5_EVhc5yx6dloQHCEMVs2PI0tYF7Yvll03s21EKmzEpq2XZDSVzYEQEcVw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Jdudeo">Jdudeo</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@Jdudeo1">@Jdudeo1</div><div class="text-4xl">250</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC5uxpWO8BlIJ4uHCNT06ndQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/X3oKQ3Yq-iew1TM9ZaVnWMNE3z0CdMcW5gjevIGg0jiKWqHwjBivVtUr7t5Z_6IErXJ7dRxYKw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Nia 2">Nia 2</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@mixaxern_2">@mixaxern_2</div><div class="text-4xl">214</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCzncsMtOzXOo4V4PvSrt8kw?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/Kg6Wuipfl9usA6qLKPOVIKe-sywhnR5ulAF3-gE65g8fGD5uErrp-t6QTBCZOXChX9V3q9Bx=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="leveledstats">leveledstats</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@leveledstats">@leveledstats</div><div class="text-4xl">209</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC5OdAoAgEKJzrFsdbEawK8g?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/EeQZLQsFWQAcFaw0X7GfgXKVSipovA68ZxObBz5I4G-ud4DuoG3FW7lsxKLVQN19xxNCP4menrI=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="    ">    </div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@TalkingFriendsRUS">@TalkingFriendsRUS</div><div class="text-4xl">194</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC0eaMB_D3rlM9XJlyMd78WA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/UvYsiksTImRunKtdFDBS_S_mkpLRAq1ukfV4c6nPfpxLvDrEBd-6io3xxZdwB0yZWXRE3MtC=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="GouleQ">GouleQ</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@GGGouleQ">@GGGouleQ</div><div class="text-4xl">176</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC-vPv-G4WWVveP3Myr9UqoA?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/K4iRcpYlqRmjuUhczh18QoI-XU8LlmZME3J5MOkxH5821XeTRY7c4YX1Ly56Rlj9AvPfGAqHbQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Nia (Bot)">Nia (Bot)</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@NiaBot">@NiaBot</div><div class="text-4xl">137</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCfMX9dhF2ao-0cCPeokdzmg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/Y610Yf3hN2UFeohfCnQbp6j1D3GcMJkIPLpS5wFVfQ9CudU6twOClrInZoI77wbrYwbspiD6tYo=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Laura Gaming">Laura Gaming</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@randomgamerplayz">@randomgamerplayz</div><div class="text-4xl">107</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCT8gCaPj2brQY7D3NBwne-Q?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/yPOIo0ehC-Ds3kOJ4tCPMr3_NgAQCQz4st8xsaINP4CcjP42svjKzkrVBT6tGNK2cJ7sXrKAEA=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Techman">Techman</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@techman_real">@techman_real</div><div class="text-4xl">65</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCyf9RbzsHFZ6I3ci1fFGv6Q?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/0lgquaz6L7vg7H4myvq08Yu69CqQKjKpd-5550aFlIMHPciIobRgMntdvdxiAZ7U6R2pMXLNxrU=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="FNSkullz">FNSkullz</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@SkullzFortnite">@SkullzFortnite</div><div class="text-4xl">54</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCqM8vrIHgvqsxZYmbJEpzpQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/_0K2x-sMH4IaEa4Wgy5q4dgnD5XldJMPrDsvj73TpXpvQLbli_Zs9kaNH4VYw56v0rbbR4gQgw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="luckiz32">luckiz32</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@luckiz32">@luckiz32</div><div class="text-4xl">43</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UC7eS1D1MUyG-dy9y6blADhg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/ytc/AIdro_kTJI2U10xJUzwgbM6i-P7gGAsB97eptahDOG3El00EVNM_=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Charlie Ashford 2">Charlie Ashford 2</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@3">@3</div><div class="text-4xl">42</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCtFymTED6nrbujHVQNjv3Fw?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/j8PrFKMTziGt_qT_3rK1r-Hkk5z-Qu972qnEh4Bb3U5_7kefXSJPOLY9mc1w1oJaBnT-Awdd=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="PeeGeePee">PeeGeePee</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@PeeGeePee">@PeeGeePee</div><div class="text-4xl">35</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCzxt2-Lbe-9rLsU4gA57Q_g?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/ytc/AIdro_kJ8Z_fqKgbGnStiBxzimmgCBz_Rfo86SX2Fdke2TIxAkuCx2plxe9_oMvulNGVXe35MQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="ananyesh">ananyesh</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@ananyesh">@ananyesh</div><div class="text-4xl">33</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCCSWIHk-VCp9Qqg6DOVJbvQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/6D2uPViKdLOzITK4ePvnWqtuwiYyc0HAn4CVXMGAKFi7_xkzmAZE6X7XJgnGHkYxFrrenBHkBac=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="mrbeastfan ">mrbeastfan </div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@Ais12_MrBeastFan_official">@Ais12_MrBeastFan_official</div><div class="text-4xl">13</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCQuILwtULF0iymF5XDN6_qg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/GPs9Zg52fQmxtkXGrTd58036EU8SdeOGV4V5_k2AuhjlmUQ2hR3ec-4JwdEo30ON2rvA5hNemw=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="noname">noname</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@">@</div><div class="text-4xl">13</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCm8tAjVAGTmhU3bdF3wzimg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/eg_5N8cvTJjQMnu4wvVoUy4ES2t0HbuFitpQBJJk24M4CQLfV5aps1qy9BCvhNUGUea5i4Vk=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Communitrics">Communitrics</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@-">@-</div><div class="text-4xl">11</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCYUUgtHNz2vIfNpq9KCZI2w?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/Iq8lfNmumuJPpG_XRp8mB9FwtcC9AX17_4trjUVP58_6c3mNJGAVqFOy4haCQt0lb7OO61f0H6E=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Justynou">Justynou</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@justyynou">@justyynou</div><div class="text-4xl">10</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCTV31jYJsExLOFAKe0KfD4g?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/IBkEs5SSxNjEpONsXwXqG5KzUTocXDlSPAHCwxZJTeoRXDwOHaB86--JCYKiBJOuJiO35wDzxNc=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Avile Statistics">Avile Statistics</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@AvileStatistics">@AvileStatistics</div><div class="text-4xl">8</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCaJdyTbdSD-n-VAe3esGHVQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/r2J2C7RrYPpLjXrcel1MWuyLV7by-KW-5SjVKEtm_EimnmjPgfYPB6FUm2iUjcM6UVc2OunwBQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="ezika">ezika</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@ezikagirl">@ezikagirl</div><div class="text-4xl">6</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCp5tYP16EutCuOPDbeTpwPQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/AkzGxSOGiFEM0RNsq2CK5oTRVToeIq6DO1y69Zx7AtZfxss0L-5n38I2rNdeGcENpmrGRZ20DQ=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Doki Kids TV">Doki Kids TV</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@DokiKidsTV">@DokiKidsTV</div><div class="text-4xl">4</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCE_ngwLQ5Qmq9x4vL8mmzFg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/re5Jv3Rxol4MVgOb3vK-OiL7C114DYEyztCg2gDaGssO0piGh8978OWQrUyND8AYHlPIFf0u=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Quhopian">Quhopian</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@Quhopian">@Quhopian</div><div class="text-4xl">3</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCr40kxP4aP9JCbQxwp-UPjQ?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/ytc/AIdro_lb3v9XwJbntfxcXRhXe3Kn04BiPPObyHdMcDCLvkT1UflNBWVMXbiCh4qWga8o50d-Wg=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="GouleQHas30Accounts">GouleQHas30Accounts</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@GouleQHas30Accounts">@GouleQHas30Accounts</div><div class="text-4xl">2</div><div class="opacity-50 text-sm">Subscribers</div></a><a href="/UCoH56JoGy1Lje2LgojRneSA/UCHbBW81CjKs6EcsvXg9WkQg?counter=SUBSCRIBERS_NET_CHANGE" class="w-full shadow-lg m-auto p-4 bg-slate-800 rounded-md text-center h-full"><img class="m-auto rounded-full" src="https://yt3.ggpht.com/tXQjkE7Kr5kh5z1DkMU-HIgKmIXaXh6cFl76MiSeO9ZZH8J1wm4QMDVNOW9-eVp8g9nsRTFOPfo=s88-c-k-c0x00ffffff-no-rj"/><div class="text-xl whitespace-nowrap overflow-hidden text-ellipsis" title="Affintego">Affintego</div><div class="opacity-50 text-sm whitespace-nowrap overflow-hidden text-ellipsis" title="@Affintego">@Affintego</div><div class="text-4xl">0</div><div class="opacity-50 text-sm">Subscribers</div></a></div><div class="opacity-50 text-sm text-center mt-2">This is all of the information we get from your account. We don&#x27;t look at your videos or anything. Just the total stats.</div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/odometer.js/0.4.7/odometer.min.js"></script></body></html>
